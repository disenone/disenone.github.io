<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    
    <title>Disenone&#39;s Wiki</title>
    <description>无止境</description>
    <link>https://wiki.disenone.site/</link>
    <atom:link href="https://wiki.disenone.site/feed_rss_updated.xml" rel="self" type="application/rss+xml" />

    
    <managingEditor>Disenone</managingEditor>
    <docs>https://github.com/disenone/wiki</docs>
    <language>zh</language>

    
    <pubDate>Tue, 16 Apr 2024 19:34:24 -0000</pubDate>
    <lastBuildDate>Tue, 16 Apr 2024 19:34:24 -0000</lastBuildDate>
    <ttl>1440</ttl>

    
    <generator>MkDocs RSS plugin - v1.12.1</generator>

    
    
    <image>
      <url>https://upload.wikimedia.org/wikipedia/commons/thumb/4/43/Feed-icon.svg/128px-Feed-icon.svg.png</url>
      <title>Disenone's Wiki</title>
      <link>https://wiki.disenone.site/</link>
    </image>
    

    
    
    <item>
      <title>Blog</title>
      
      
      
      
      <description>&lt;h1&gt;Blog&lt;/h1&gt;</description>
      <link>https://wiki.disenone.site/en/blog/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Tue, 16 Apr 2024 19:34:35 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/en/blog/</guid>
      
    </item>
    
    <item>
      <title>Blog</title>
      
      
      
      
      <description>&lt;h1&gt;Blog&lt;/h1&gt;</description>
      <link>https://wiki.disenone.site/blog/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Tue, 16 Apr 2024 19:34:22 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/blog/</guid>
      
    </item>
    
    <item>
      <title>Home</title>
      
      
      
      
      <description>&lt;!-- no translate --&gt;

&lt;h1&gt;Disenone&#39;s Wiki&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/disenone/wiki/actions&#34;&gt;&lt;img alt=&#34;badge&#34; src=&#34;https://github.com/disenone/wiki/actions/workflows/Build.yml/badge.svg?label=Build&amp;amp;style=flat-square&#34;&gt;{ loading=lazy }&lt;/a&gt;
&lt;a href=&#34;https://github.com/disenone/wiki/commits/main&#34;&gt;&lt;img alt=&#34;badge&#34; src=&#34;https://img.shields.io/github/last-commit/disenone/wiki?color=FCD734&amp;amp;label=Last%20commit&amp;amp;style=flat-square&#34;&gt;{ loading=lazy }&lt;/a&gt;
&lt;a href=&#34;contact-and-subscribe&#34;&gt;&lt;img alt=&#34;badge&#34; src=&#34;https://img.shields.io/badge/Contact%20%26%20Subscribe-me-34ABE0?&amp;amp;style=flat-square&#34;&gt;{ loading=lazy }&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;无止境&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hi there~ 欢迎来到我的知识库。&lt;/p&gt;
&lt;p&gt;为了避免遗忘、便于分享，我在这里收录知识。
请随意浏览～&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;cpp-C和Cpp的命令行参数处理总结&#34;&gt;编程技术&lt;/a&gt;{ .md-button }
&lt;a href=&#34;game-游戏AOI算法解析和性能实测&#34;&gt;游戏开发&lt;/a&gt;{ .md-button }&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Tue, 16 Apr 2024 19:24:50 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/</guid>
      
    </item>
    
    <item>
      <title>Contact and Subscribe</title>
      
      
      
      
      <description>&lt;h1&gt;Contact and Subscribe&lt;/h1&gt;
&lt;!-- no translate --&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/disenone&#34;&gt;&lt;img alt=&#34;badge&#34; src=&#34;https://img.shields.io/badge/GitHub-282c34?&amp;amp;style=for-the-badge&#34;&gt;&lt;/a&gt;
&lt;a href=&#34;mailto:disenonec@gmail.com&#34;&gt;&lt;img alt=&#34;badge&#34; src=&#34;https://img.shields.io/badge/Email-f48222?&amp;amp;style=for-the-badge&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://wiki.disenone.site/sitemap.xml&#34;&gt;&lt;img alt=&#34;badge&#34; src=&#34;https://img.shields.io/badge/Sitemap-green?&amp;amp;style=flat-square&#34;&gt;{ loading=lazy }&lt;/a&gt;
&lt;a href=&#34;https://wiki.disenone.site/feed_rss_created.xml&#34;&gt;&lt;img alt=&#34;badge&#34; src=&#34;https://img.shields.io/badge/RSS-post%20created-pcf?&amp;amp;style=flat-square&#34;&gt;{ loading=lazy }&lt;/a&gt;
&lt;a href=&#34;https://wiki.disenone.site/feed_rss_updated.xml&#34;&gt;&lt;img alt=&#34;badge&#34; src=&#34;https://img.shields.io/badge/RSS-post%20updated-yellowgreen?&amp;amp;style=flat-square&#34;&gt;{ loading=lazy }&lt;/a&gt;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/contact-and-subscribe/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Mon, 15 Apr 2024 02:57:59 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/contact-and-subscribe/</guid>
      
    </item>
    
    <item>
      <title>UE 编辑器插件 UE.EditorPlus 说明文档</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;UE 编辑器插件 EditorPlus 说明文档&#34; /&gt;&lt;/p&gt;
&lt;h1&gt;UE 编辑器插件 UE.EditorPlus 说明文档&lt;/h1&gt;
&lt;h2&gt;介绍视频&lt;/h2&gt;
&lt;p&gt;&lt;img alt=&#34;type:video&#34; src=&#34;assets/img/2024-ue-editorplus/market/video.mp4&#34;&gt;&lt;/p&gt;
&lt;h2&gt;插件源码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/disenone/UE.EditorPlus&#34;&gt;UE.EditorPlus&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;项目添加源码插件 EU.EditorPlus&lt;/h2&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中文：&lt;a href=&#34;https://wiki.disenone.site/ue-%E9%80%9A%E8%BF%87%E6%8F%92%E4%BB%B6%E6%BA%90%E7%A0%81%E6%B7%BB%E5%8A%A0%E6%8F%92%E4%BB%B6/&#34;&gt;UE 通过插件源码添加插件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;English: &lt;a href=&#34;https://wiki.disenone.site/en/ue-%E9%80%9A%E8%BF%87%E6%8F%92%E4%BB%B6%E6%BA%90%E7%A0%81%E6%B7%BB%E5%8A%A0%E6%8F%92%E4%BB%B6/&#34;&gt;UE adds plugins through the plugin source code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;插件说明&lt;/h2&gt;
&lt;p&gt;UE.EditorPlus 是一个 UE 编辑器插件，提供了一种方便的方式来扩展编辑器菜单，并支持高级方式来扩展，同时包含了一些实用的编辑器工具。本插件支持 UE5.3+。&lt;/p&gt;
&lt;h2&gt;扩展编辑器菜单&lt;/h2&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2024-ue-editorplus/menu.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2024-ue-editorplus/toolbar.png&#34;&gt;&lt;/p&gt;
&lt;h3&gt;说明&lt;/h3&gt;
&lt;p&gt;支持多种方式扩展编辑器菜单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路径方式：&lt;code&gt;RegisterPathAction(&#34;/&amp;lt;MenuBar&amp;gt;Bar/&amp;lt;SubMenu&amp;gt;SubMenu/&amp;lt;Command&amp;gt;Action&#34;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实例化方式：&lt;code&gt;EP_NEW_MENU(FEditorPlusMenuBar)(&#34;Bar&#34;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;混合方式：&lt;code&gt;RegisterPath(&#34;/&amp;lt;MenuBar&amp;gt;Bar/&amp;lt;SubMenu&amp;gt;SubMenu/&amp;lt;Command&amp;gt;Action&#34;,EP_NEW_MENU(FEditorPlusCommand)(&#34;Action&#34;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;路径方式&lt;/h3&gt;
&lt;p&gt;可以通过这样的方式来注册一个编辑器菜单指令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
FEditorPlusPath::RegisterPathAction(
    &#34;/&amp;lt;MenuBar&amp;gt;Bar/&amp;lt;SubMenu&amp;gt;SubMenu/&amp;lt;Command&amp;gt;Action&#34;,
    FExecuteAction::CreateLambda([]
        {
            // do action
        })
);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样就可以在编辑器菜单栏 Help 后面增加一个菜单栏 Bar，Bar 里面增加一个子菜单 SubMenu， SubMenu 里面增加一个命令 Action。&lt;/p&gt;
&lt;p&gt;完整的路径格式会是这样的：&lt;code&gt;/&amp;lt;Hook&amp;gt;HookName/&amp;lt;Type1&amp;gt;Name1/&amp;lt;Type2&amp;gt;Name2&lt;/code&gt;，第一个路径必须是 &lt;code&gt;&amp;lt;Hook&amp;gt;&lt;/code&gt;，目前支持的类型和限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Hook&amp;gt;&lt;/code&gt;：表示需要在哪个 Hook 的位置上生成菜单，后续路径不能有 &lt;code&gt;&amp;lt;Hook&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;MenuBar&amp;gt;&lt;/code&gt;：菜单栏，后面路径不能有 &lt;code&gt;&amp;lt;Hook&amp;gt;, &amp;lt;MenuBar&amp;gt;, &amp;lt;ToolBar&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;ToolBar&amp;gt;&lt;/code&gt;: 工具栏，后面路径不能有 &lt;code&gt;&amp;lt;Hook&amp;gt;, &amp;lt;MenuBar&amp;gt;, &amp;lt;ToolBar&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Section&amp;gt;&lt;/code&gt;：菜单分节，后面路径不能有 &lt;code&gt;&amp;lt;Hook&amp;gt;, &amp;lt;MenuBar&amp;gt;, &amp;lt;Section&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Separator&amp;gt;&lt;/code&gt;：菜单分隔符，后面路径不能有 &lt;code&gt;&amp;lt;Hook&amp;gt;, &amp;lt;MenuBar&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;SubMenu&amp;gt;&lt;/code&gt;：子菜单，后面路径不能有 &lt;code&gt;&amp;lt;Hook&amp;gt;, &amp;lt;MenuBar&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Command&amp;gt;&lt;/code&gt;：菜单命令，后面不能有任何路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Widget&amp;gt;&lt;/code&gt;：更多可扩展定制的 Slate UI 组件，后面不能有任何路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更简易的路径形式：&lt;code&gt;/BarName/SubMenuName1/SubMenuName2/CommandName&lt;/code&gt;，如果不指定类型，默认路径的第一个是 &lt;code&gt;&amp;lt;MenuBar&amp;gt;&lt;/code&gt;，中间的是 &lt;code&gt;&amp;lt;SubMenu&amp;gt;&lt;/code&gt;，最后的是 &lt;code&gt;&amp;lt;Command&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果没有指定 &lt;code&gt;&amp;lt;Hook&amp;gt;&lt;/code&gt; 则自动最前面加上 &lt;code&gt;&amp;lt;Hook&amp;gt;Help&lt;/code&gt;，表示在 Help 菜单后面添加菜单栏。&lt;/p&gt;
&lt;h3&gt;实例化方式&lt;/h3&gt;
&lt;p&gt;路径方式是自动把所有节点根据类型和默认参数实例化出来，我们也可以自己控制实例化，可以更细致控制扩展的内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
EP_NEW_MENU(FEditorPlusMenuBar)(&#34;MyBar&#34;, &#34;MyBar&#34;, LOCTEXT(&#34;MyBar&#34;, &#34;MyBar&#34;), LOCTEXT(&#34;MyBarTips&#34;, &#34;MyBarTips&#34;))
-&amp;gt;RegisterPath()
-&amp;gt;Content({
    EP_NEW_MENU(FEditorPlusSubMenu)(&#34;MySubMenu&#34;)
    -&amp;gt;Content({
        EP_NEW_MENU(FEditorPlusCommand)(&#34;MyAction&#34;)
        -&amp;gt;BindAction(FExecuteAction::CreateLambda([]
            {
                // do action
            })),
    })
});&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;实例化 &lt;code&gt;MyBar&lt;/code&gt; 的时候可以传入 Hook 名字，本地化名字，本地化提示参数（&lt;code&gt;&#34;MyBar&#34;, LOCTEXT(&#34;MyBar&#34;, &#34;MyBar&#34;), LOCTEXT(&#34;MyBarTips&#34;, &#34;MyBarTips&#34;)&lt;/code&gt;）。上面代码就相当于路径方式 &lt;code&gt;/&amp;lt;Hook&amp;gt;Help/&amp;lt;MenuBar&amp;gt;MyBar/&amp;lt;SubMenu&amp;gt;MySubMenu/&amp;lt;Command&amp;gt;MyAction&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;混合方式&lt;/h3&gt;
&lt;p&gt;当然还可以两种方式混合使用：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
FEditorPlusPath::RegisterPath(
    &#34;/&amp;lt;MenuBar&amp;gt;Bar/&amp;lt;SubMenu&amp;gt;SubMenu/&amp;lt;Command&amp;gt;Action&#34;,
    EP_NEW_MENU(FEditorPlusCommand)(&#34;Action&#34;)
    -&amp;gt;BindAction(FExecuteAction::CreateLambda([]
        {
            // do action
        })),
);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这种情况下，插件会自动实例化中间路径的节点，最后的路径使用用户自己实例化的节点。&lt;/p&gt;
&lt;h3&gt;更多用例&lt;/h3&gt;
&lt;p&gt;头文件:&lt;/p&gt;
&lt;p&gt;```cpp&lt;/p&gt;
&lt;h1&gt;include &lt;EditorPlusPath.h&gt;&lt;/h1&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;路径方式指定本地化语言，&lt;code&gt;EP_FNAME_HOOK_AUTO&lt;/code&gt; 表示自动使用路径名字作为 &lt;code&gt;Hook&lt;/code&gt; 名字：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
FEditorPlusPath::RegisterPathAction(
        &#34;/Bar/Action&#34;,
        FExecuteAction::CreateLambda([]
        {
            // do action
        }),
        EP_FNAME_HOOK_AUTO,
        LOCTEXT(&#34;Action&#34;, &#34;Action&#34;),
        LOCTEXT(&#34;ActionTips&#34;, &#34;ActionTips&#34;));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过路径获取节点并设置本地化文本：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
FEditorPlusPath::GetNodeByPath(&#34;/MenuTest&#34;)
    -&amp;gt;SetFriendlyName(LOCTEXT(&#34;MenuTest&#34;, &#34;MenuTest&#34;))
    -&amp;gt;SetFriendlyTips(LOCTEXT(&#34;MenuTestTips&#34;, &#34;MenuTestTips&#34;));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;路径末端添加一个 Slate UI 控件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
FEditorPlusPath::RegisterPath(
    &#34;/&amp;lt;MenuBar&amp;gt;Bar/&amp;lt;SubMenu&amp;gt;SubMenu/&amp;lt;Widget&amp;gt;Widget&#34;,
    EP_NEW_MENU(FEditorPlusWidget)(&#34;Widget&#34;, LOCTEXT(&#34;Widget&#34;, &#34;Widget&#34;))
        -&amp;gt;BindWidget(SNew(SHorizontalBox)));
);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 UE 自带的 Hook 里面添加新的节点&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
FEditorPlusPath::RegisterPath(&#34;&amp;lt;Hook&amp;gt;EpicGamesHelp/&amp;lt;Separator&amp;gt;ExtendSeparator&#34;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;多次声明相同的路径，都被识别成同一个路径，因此可以不断扩展相同的路径&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
FEditorPlusPath::RegisterPathAction(&#34;/MenuTest/SubMenu1/SubMenu1/Path1&#34;, Action, EP_FNAME_HOOK_AUTO, LOCTEXT(&#34;Path1&#34;, &#34;Path1&#34;), LOCTEXT(&#34;Path1Tips&#34;, &#34;Path1Tips&#34;));
FEditorPlusPath::RegisterPathAction(&#34;/MenuTest/SubMenu1/SubMenu1/Path2&#34;, Action, EP_FNAME_HOOK_AUTO, LOCTEXT(&#34;Path2&#34;, &#34;Path2&#34;), LOCTEXT(&#34;Path2Tips&#34;, &#34;Path2Tips&#34;));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;为一个节点继续扩展路径&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
auto node = FEditorPlusPath::GetNodeByPath(&#34;/MenuTest&#34;);
FEditorPlusPath::RegisterChildPath(node, &#34;&amp;lt;SubMenu&amp;gt;Sub/&amp;lt;Separator&amp;gt;Sep&#34;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;删除一个路径&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
FEditorPlusPath::UnregisterPath(&#34;/MenuTest/SubMenu1/SubMenu1/Path1&#34;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;扩展工具栏
&lt;code&gt;cpp
FEditorPlusPath::RegisterPath(&#34;/&amp;lt;Hook&amp;gt;ProjectSettings/&amp;lt;ToolBar&amp;gt;MenuTestToolBar&#34;)
-&amp;gt;Content({
    EP_NEW_MENU(FEditorPlusCommand)(&#34;ToolBarCommand1&#34;)
    -&amp;gt;BindAction(...)
});&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;接口说明&lt;/h3&gt;
&lt;p&gt;```cpp
class EDITORPLUS_API FEditorPlusPath
{
public:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static TSharedPtr&amp;lt;FEditorPlusMenuBase&amp;gt; RegisterPath(const FString&amp;amp; Path, const TSharedPtr&amp;lt;FEditorPlusMenuBase&amp;gt;&amp;amp; Menu=nullptr);
static TSharedPtr&amp;lt;FEditorPlusMenuBase&amp;gt; RegisterPath(const FString&amp;amp; Path, const FText&amp;amp; FriendlyName, const FText&amp;amp; FriendlyTips);
static TSharedPtr&amp;lt;FEditorPlusMenuBase&amp;gt; RegisterPathAction(
    const FString&amp;amp; Path, const FExecuteAction&amp;amp; ExecuteAction, const FName&amp;amp; Hook=EP_FNAME_HOOK_AUTO,
    const FText&amp;amp; FriendlyName=FText::GetEmpty(), const FText&amp;amp; FriendlyTips=FText::GetEmpty());

static TSharedPtr&amp;lt;FEditorPlusMenuBase&amp;gt; RegisterChildPath(
    const TSharedRef&amp;lt;FEditorPlusMenuBase&amp;gt;&amp;amp; InParent, const FString&amp;amp; Path, const TSharedPtr&amp;lt;FEditorPlusMenuBase&amp;gt;&amp;amp; Menu=nullptr);
static TSharedPtr&amp;lt;FEditorPlusMenuBase&amp;gt; RegisterChildPath(
    const TSharedRef&amp;lt;FEditorPlusMenuBase&amp;gt;&amp;amp; InParent, const FString&amp;amp; Path, const FText&amp;amp; FriendlyName, const FText&amp;amp; FriendlyTips);
static TSharedPtr&amp;lt;FEditorPlusMenuBase&amp;gt; RegisterChildPathAction(
    const TSharedRef&amp;lt;FEditorPlusMenuBase&amp;gt;&amp;amp; InParent, const FString&amp;amp; Path, const FExecuteAction&amp;amp; ExecuteAction,
    const FName&amp;amp; Hook=EP_FNAME_HOOK_AUTO, const FText&amp;amp; FriendlyName=FText::GetEmpty(), const FText&amp;amp; FriendlyTips=FText::GetEmpty());

static bool UnregisterPath(
    const FString&amp;amp; Path, const TSharedPtr&amp;lt;FEditorPlusMenuBase&amp;gt;&amp;amp; Leaf=nullptr);

static TSharedPtr&amp;lt;FEditorPlusMenuBase&amp;gt; GetNodeByPath(const FString&amp;amp; Path);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};
```&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RegisterPath&lt;/code&gt;：生成路径菜单&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RegisterPathAction&lt;/code&gt;：生成路径菜单，并自动为末端 &lt;code&gt;&amp;lt;Command&amp;gt;&lt;/code&gt; 节点绑定操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RegisterChildPath&lt;/code&gt;：为指定节点继续生成子路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RegisterChildPathAction&lt;/code&gt;：为指定节点继续生成子路径，并自动绑定操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UnregisterPath&lt;/code&gt;：删除路径，&lt;code&gt;Leaf&lt;/code&gt; 在有多个同名的末端节点可以指定严格匹配。删除的过程中，会回溯中间节点，一旦中间节点没有任何子节点也会被删除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GetNodeByPath&lt;/code&gt;：根据路径获取节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;节点类型&lt;/p&gt;
&lt;p&gt;```cpp
// base class of all node
class EDITORPLUS_API FEditorPlusMenuBase: public TSharedFromThis&lt;FEditorPlusMenuBase&gt; {}&lt;/p&gt;
&lt;p&gt;class EDITORPLUS_API FEditorPlusHook: public TEditorPlusMenuBaseRoot {}&lt;/p&gt;
&lt;p&gt;class EDITORPLUS_API FEditorPlusMenuBar: public TEditorPlusMenuBaseNode {}&lt;/p&gt;
&lt;p&gt;class EDITORPLUS_API FEditorPlusToolBar: public TEditorPlusMenuBaseNode {}&lt;/p&gt;
&lt;p&gt;class EDITORPLUS_API FEditorPlusSection: public TEditorPlusMenuBaseNode {}&lt;/p&gt;
&lt;p&gt;class EDITORPLUS_API FEditorPlusSeparator: public TEditorPlusMenuBaseNode{}&lt;/p&gt;
&lt;p&gt;class EDITORPLUS_API FEditorPlusSubMenu: public TEditorPlusMenuBaseNode {}&lt;/p&gt;
&lt;p&gt;class EDITORPLUS_API FEditorPlusCommand: public TEditorPlusMenuBaseLeaf {}&lt;/p&gt;
&lt;p&gt;class EDITORPLUS_API FEditorPlusWidget: public TEditorPlusMenuBaseLeaf {}
```&lt;/p&gt;
&lt;p&gt;更多样例和接口说明请参考源码 &lt;a href=&#34;https://github.com/disenone/UE.EditorPlus&#34;&gt;UE.EditorPlus&lt;/a&gt;，测试用例 &lt;a href=&#34;https://github.com/disenone/UE.EditorPlus/blob/ue5.3/Source/EditorPlusTools/Private/MenuTest/MenuTest.cpp&#34;&gt;MenuTest.cpp&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;模块化管理&lt;/h3&gt;
&lt;p&gt;UE.EditorPlus 还提供了一个模块化管理扩展菜单的框架，支持插件加载和卸载的时候，自动加载和卸载扩展的菜单&lt;/p&gt;
&lt;p&gt;让菜单类继承 &lt;code&gt;IEditorPlusToolInterface&lt;/code&gt;，并覆写 &lt;code&gt;OnStartup&lt;/code&gt; 和 &lt;code&gt;OnShutdown&lt;/code&gt; 函数。&lt;code&gt;OnStartup&lt;/code&gt; 负责创建菜单，&lt;code&gt;OnShutdown&lt;/code&gt; 负责调用节点的 &lt;code&gt;Destroy&lt;/code&gt; 函数清理菜单。单节点的引用数归0，则会执行自动清理。&lt;/p&gt;
&lt;p&gt;```cpp
class FMenuTest: public IEditorPlusToolInterface
{
public:
    virtual void OnStartup() override;
    virtual void OnShutdown() override;
}&lt;/p&gt;
&lt;p&gt;void FMenuTest::OnStartup()
{
    BuildPathMenu();
    BuildCustomMenu();
    BuildMixMenu();
    BuildExtendMenu();
}&lt;/p&gt;
&lt;p&gt;void FMenuTest::OnShutdown()
{
    for(auto Menu: Menus)
    {
        if(Menu.IsValid()) Menu-&amp;gt;Destroy();
    }
    Menus.Empty();
}
```&lt;/p&gt;
&lt;p&gt;菜单管理类继承 &lt;code&gt;IEditorPlusToolManagerInterface&lt;/code&gt;，并覆写 &lt;code&gt;AddTools&lt;/code&gt; 函数，在 &lt;code&gt;AddTools&lt;/code&gt; 里面添加菜单类&lt;/p&gt;
&lt;p&gt;```cpp
class FEditorPlusToolsImpl: public IEditorPlusToolManagerInterface
{
public:
    virtual void AddTools() override;
}&lt;/p&gt;
&lt;p&gt;void FEditorPlusToolsImpl::AddTools()
{
    if (!Tools.Num())
    {
        Tools.Emplace(MakeShared&lt;FMenuTest&gt;());
    }&lt;/p&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;插件加载和卸载的时候分别调用管理类的 &lt;code&gt;StartupTools&lt;/code&gt; 和 &lt;code&gt;ShutdownTools&lt;/code&gt; 函数&lt;/p&gt;
&lt;p&gt;```cpp
void FEditorPlusToolsModule::StartupModule()
{
    Impl = FEditorPlusToolsImpl::Get();
    Impl-&amp;gt;StartupTools();&lt;/p&gt;
&lt;p&gt;}
void FEditorPlusToolsModule::ShutdownModule()
{
    Impl-&amp;gt;ShutdownTools();
}
```&lt;/p&gt;
&lt;p&gt;完成以上适配，则可以自动在加载和卸载插件的时候，自动加载和卸载扩展的菜单。&lt;/p&gt;
&lt;h2&gt;编辑器工具&lt;/h2&gt;
&lt;p&gt;UE.EditorPlus 还提供了一些实用的编辑器工具&lt;/p&gt;
&lt;h2&gt;创建编辑器窗口&lt;/h2&gt;
&lt;p&gt;使用 EditorPlus，可以很简单的创建一个新的编辑器窗口&lt;/p&gt;
&lt;p&gt;```cpp
// register spawn tab
Tab = MakeShared&lt;FEditorPlusTab&gt;(LOCTEXT(&#34;ClassBrowser&#34;, &#34;ClassBrowser&#34;), LOCTEXT(&#34;ClassBrowserTip&#34;, &#34;Open the ClassBrowser&#34;));
Tab-&amp;gt;Register&lt;SClassBrowserTab&gt;();&lt;/p&gt;
&lt;p&gt;// register menu action to spawn tab
FEditorPlusPath::RegisterPathAction(
    &#34;/EditorPlusTools/ClassBrowser&#34;,
    FExecuteAction::CreateSP(Tab.ToSharedRef(), &amp;amp;FEditorPlusTab::TryInvokeTab),
);
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SClassBrowserTab&lt;/code&gt; 是一个自定义的 UI 控件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
class SClassBrowserTab final : public SCompoundWidget
{
    SLATE_BEGIN_ARGS(SClassBrowserTab)
    {}
    SLATE_END_ARGS()
    // ...
}&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;ClassBrowser&lt;/h3&gt;
&lt;p&gt;ClassBrowser 是一个 UE Class 查看器，通过菜单 EditorPlusTools -&amp;gt; ClassBrowser 来打开&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2024-ue-editorplus/classbrowser_menu.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2024-ue-editorplus/classbrowser.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;基于 UE 的反射来实现，可以很方便查看 UE 各种类型的成员信息，说明提示等，支持模糊搜索，并能跳转打开父类的信息。&lt;/p&gt;
&lt;h3&gt;MenuCollections&lt;/h3&gt;
&lt;p&gt;MenuCollections 是一个菜单命令快速查找和收藏工具，能够帮助你快速找到需要执行的菜单命令，并可以收藏常用命令，提升效率。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2024-ue-editorplus/menucollection_find.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2024-ue-editorplus/menucollection_star.png&#34;&gt;&lt;/p&gt;
&lt;h3&gt;SlateResourceBrowser&lt;/h3&gt;
&lt;p&gt;SlateResourceBrowser 是一个可以快速查看 Slate UI 资源的工具，能够帮助你浏览和查找需要的编辑器资源，方便扩展编辑器。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2024-ue-editorplus/slateresourcebrowser_color.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2024-ue-editorplus/slateresourcebrowser_icon.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2024-ue-editorplus/slateresourcebrowser_font.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2024-ue-editorplus/slateresourcebrowser_widgetstyle.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/ue-%E7%BC%96%E8%BE%91%E5%99%A8%E6%8F%92%E4%BB%B6-EditorPlus/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Mon, 15 Apr 2024 02:57:59 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/ue-%E7%BC%96%E8%BE%91%E5%99%A8%E6%8F%92%E4%BB%B6-EditorPlus/</guid>
      
    </item>
    
    <item>
      <title>C/C++ 宏编程解析</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;C/C++ 宏编程解析&#34; /&gt;&lt;/p&gt;
&lt;p&gt;本文的目的是要讲清楚 C/C++ 的宏编程的规则和实现方法，让你不再惧怕看到代码里面的宏。我会首先说说 C++ 标准 14 里面提到的关于宏展开的规则，然后通过修改 Clang 的源码来观察宏展开，最后基于这些知识来聊聊宏编程的实现。&lt;/p&gt;
&lt;p&gt;本文的代码全部都在这里：&lt;a href=&#34;assets/img/2021-3-31-cpp-preprocess/macros.cpp&#34;&gt;下载&lt;/a&gt;，&lt;a href=&#34;https://godbolt.org/z/coWvc5Pse&#34;&gt;在线演示&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;引子&lt;/h2&gt;
&lt;p&gt;我们可以通过执行命令 &lt;code&gt;gcc -P -E a.cpp -o a.cpp.i&lt;/code&gt; 来让编译器对文件 &lt;code&gt;a.cpp&lt;/code&gt; 只执行预处理并保存结果到 &lt;code&gt;a.cpp.i&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;首先我们先来看一些例子:&lt;/p&gt;
&lt;h4&gt;递归重入（Reentrancy）&lt;/h4&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define ITER(arg0, arg1) ITER(arg1, arg0)&lt;/h1&gt;
&lt;p&gt;ITER(1, 2)          // -&amp;gt; ITER(2, 1)
```&lt;/p&gt;
&lt;p&gt;宏 &lt;code&gt;ITER&lt;/code&gt; 交换了 &lt;code&gt;arg0&lt;/code&gt;, &lt;code&gt;arg1&lt;/code&gt; 的位置。宏展开之后，得到的是 &lt;code&gt;ITER(2, 1)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以看到，&lt;code&gt;arg0&lt;/code&gt; &lt;code&gt;arg1&lt;/code&gt; 的位置成功交换，在这里宏成功展开了一次，但也只展开了一次，不再递归重入。换言之，宏的展开过程中，是不可自身递归重入的，如果在递归的过程中发现相同的宏在之前的递归中已经展开过，则不再展开，这是宏展开的其中一条重要的规则。禁止递归重入的原因也很简单，就是为了避免无限递归。&lt;/p&gt;
&lt;h4&gt;字符串拼接&lt;/h4&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define CONCAT(arg0, arg1) arg0 ## arg1&lt;/h1&gt;
&lt;p&gt;CONCAT(Hello, World)                // -&amp;gt; HelloWorld
CONCAT(Hello, CONCAT(World, !))     // -&amp;gt;　HelloCONCAT(World, !)
```&lt;/p&gt;
&lt;p&gt;宏 &lt;code&gt;CONCAT&lt;/code&gt; 目的是拼接 &lt;code&gt;arg0&lt;/code&gt; &lt;code&gt;arg1&lt;/code&gt;。宏展开之后，&lt;code&gt;CONCAT(Hello, World)&lt;/code&gt; 能够得到正确的结果 &lt;code&gt;HelloWorld&lt;/code&gt;。但是 &lt;code&gt;CONCAT(Hello, CONCAT(World, !))&lt;/code&gt; 却只展开了外层的宏，内层的 &lt;code&gt;CONCAT(World, !)&lt;/code&gt; 并没有展开而是直接跟 &lt;code&gt;Hello&lt;/code&gt; 拼接在一起了，这跟我们预想的不一样，我们真正想要的结果是 &lt;code&gt;HelloWorld!&lt;/code&gt;。这就是宏展开的另外一条重要的规则：跟在 &lt;code&gt;##&lt;/code&gt; 操作符后面的宏参数，不会执行展开，而是会直接跟前面的内容先拼接在一起。&lt;/p&gt;
&lt;p&gt;通过上面两个例子可以看出来，宏展开的规则有一些是反直觉的，如果不清楚具体的规则，有可能写出来的宏跟我们想要的效果不一致。&lt;/p&gt;
&lt;h2&gt;宏展开规则&lt;/h2&gt;
&lt;p&gt;通过引子的两个例子，我们了解到了宏展开是有一套标准的规则的，这套规则定义在 C/C++ 标准里面，内容不多，建议先仔细读几遍，我这里顺带给下标准 n4296 版本的链接，宏展开在 16.3 节：&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf&#34;&gt;传送门&lt;/a&gt;。下面我挑出 n4296 版本中几条重要的规则，这些规则会决定如何正确编写宏（还是建议抽时间把标准里面的宏展开细读下）。&lt;/p&gt;
&lt;h4&gt;参数分隔&lt;/h4&gt;
&lt;p&gt;宏的参数要求是用逗号分隔，而且参数的个数需要跟宏定义的个数一致，传递给宏的参数中，额外用括号包住的内容视为一个参数，参数允许为空：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define ADD_COMMA(arg1, arg2) arg1, arg2&lt;/h1&gt;
&lt;p&gt;ADD_COMMA(a, b)             // -&amp;gt; a, b
ADD_COMMA(a)                // 报错 &#34;macro &#34;MACRO&#34; requires 2 arguments, but only 1 given&#34;
ADD_COMMA((a, b), c)        // -&amp;gt; (a, b), c
ADD_COMMA(, b)              // -&amp;gt; , b
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ADD_COMMA((a, b), c)&lt;/code&gt; 中 &lt;code&gt;(a, b)&lt;/code&gt; 视为第一个参数。&lt;code&gt;ADD_COMMA(, b)&lt;/code&gt; 中，第一个参数为空，于是展开为 &lt;code&gt;, b&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;宏参数展开&lt;/h4&gt;
&lt;p&gt;在对宏进行展开的时候，如果宏的参数也是可以展开的宏，会先把参数完全展开，再展开宏，例如&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
ADD_COMMA(ADD_COMMA(1, 2), ADD_COMMA(3, 4))     // -&amp;gt; 1, 2, 3, 4&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一般情况下的宏展开，都可以认为是先对参数求值，再对宏求值，除非遇到了 &lt;code&gt;#&lt;/code&gt; 和 &lt;code&gt;##&lt;/code&gt; 操作符。&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;#&lt;/code&gt; 操作符&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;#&lt;/code&gt; 操作符后面跟的宏参数，不会进行展开，会直接字符串化，例如：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define STRINGIZE(arg0) # arg0&lt;/h1&gt;
&lt;p&gt;STRINGIZE(a)                // -&amp;gt; &#34;a&#34;
STRINGIZE(STRINGIZE(a))     // -&amp;gt; &#34;STRINGIZE(a)&#34;
```&lt;/p&gt;
&lt;p&gt;根据这条规则 &lt;code&gt;STRINGIZE(STRINGIZE(a))&lt;/code&gt; 只能展开为 &lt;code&gt;&#34;STRINGIZE(a)&#34;&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;##&lt;/code&gt; 操作符&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;##&lt;/code&gt; 操作符前后的宏参数，都不会进行展开，会先直接拼接起来，例如：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define CONCAT(arg0, arg1) arg0 ## arg1&lt;/h1&gt;
&lt;p&gt;CONCAT(Hello, World)                        // -&amp;gt; HelloWorld
CONCAT(Hello, CONCAT(World, !))             // -&amp;gt; HelloCONCAT(World, !)
CONCAT(CONCAT(Hello, World) C, ONCAT(!))    // -&amp;gt; CONCAT(Hello, World) CONCAT(!)
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CONCAT(CONCAT(Hello, World) C, ONCAT(!))&lt;/code&gt; 只能是先拼接在一起，得到 &lt;code&gt;CONCAT(Hello, World) CONCAT(!)&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;重复扫描&lt;/h4&gt;
&lt;p&gt;预处理器执行完一次宏展开之后，会重新扫描得到的内容，继续展开，直到没有可以展开的内容为止。&lt;/p&gt;
&lt;p&gt;一次宏展开，可以理解为先把参数完全展开（除非遇到 &lt;code&gt;#&lt;/code&gt; 和 &lt;code&gt;##&lt;/code&gt;），再根据宏的定义，把宏和完全展开后的参数按照定义进行替换，再处理定义中的所有 &lt;code&gt;#&lt;/code&gt; 和 &lt;code&gt;##&lt;/code&gt; 操作符。&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define CONCAT(arg0, arg1) arg0 ## arg1&lt;/h1&gt;
&lt;h1&gt;define STRINGIZE(arg0) # arg0&lt;/h1&gt;
&lt;p&gt;CONCAT(STRING, IZE(Hello))        // -&amp;gt; STRINGIZE(Hello) -&amp;gt; &#34;Hello&#34;
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CONCAT(STRING, IZE(Hello))&lt;/code&gt; 第一次扫描展开得到 &lt;code&gt;STRINGIZE(Hello)&lt;/code&gt;，然后执行第二次扫描，发现 &lt;code&gt;STRINGIZE&lt;/code&gt; 可以继续展开，最后得到 &lt;code&gt;&#34;Hello&#34;&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;禁止递归重入&lt;/h4&gt;
&lt;p&gt;在重复扫描的过程中，禁止递归展开相同的宏。可以把宏展开理解为树形的结构，根节点就是一开始要展开的宏，每个宏展开之后的内容作为该宏的子节点连接到树上，那么禁止递归就是在展开子节点的宏时，如果该宏跟任意祖先节点的宏相同，则禁止展开。来看一些例子：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define CONCAT(arg0, arg1) arg0 ## arg1&lt;/h1&gt;
&lt;h1&gt;define CONCAT_SPACE(arg0, arg1) arg0 arg1&lt;/h1&gt;
&lt;h1&gt;define IDENTITY(arg0) IDENTITY_IMPL(arg0)&lt;/h1&gt;
&lt;h1&gt;define IDENTITY_IMPL(arg0) arg0&lt;/h1&gt;
&lt;p&gt;CONCAT(CON, CAT(a, b))                  // -&amp;gt; CONCAT(a, b)
IDENTITY_IMPL(CONCAT(CON, CAT(a, b)))   // -&amp;gt; CONCAT(a, b)
IDENTITY(CONCAT(CON, CAT(a, b)))        // -&amp;gt; IDENTITY_IMPL(CONCAT(a, b)) -&amp;gt; CONCAT(a, b)
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CONCAT(CON, CAT(a, b))&lt;/code&gt;：由于 &lt;code&gt;CONCAT&lt;/code&gt; 是用 &lt;code&gt;##&lt;/code&gt; 拼接两个参数，根据 &lt;code&gt;##&lt;/code&gt; 的规则，不会展开参数，直接拼接。所以第一次展开得到了 &lt;code&gt;CONCAT(a, b)&lt;/code&gt;，由于 &lt;code&gt;CONCAT&lt;/code&gt; 已经展开过了不会再递归展开，所以停止。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IDENTITY_IMPL(CONCAT(CON, CAT(a, b)))&lt;/code&gt;：&lt;code&gt;IDENTITY_IMPL&lt;/code&gt; 可以理解为对参数 &lt;code&gt;arg0&lt;/code&gt; 求值，这里的参数 &lt;code&gt;arg0&lt;/code&gt; 求值得到了 &lt;code&gt;CONCAT(a, b)&lt;/code&gt;，并由于递归被标记为了禁止重入，之后 &lt;code&gt;IDENTITY_IMPL&lt;/code&gt; 展开完成，进行第二次扫描的时候，发现是禁止重入的 &lt;code&gt;CONCAT(a, b)&lt;/code&gt;，于是停止展开。在这里 &lt;code&gt;CONCAT(a, b)&lt;/code&gt; 是由参数 &lt;code&gt;arg0&lt;/code&gt; 展开而得到的，但在后续展开的时候，也会保持禁止重入的标记，可以理解为父节点是参数 &lt;code&gt;arg0&lt;/code&gt;，一直保持着禁止重入的标记。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IDENTITY(CONCAT(CON, CAT(a, b)))&lt;/code&gt;：这个例子主要是为了加强对父子节点的理解，参数自己展开的时候，是自身作为父节点，展开的内容作为子节点去判断递归，展开后的参数传到宏定义之后，禁止重入的标记会继续保留（如果传到宏定义之后没有改变参数展开后的宏）。可以把参数的展开过程看成是另外一棵树，参数的展开结果就是树的最底层子节点，这个子节点传给宏来执行展开的同时，依然是保留着禁止重入的特性。&lt;/p&gt;
&lt;p&gt;例如这里，在第一次完全展开之后得到 &lt;code&gt;IDENTITY_IMPL(CONCAT(a, b))&lt;/code&gt;，&lt;code&gt;CONCAT(a, b)&lt;/code&gt; 被标记为禁止重入， 即使 &lt;code&gt;IDENTITY_IMPL&lt;/code&gt; 是对参数求值的，但参数已经禁止展开，所以参数就原封不动的传到定义里，最后我们还是得到 &lt;code&gt;CONCAT(a, b)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以上我只是列出了一些我认为比较重要的，或者觉得不太好理解的规则，详细的宏展开规则，还是建议花点时间直接去看标准文档。&lt;/p&gt;
&lt;h2&gt;通过 Clang 观察展开过程&lt;/h2&gt;
&lt;p&gt;我们可以给 Clang 源码加上一些打印信息来观察宏展开的过程，我无意深入解释 Clang 的源码，在这里给一份修改过的文件 diff，有兴趣的可以自己编译 Clang 来研究。这里我是用的 llvm 版本 11.1.0 （&lt;a href=&#34;https://github.com/llvm/llvm-project/archive/refs/tags/llvmorg-11.1.0.tar.gz&#34;&gt;传送门&lt;/a&gt;），修改过的文件（&lt;a href=&#34;assets/img/2021-3-31-cpp-preprocess/clang-modify.zip&#34;&gt;传送门&lt;/a&gt;）。下面简单通过例子来验证我们之前介绍的宏展开规则：&lt;/p&gt;
&lt;h4&gt;例子1&lt;/h4&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define CONCAT(arg0, arg1) arg0 ## arg1&lt;/h1&gt;
&lt;p&gt;CONCAT(C, ONCAT(a, b))      // CONCAT(a, b)
```&lt;/p&gt;
&lt;p&gt;使用修改过的 Clang 来预处理以上代码： &lt;code&gt;clang -P -E a.cpp -o a.cpp.i&lt;/code&gt;，得到下面的打印信息：&lt;/p&gt;
&lt;p&gt;``` text linenums=&#34;1&#34;
HandleIdentifier:
MacroInfo 0x559e57496900
    #define &lt;macro&gt;&lt;a href=&#34;arg0, arg1&#34;&gt;2813:CONCAT&lt;/a&gt; arg0 ## arg1
Macro is ok to expand&lt;/p&gt;
&lt;p&gt;EnterMacro: 0&lt;/p&gt;
&lt;p&gt;Enter ExpandFunctionArguments:
MacroInfo 0x559e57496900 used
    #define &lt;macro&gt;&lt;a href=&#34;arg0, arg1&#34;&gt;2813:CONCAT&lt;/a&gt; arg0 ## arg1
Token: 0
identifier: arg0
Args: [identifier: C]
Token: 1
hashhash:
Token: 2
identifier: arg1
Args: [identifier: ONCAT][l_paren: ][identifier: a][comma: ][identifier: b][r_paren: ]
Leave ExpandFunctionArguments: [identifier: C][hashhash: ][identifier: ONCAT][l_paren: ][identifier: a][comma: ][identifier: b][r_paren: ]&lt;/p&gt;
&lt;p&gt;LeaveMacro: 0&lt;/p&gt;
&lt;p&gt;HandleIdentifier:
MacroInfo 0x559e57496900 disabled used
    #define &lt;macro&gt;&lt;a href=&#34;arg0, arg1&#34;&gt;2813:CONCAT&lt;/a&gt; arg0 ## arg1
Macro is not ok to expand
```&lt;/p&gt;
&lt;p&gt;第 &lt;a href=&#34;#__codelineno-9-1&#34;&gt;1&lt;/a&gt; 行 &lt;code&gt;HandleIdentifier&lt;/code&gt; 遇到宏的时候会打印，接着打印宏的信息（第 &lt;a href=&#34;#__codelineno-9-2&#34;&gt;2-4&lt;/a&gt; 行），宏没有禁用，所以可以按照定义来展开 &lt;code&gt;Macro is ok to expand&lt;/code&gt;，之后进入宏 &lt;code&gt;EnterMacro&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;真正执行宏展开的函数是 &lt;code&gt;ExpandFunctionArguments&lt;/code&gt;，之后再次打印待展开的宏信息，注意到此时宏已经被标记为 &lt;code&gt;used&lt;/code&gt; （第 &lt;a href=&#34;#__codelineno-9-9&#34;&gt;9&lt;/a&gt; 行）。之后根据宏的定义，进行逐个 &lt;code&gt;Token&lt;/code&gt; 的展开 （&lt;code&gt;Token&lt;/code&gt; 是 &lt;code&gt;Clang&lt;/code&gt; 预处理里面的概念，这里不深入说明）。&lt;/p&gt;
&lt;p&gt;第 0 个 &lt;code&gt;Token&lt;/code&gt; 是形参 &lt;code&gt;arg0&lt;/code&gt;, 对应的实参是 &lt;code&gt;C&lt;/code&gt;，判断不需要展开，于是直接复制到结果上（第 &lt;a href=&#34;#__codelineno-9-11&#34;&gt;11-13&lt;/a&gt; 行）。&lt;/p&gt;
&lt;p&gt;第 1 个 &lt;code&gt;Token&lt;/code&gt; 是 &lt;code&gt;hashhash&lt;/code&gt;，也就是 &lt;code&gt;##&lt;/code&gt; 操作符，继续复制到结果上（第 &lt;a href=&#34;#__codelineno-9-14&#34;&gt;14-15&lt;/a&gt; 行）。&lt;/p&gt;
&lt;p&gt;第 2 个 &lt;code&gt;Token&lt;/code&gt; 是形参 &lt;code&gt;arg1&lt;/code&gt;，对应的实参是 &lt;code&gt;ONCAT(a, b)&lt;/code&gt;，预处理器也会把实参处理成一个个的 &lt;code&gt;Token&lt;/code&gt;，所以可以看到打印的结果用中括号包住了实参的每个 &lt;code&gt;Token&lt;/code&gt;（第 18 行），由于 &lt;code&gt;##&lt;/code&gt; 的原因这个实参依然不需要展开，所以还是直接复制到结果上（第 &lt;a href=&#34;#__codelineno-9-16&#34;&gt;16-18&lt;/a&gt; 行）。&lt;/p&gt;
&lt;p&gt;最后 &lt;code&gt;Leave ExpandFunctionArguments&lt;/code&gt; 打印本次扫描展开得到的结果（第 &lt;a href=&#34;#__codelineno-9-19&#34;&gt;19&lt;/a&gt; 行），把结果的 &lt;code&gt;Token&lt;/code&gt; 都翻译过来就是 &lt;code&gt;C ## ONCAT(a, b)&lt;/code&gt;，之后预处理器就执行 &lt;code&gt;##&lt;/code&gt; 操作符来生成新的内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;##&lt;/code&gt; 执行之后得到 &lt;code&gt;CONCAT(a, b)&lt;/code&gt;，遇到宏 &lt;code&gt;CONCAT&lt;/code&gt;，预处理还是先进入 &lt;code&gt;HandleIdentifier&lt;/code&gt;，打印宏的信息，发现该宏状态是 &lt;code&gt;disable used&lt;/code&gt;，是已经展开过的，禁止再重入了，显示 &lt;code&gt;Macro is not ok to expand&lt;/code&gt;，预处理器不再展开，最终得到的结果就是 &lt;code&gt;CONCAT(a, b)&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;例子2&lt;/h4&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define CONCAT(arg0, arg1) arg0 ## arg1&lt;/h1&gt;
&lt;h1&gt;define IDENTITY(arg0) arg0&lt;/h1&gt;
&lt;p&gt;IDENTITY(CONCAT(C, ONCAT(a, b)))
```&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; &lt;font&gt; Clang 打印信息（点击展开）：&lt;/font&gt; &lt;/summary&gt;
``` test linenums=&#34;1&#34;
HandleIdentifier:
MacroInfo 0x562a148f5a60
    #define &lt;macro&gt;[2853:IDENTITY](arg0) arg0
Macro is ok to expand

HandleIdentifier:
MacroInfo 0x562a148f5930
    #define &lt;macro&gt;[2813:CONCAT](arg0, arg1) arg0 ## arg1

EnterMacro: 0

Enter ExpandFunctionArguments:
MacroInfo 0x562a148f5a60 used
    #define &lt;macro&gt;[2853:IDENTITY](arg0) arg0
Token: 0
identifier: arg0
Args: [identifier: CONCAT][l_paren: ][identifier: C][comma: ][identifier: ONCAT][l_paren: ][identifier: a][comma: ][identifier: b][r_paren: ][r_paren: ]
getPreExpArgument: [identifier: CONCAT][l_paren: ][identifier: C][comma: ][identifier: ONCAT][l_paren: ][identifier: a][comma: ][identifier: b][r_paren: ][r_paren: ][eof: ]

HandleIdentifier:
MacroInfo 0x562a148f5930
    #define &lt;macro&gt;[2813:CONCAT](arg0, arg1) arg0 ## arg1
Macro is ok to expand

EnterMacro: 1

Enter ExpandFunctionArguments:
MacroInfo 0x562a148f5930 used
    #define &lt;macro&gt;[2813:CONCAT](arg0, arg1) arg0 ## arg1
Token: 0
identifier: arg0
Args: [identifier: C]
Token: 1
hashhash:
Token: 2
identifier: arg1
Args: [identifier: ONCAT][l_paren: ][identifier: a][comma: ][identifier: b][r_paren: ]
Leave ExpandFunctionArguments: [identifier: C][hashhash: ][identifier: ONCAT][l_paren: ][identifier: a][comma: ][identifier: b][r_paren: ]

LeaveMacro: 1

HandleIdentifier:
MacroInfo 0x562a148f5930 disabled used
    #define &lt;macro&gt;[2813:CONCAT](arg0, arg1) arg0 ## arg1
Macro is not ok to expand
ResultArgToks: [identifier: CONCAT][l_paren: ][identifier: a][comma: ][identifier: b][r_paren: ]
Leave ExpandFunctionArguments: [identifier: CONCAT][l_paren: ][identifier: a][comma: ][identifier: b][r_paren: ]

LeaveMacro: 0

HandleIdentifier:
MacroInfo 0x562a148f5930 used
    #define &lt;macro&gt;[2813:CONCAT](arg0, arg1) arg0 ## arg1
Macro is not ok to expand
```

&lt;/details&gt;

&lt;p&gt;第 &lt;a href=&#34;#__codelineno-11-12&#34;&gt;12&lt;/a&gt; 行开始展开 &lt;code&gt;IDENTITY&lt;/code&gt;，发现参数 &lt;code&gt;Token 0&lt;/code&gt; 是 &lt;code&gt;CONCAT(...)&lt;/code&gt;，也是一个宏，于是先对该参数进行求值。&lt;/p&gt;
&lt;p&gt;第 &lt;a href=&#34;#__codelineno-11-27&#34;&gt;27&lt;/a&gt; 行开始展开参数宏 &lt;code&gt;CONCAT(...)&lt;/code&gt;，跟例子 1 一样，多次扫描展开完成后得到 &lt;code&gt;CONCAT(a, b)&lt;/code&gt; （第 &lt;a href=&#34;#__codelineno-11-46&#34;&gt;46&lt;/a&gt; 行）。&lt;/p&gt;
&lt;p&gt;第 &lt;a href=&#34;#__codelineno-11-47&#34;&gt;47&lt;/a&gt; 结束对 &lt;code&gt;IDENTITY&lt;/code&gt; 的展开，得到的结果是 &lt;code&gt;CONCAT(a, b)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第 &lt;a href=&#34;#__codelineno-11-51&#34;&gt;51&lt;/a&gt; 行重新扫描 &lt;code&gt;CONCAT(a, b)&lt;/code&gt;，发现虽然是宏，但在之前的参数展开过程中已经被设置成了 &lt;code&gt;used&lt;/code&gt;，不再递归展开，直接作为最终结果。&lt;/p&gt;
&lt;h4&gt;例子 3&lt;/h4&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define CONCAT(arg0, arg1) arg0 ## arg1&lt;/h1&gt;
&lt;h1&gt;define IDENTITY_IMPL(arg0) arg0&lt;/h1&gt;
&lt;h1&gt;define IDENTITY(arg0) IDENTITY_IMPL(arg0)&lt;/h1&gt;
&lt;p&gt;IDENTITY(CONCAT(C, ONCAT(a, b)))
```&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; &lt;font&gt;Clang 打印信息（点击展开）：&lt;/font&gt; &lt;/summary&gt;
``` test linenums=&#34;1&#34;
HandleIdentifier:
MacroInfo 0x55e824457a80
    #define &lt;macro&gt;[2853:IDENTITY_IMPL](arg0) arg0

HandleIdentifier:
MacroInfo 0x55e824457ba0
    #define &lt;macro&gt;[2886:IDENTITY](arg0) IDENTITY_IMPL(arg0)
Macro is ok to expand

HandleIdentifier:
MacroInfo 0x55e824457950
    #define &lt;macro&gt;[2813:CONCAT](arg0, arg1) arg0 ## arg1

EnterMacro: 0

Enter ExpandFunctionArguments:
MacroInfo 0x55e824457ba0 used
    #define &lt;macro&gt;[2886:IDENTITY](arg0) IDENTITY_IMPL(arg0)
Token: 0
identifier: IDENTITY_IMPL
Token: 1
l_paren:
Token: 2
identifier: arg0
Args: [identifier: CONCAT][l_paren: ][identifier: C][comma: ][identifier: ONCAT][l_paren: ][identifier: a][comma: ][identifier: b][r_paren: ][r_paren: ]
getPreExpArgument: [identifier: CONCAT][l_paren: ][identifier: C][comma: ][identifier: ONCAT][l_paren: ][identifier: a][comma: ][identifier: b][r_paren: ][r_paren: ][eof: ]

HandleIdentifier:
MacroInfo 0x55e824457950
    #define &lt;macro&gt;[2813:CONCAT](arg0, arg1) arg0 ## arg1
Macro is ok to expand

EnterMacro: 1

Enter ExpandFunctionArguments:
MacroInfo 0x55e824457950 used
    #define &lt;macro&gt;[2813:CONCAT](arg0, arg1) arg0 ## arg1
Token: 0
identifier: arg0
Args: [identifier: C]
Token: 1
hashhash:
Token: 2
identifier: arg1
Args: [identifier: ONCAT][l_paren: ][identifier: a][comma: ][identifier: b][r_paren: ]
Leave ExpandFunctionArguments: [identifier: C][hashhash: ][identifier: ONCAT][l_paren: ][identifier: a][comma: ][identifier: b][r_paren: ]

LeaveMacro: 1

HandleIdentifier:
MacroInfo 0x55e824457950 disabled used
    #define &lt;macro&gt;[2813:CONCAT](arg0, arg1) arg0 ## arg1
Macro is not ok to expand
ResultArgToks: [identifier: CONCAT][l_paren: ][identifier: a][comma: ][identifier: b][r_paren: ]
Token: 3
r_paren:
Leave ExpandFunctionArguments: [identifier: IDENTITY_IMPL][l_paren: ][identifier: CONCAT][l_paren: ][identifier: a][comma: ][identifier: b][r_paren: ][r_paren: ]

LeaveMacro: 0

HandleIdentifier:
MacroInfo 0x55e824457a80
    #define &lt;macro&gt;[2853:IDENTITY_IMPL](arg0) arg0
Macro is ok to expand

HandleIdentifier:
MacroInfo 0x55e824457950 used
    #define &lt;macro&gt;[2813:CONCAT](arg0, arg1) arg0 ## arg1

EnterMacro: 2

Enter ExpandFunctionArguments:
MacroInfo 0x55e824457a80 used
    #define &lt;macro&gt;[2853:IDENTITY_IMPL](arg0) arg0
Token: 0
identifier: arg0
Args: [identifier: CONCAT][l_paren: ][identifier: a][comma: ][identifier: b][r_paren: ]
getPreExpArgument: [identifier: CONCAT][l_paren: ][identifier: a][comma: ][identifier: b][r_paren: ][eof: ]

HandleIdentifier:
MacroInfo 0x55e824457950 used
    #define &lt;macro&gt;[2813:CONCAT](arg0, arg1) arg0 ## arg1
Macro is not ok to expand
ResultArgToks: [identifier: CONCAT][l_paren: ][identifier: a][comma: ][identifier: b][r_paren: ]
Leave ExpandFunctionArguments: [identifier: CONCAT][l_paren: ][identifier: a][comma: ][identifier: b][r_paren: ]

LeaveMacro: 2

HandleIdentifier:
MacroInfo 0x55e824457950 used
    #define &lt;macro&gt;[2813:CONCAT](arg0, arg1) arg0 ## arg1
Macro is not ok to expand
```

&lt;/details&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第 &lt;a href=&#34;#__codelineno-13-16&#34;&gt;16&lt;/a&gt; 行开始展开 &lt;code&gt;IDENTITY&lt;/code&gt;，同理预处理器看到 &lt;code&gt;Token 2&lt;/code&gt; （也即是 &lt;code&gt;arg0&lt;/code&gt;）是宏，于是先展开 &lt;code&gt;CONCAT(C, ONCAT(a, b))&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;展开 &lt;code&gt;arg0&lt;/code&gt; 后得到 &lt;code&gt;CONCAT(a, b)&lt;/code&gt; （第 &lt;a href=&#34;#__codelineno-13-23&#34;&gt;23-54&lt;/a&gt; 行）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IDENTITY&lt;/code&gt; 最终展开为 &lt;code&gt;IDENTITY_IMPL(CONCAT(a, b))&lt;/code&gt;（第 &lt;a href=&#34;#__codelineno-13-57&#34;&gt;57&lt;/a&gt; 行）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重新扫描，继续展开 &lt;code&gt;IDENTITY_IMPL&lt;/code&gt;（第 &lt;a href=&#34;#__codelineno-13-61&#34;&gt;61-72&lt;/a&gt; 行），发现此时的 &lt;code&gt;Token 0&lt;/code&gt; 是宏 &lt;code&gt;CONCAT(a, b)&lt;/code&gt;，但处于 &lt;code&gt;used&lt;/code&gt; 状态，中止展开并返回（第 75-84行），最终得到的结果还是 &lt;code&gt;CONCAT(a, b)&lt;/code&gt;（第 &lt;a href=&#34;#__codelineno-13-85&#34;&gt;85&lt;/a&gt; 行）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重新扫描结果，发现宏 &lt;code&gt;CONCAT(a, b)&lt;/code&gt; 的状态是 &lt;code&gt;used&lt;/code&gt;，停止展开并得到最终的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过以上三个简单的例子，我们可以大致的理解预处理器展开宏的过程，这里不再对预处理器进行更深入的探讨，有兴趣可以对照我提供的修改文件来研究。&lt;/p&gt;
&lt;h2&gt;宏编程实现&lt;/h2&gt;
&lt;p&gt;下面我们开始进入到了主题（前面那一大段目的是为了更好的理解宏展开规则），宏编程实现。&lt;/p&gt;
&lt;h4&gt;基本符号&lt;/h4&gt;
&lt;p&gt;首先可以先定义宏的特殊符号，做求值和拼接的时候会用到&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define PP_LPAREN() (&lt;/h1&gt;
&lt;h1&gt;define PP_RPAREN() )&lt;/h1&gt;
&lt;h1&gt;define PP_COMMA() ,&lt;/h1&gt;
&lt;h1&gt;define PP_EMPTY()&lt;/h1&gt;
&lt;h1&gt;define PP_HASHHASH # ## #      // 表示 ## 字符串，但只是作为字符串，不会当作 ## 操作符来处理&lt;/h1&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;h4&gt;求值&lt;/h4&gt;
&lt;p&gt;利用参数优先展开的规则，可以写出一个求值宏：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define PP_IDENTITY(arg0) arg0&lt;/h1&gt;
&lt;p&gt;PP_COMMA PP_LPAREN() PP_RPAREN()                // -&amp;gt; PP_COMMA ( )
PP_IDENTITY(PP_COMMA PP_LPAREN() PP_RPAREN())   // -&amp;gt; PP_COMMA() -&amp;gt; ,
```&lt;/p&gt;
&lt;p&gt;如果只是写 &lt;code&gt;PP_COMMA PP_LPAREN() PP_RPAREN()&lt;/code&gt;，预处理器只会分别处理每个宏，对展开的结果不会再合并处理。加上 &lt;code&gt;PP_IDENTITY&lt;/code&gt; 之后，预处理器可以对展开得到的 &lt;code&gt;PP_COMMA()&lt;/code&gt; 再进行求值，得到 &lt;code&gt;,&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;拼接&lt;/h4&gt;
&lt;p&gt;由于 &lt;code&gt;##&lt;/code&gt; 拼接的时候，是不会展开左右两边的参数，为了让参数可以先求值再拼接，可以这样写：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define PP_CONCAT(arg0, arg1) PP_CONCAT_IMPL(arg0, arg1)&lt;/h1&gt;
&lt;h1&gt;define PP_CONCAT_IMPL(arg0, arg1) arg0 ## arg1&lt;/h1&gt;
&lt;p&gt;PP_CONCAT(PP_IDENTITY(1), PP_IDENTITY(2))         // -&amp;gt; 12
PP_CONCAT_IMPL(PP_IDENTITY(1), PP_IDENTITY(2))    // -&amp;gt; PP_IDENTITY(1)PP_IDENTITY(2) -&amp;gt; 报错
```&lt;/p&gt;
&lt;p&gt;这里 &lt;code&gt;PP_CONCAT&lt;/code&gt; 用到的方法叫做延迟拼接，在展开为 &lt;code&gt;PP_CONCAT_IMPL&lt;/code&gt; 的时候，&lt;code&gt;arg0&lt;/code&gt; 和 &lt;code&gt;arg1&lt;/code&gt; 都会先展开求值，之后再由 &lt;code&gt;PP_CONCAT_IMPL&lt;/code&gt; 执行真正的拼接操作。&lt;/p&gt;
&lt;h4&gt;逻辑运算&lt;/h4&gt;
&lt;p&gt;借助 &lt;code&gt;PP_CONCAT&lt;/code&gt; 可以实现逻辑运算。首先定义 &lt;code&gt;BOOL&lt;/code&gt; 值：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define PP_BOOL(arg0) PP_CONCAT(PP_BOOL_, arg0)&lt;/h1&gt;
&lt;h1&gt;define PP_BOOL_0 0&lt;/h1&gt;
&lt;h1&gt;define PP_BOOL_1 1&lt;/h1&gt;
&lt;h1&gt;define PP_BOOL_2 1&lt;/h1&gt;
&lt;h1&gt;define PP_BOOL_3 1&lt;/h1&gt;
&lt;p&gt;// ...&lt;/p&gt;
&lt;h1&gt;define PP_BOOL_256 1&lt;/h1&gt;
&lt;p&gt;PP_BOOL(3)              // -&amp;gt; PP_BOOL_3 -&amp;gt; 1
```&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;PP_CONCAT&lt;/code&gt; 先把 &lt;code&gt;PP_BOOL_&lt;/code&gt; 和 &lt;code&gt;arg0&lt;/code&gt; 拼接在一起，再对拼接结果进行求值。这里的 &lt;code&gt;arg0&lt;/code&gt; 要求是求值之后得到 &lt;code&gt;[0, 256]&lt;/code&gt; 范围的数字，拼接在 &lt;code&gt;PP_BOOL_&lt;/code&gt; 后面求值，就能得到布尔值。与或非运算：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define PP_NOT(arg0) PP_CONCAT(PP_NOT_, PP_BOOL(arg0))&lt;/h1&gt;
&lt;h1&gt;define PP_NOT_0 1&lt;/h1&gt;
&lt;h1&gt;define PP_NOT_1 0&lt;/h1&gt;
&lt;h1&gt;define PP_AND(arg0, arg1) PP_CONCAT(PP_AND_, PP_CONCAT(PP_BOOL(arg0), PP_BOOL(arg1)))&lt;/h1&gt;
&lt;h1&gt;define PP_AND_00 0&lt;/h1&gt;
&lt;h1&gt;define PP_AND_01 0&lt;/h1&gt;
&lt;h1&gt;define PP_AND_10 0&lt;/h1&gt;
&lt;h1&gt;define PP_AND_11 1&lt;/h1&gt;
&lt;h1&gt;define PP_OR(arg0, arg1) PP_CONCAT(PP_OR_, PP_CONCAT(PP_BOOL(arg0), PP_BOOL(arg1)))&lt;/h1&gt;
&lt;h1&gt;define PP_OR_00 0&lt;/h1&gt;
&lt;h1&gt;define PP_OR_01 1&lt;/h1&gt;
&lt;h1&gt;define PP_OR_10 1&lt;/h1&gt;
&lt;h1&gt;define PP_OR_11 1&lt;/h1&gt;
&lt;p&gt;PP_NOT(PP_BOOL(2))      // -&amp;gt; PP_CONCAT(PP_NOT_, 1) -&amp;gt; PP_NOT_1 -&amp;gt; 0
PP_AND(2, 3)            // -&amp;gt; PP_CONCAT(PP_AND_, 11) -&amp;gt; PP_AND_11 -&amp;gt; 1
PP_AND(2, 0)            // -&amp;gt; PP_CONCAT(PP_AND_, 10) -&amp;gt; PP_AND_10 -&amp;gt; 0
PP_OR(2, 0)             // -&amp;gt; PP_CONCAT(PP_OR_, 10) -&amp;gt; PP_OR_10, -&amp;gt; 1
```&lt;/p&gt;
&lt;p&gt;先用 &lt;code&gt;PP_BOOL&lt;/code&gt; 对参数求值，之后再根据 &lt;code&gt;0 1&lt;/code&gt; 的组合来拼接逻辑运算的结果。如果不用 &lt;code&gt;PP_BOOL&lt;/code&gt; 来求值，那么参数就只能支持 &lt;code&gt;0 1&lt;/code&gt; 两种数值，适用性大大降低。同理也可以写出异或，或非等操作，有兴趣可以自己尝试。&lt;/p&gt;
&lt;h4&gt;条件选择&lt;/h4&gt;
&lt;p&gt;利用 &lt;code&gt;PP_BOOL&lt;/code&gt; 和 &lt;code&gt;PP_CONCAT&lt;/code&gt;，还可以写出条件选择语句：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define PP_IF(if, then, else) PP_CONCAT(PP_IF_, PP_BOOL(if))(then, else)&lt;/h1&gt;
&lt;h1&gt;define PP_IF_1(then, else) then&lt;/h1&gt;
&lt;h1&gt;define PP_IF_0(then, else) else&lt;/h1&gt;
&lt;p&gt;PP_IF(1, 2, 3)      // -&amp;gt; PP_IF_1(2, 3) -&amp;gt; 2
PP_IF(0, 2, 3)      // -&amp;gt; PP_IF_0(2, 3) -&amp;gt; 3
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt; 求值如果是 &lt;code&gt;1&lt;/code&gt;，用 &lt;code&gt;PP_CONCAT&lt;/code&gt; 拼接成 &lt;code&gt;PP_IF_1&lt;/code&gt;，最后展开为 &lt;code&gt;then&lt;/code&gt; 的值；同理若 &lt;code&gt;if&lt;/code&gt; 求值为 &lt;code&gt;0&lt;/code&gt;，得到 &lt;code&gt;PP_IF_0&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;递增递减&lt;/h4&gt;
&lt;p&gt;整数递增递减：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define PP_INC(arg0) PP_CONCAT(PP_INC_, arg0)&lt;/h1&gt;
&lt;h1&gt;define PP_INC_0 1&lt;/h1&gt;
&lt;h1&gt;define PP_INC_1 2&lt;/h1&gt;
&lt;h1&gt;define PP_INC_2 3&lt;/h1&gt;
&lt;h1&gt;define PP_INC_3 4&lt;/h1&gt;
&lt;p&gt;// ...&lt;/p&gt;
&lt;h1&gt;define PP_INC_255 256&lt;/h1&gt;
&lt;h1&gt;define PP_INC_256 256&lt;/h1&gt;
&lt;h1&gt;define PP_DEC(arg0) PP_CONCAT(PP_DEC_, arg0)&lt;/h1&gt;
&lt;h1&gt;define PP_DEC_0 0&lt;/h1&gt;
&lt;h1&gt;define PP_DEC_1 0&lt;/h1&gt;
&lt;h1&gt;define PP_DEC_2 1&lt;/h1&gt;
&lt;h1&gt;define PP_DEC_3 2&lt;/h1&gt;
&lt;p&gt;// ...&lt;/p&gt;
&lt;h1&gt;define PP_DEC_255 254&lt;/h1&gt;
&lt;h1&gt;define PP_DEC_256 255&lt;/h1&gt;
&lt;p&gt;PP_INC(2)                   // -&amp;gt; PP_INC_2 -&amp;gt; 3
PP_DEC(3)                   // -&amp;gt; PP_DEC_3 -&amp;gt; 2
```&lt;/p&gt;
&lt;p&gt;跟 &lt;code&gt;PP_BOOL&lt;/code&gt; 类似，整数的递增递减也是有范围限制的，这里范围设置为 &lt;code&gt;[0, 256]&lt;/code&gt;，递增到 &lt;code&gt;256&lt;/code&gt; 之后，安全起见，&lt;code&gt;PP_INC_256&lt;/code&gt; 会返回自身 &lt;code&gt;256&lt;/code&gt; 作为边界，同理 &lt;code&gt;PP_DEC_0&lt;/code&gt; 也是返回 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;变长参数&lt;/h4&gt;
&lt;p&gt;宏可以接受变长参数，格式是：&lt;/p&gt;
&lt;p&gt;```cpp&lt;/p&gt;
&lt;h1&gt;define LOG(format, ...) printf(&#34;log: &#34; format, &lt;strong&gt;VA_ARGS&lt;/strong&gt;)&lt;/h1&gt;
&lt;p&gt;LOG(&#34;Hello %s\n&#34;, &#34;World&#34;)      // -&amp;gt; printf(&#34;log: &#34; &#34;Hello %s\n&#34;, &#34;World&#34;);
LOG(&#34;Hello World&#34;)              // -&amp;gt; printf(&#34;log: &#34; &#34;Hello World&#34;, ); 多了个逗号，编译报错
```&lt;/p&gt;
&lt;p&gt;由于变长参数有可能为空，空的情况下会导致编译失败，因此 C++ 20 引入了 &lt;code&gt;__VA_OPT__&lt;/code&gt;，如果变长参数是空，则返回空，否则返回原参数：&lt;/p&gt;
&lt;p&gt;```cpp&lt;/p&gt;
&lt;h1&gt;define LOG2(format, ...) printf(&#34;log: &#34; format &lt;strong&gt;VA_OPT&lt;/strong&gt;(,) &lt;strong&gt;VA_ARGS&lt;/strong&gt;)&lt;/h1&gt;
&lt;p&gt;LOG2(&#34;Hello %s\n&#34;, &#34;World&#34;)      // -&amp;gt; printf(&#34;log: &#34; &#34;Hello %s\n&#34;, &#34;World&#34;);
LOG2(&#34;Hello World&#34;)              // -&amp;gt; printf(&#34;log: &#34; &#34;Hello World&#34; ); 没有逗号，正常编译
```&lt;/p&gt;
&lt;p&gt;但可惜只有 C++ 20 以上标准才有这个宏，下文中我们将会给出 &lt;code&gt;__VA_OPT__&lt;/code&gt; 的实现方法。&lt;/p&gt;
&lt;h4&gt;惰性求值&lt;/h4&gt;
&lt;p&gt;考虑这种情况：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
PP_IF(1, PP_COMMA(), PP_LPAREN())     // -&amp;gt; PP_IF_1(,,)) -&amp;gt; 报错 unterminated argument list invoking macro &#34;PP_IF_1&#34;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们知道，宏展开的时候会对先参数进行求值。&lt;code&gt;PP_COMMA()&lt;/code&gt; 和 &lt;code&gt;PP_LPAREN()&lt;/code&gt; 求值之后再传给 &lt;code&gt;PP_IF_1&lt;/code&gt;，得到 &lt;code&gt;PP_IF_1(,,))&lt;/code&gt;，导致预处理出错。此时，可以采用一种叫做惰性求值方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
PP_IF(1, PP_COMMA, PP_LPAREN)()       // -&amp;gt; PP_IF_1(PP_COMMA, PP_LPAREN)() -&amp;gt; PP_COMMA() -&amp;gt; ,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;改成这种写法，只传宏的名字，让 &lt;code&gt;PP_IF&lt;/code&gt; 选出需要的宏名字之后，再跟括号 &lt;code&gt;()&lt;/code&gt; 拼接在一起组成完成的宏，最后再展开。惰性求值在宏编程里面也是很常见的。&lt;/p&gt;
&lt;h4&gt;以括号开始&lt;/h4&gt;
&lt;p&gt;判断变长参数是否以括号开始：&lt;/p&gt;
&lt;p&gt;``` cpp
#define PP_IS_BEGIN_PARENS(...) \
    PP_IS_BEGIN_PARENS_PROCESS( \
        PP_IS_BEGIN_PARENS_CONCAT( \
            PP_IS_BEGIN_PARENS_PRE_, PP_IS_BEGIN_PARENS_EAT &lt;strong&gt;VA_ARGS&lt;/strong&gt; \
        ) \
    )&lt;/p&gt;
&lt;h1&gt;define PP_IS_BEGIN_PARENS_PROCESS(...) PP_IS_BEGIN_PARENS_PROCESS_0(&lt;strong&gt;VA_ARGS&lt;/strong&gt;)&lt;/h1&gt;
&lt;h1&gt;define PP_IS_BEGIN_PARENS_PROCESS_0(arg0, ...) arg0&lt;/h1&gt;
&lt;h1&gt;define PP_IS_BEGIN_PARENS_CONCAT(arg0, ...) PP_IS_BEGIN_PARENS_CONCAT_IMPL(arg0, &lt;strong&gt;VA_ARGS&lt;/strong&gt;)&lt;/h1&gt;
&lt;h1&gt;define PP_IS_BEGIN_PARENS_CONCAT_IMPL(arg0, ...) arg0 ## &lt;strong&gt;VA_ARGS&lt;/strong&gt;&lt;/h1&gt;
&lt;h1&gt;define PP_IS_BEGIN_PARENS_PRE_1 1,&lt;/h1&gt;
&lt;h1&gt;define PP_IS_BEGIN_PARENS_PRE_PP_IS_BEGIN_PARENS_EAT 0,&lt;/h1&gt;
&lt;h1&gt;define PP_IS_BEGIN_PARENS_EAT(...) 1&lt;/h1&gt;
&lt;p&gt;PP_IS_BEGIN_PARENS(())              // -&amp;gt; 1
PP_IS_BEGIN_PARENS((()))            // -&amp;gt; 1
PP_IS_BEGIN_PARENS(a, b, c)         // -&amp;gt; 0
PP_IS_BEGIN_PARENS(a, ())           // -&amp;gt; 0
PP_IS_BEGIN_PARENS(a())             // -&amp;gt; 0
PP_IS_BEGIN_PARENS(()aa(bb()cc))    // -&amp;gt; 1
PP_IS_BEGIN_PARENS(aa(bb()cc))      // -&amp;gt; 0
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PP_IS_BEGIN_PARENS&lt;/code&gt; 可以用来判断传入的参数是否以括号开始，在需要处理括号参数的时候会需要用到（譬如后面说到的 &lt;code&gt;__VA_OPT__&lt;/code&gt; 实现）。看上去有点复杂，核心思想就是构建出一个宏，若变长参数以括号开始，则可以跟括号连在一起求值得到一种结果，否则就另外求值得到另一种结果。我们来慢慢看：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PP_IS_BEGIN_PARENS_PROCESS&lt;/code&gt; 和 &lt;code&gt;PP_IS_BEGIN_PARENS_PROCESS_0&lt;/code&gt; 组成的宏功能是先对传入的不定参数求值，然后取第 0 个参数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PP_IS_BEGIN_PARENS_CONCAT(PP_IS_BEGIN_PARENS_PRE_, PP_IS_BEGIN_PARENS_EAT __VA_ARGS__)&lt;/code&gt; 是先对 &lt;code&gt;PP_IS_BEGIN_PARENS_EAT __VA_ARGS__&lt;/code&gt; 求值，在把求值结果跟 &lt;code&gt;PP_IS_BEGIN_PARENS_PRE_&lt;/code&gt; 拼接在一起。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PP_IS_BEGIN_PARENS_EAT(...)&lt;/code&gt; 宏会吞掉所有参数，返回1，如果上一步 &lt;code&gt;PP_IS_BEGIN_PARENS_EAT __VA_ARGS__&lt;/code&gt; 中，&lt;code&gt;__VA_ARGS__&lt;/code&gt; 是以括号开始的，那么就会匹配到对 &lt;code&gt;PP_IS_BEGIN_PARENS_EAT(...)&lt;/code&gt; 的求值，然后返回 &lt;code&gt;1&lt;/code&gt;；相反，如果不是以括号开始，则没有匹配上，&lt;code&gt;PP_IS_BEGIN_PARENS_EAT __VA_ARGS__&lt;/code&gt; 会保留不变。&lt;/p&gt;
&lt;p&gt;若 &lt;code&gt;PP_IS_BEGIN_PARENS_EAT __VA_ARGS__&lt;/code&gt; 求值得到 &lt;code&gt;1&lt;/code&gt;，&lt;code&gt;PP_IS_BEGIN_PARENS_CONCAT(PP_IS_BEGIN_PARENS_PRE_, 1) -&amp;gt; PP_IS_BEGIN_PARENS_PRE_1 -&amp;gt; 1,&lt;/code&gt;，注意 &lt;code&gt;1&lt;/code&gt; 后面是有个逗号的，把 &lt;code&gt;1,&lt;/code&gt; 传给 &lt;code&gt;PP_IS_BEGIN_PARENS_PROCESS_0&lt;/code&gt;，取第 0 个参数，最后得到 &lt;code&gt;1&lt;/code&gt;，表示参数是以括号开始。&lt;/p&gt;
&lt;p&gt;若 &lt;code&gt;PP_IS_BEGIN_PARENS_EAT __VA_ARGS__&lt;/code&gt; 求值得到不是 &lt;code&gt;1&lt;/code&gt;，而是保持不变，则 &lt;code&gt;PP_IS_BEGIN_PARENS_CONCAT(PP_IS_BEGIN_PARENS_PRE_, PP_IS_BEGIN_PARENS_EAT __VA_ARGS__) -&amp;gt; PP_IS_BEGIN_PARENS_PRE_PP_IS_BEGIN_PARENS_EAT __VA_ARGS__ -&amp;gt; 0, __VA_ARGS__&lt;/code&gt;，传给 &lt;code&gt;PP_IS_BEGIN_PARENS_PROCESS_0&lt;/code&gt; 得到的是 &lt;code&gt;0&lt;/code&gt;，表示参数不是以括号开始。&lt;/p&gt;
&lt;h4&gt;变长参数空&lt;/h4&gt;
&lt;p&gt;判断变长参数是否为空也是一个常用的宏，在实现 &lt;code&gt;__VA_OPT__&lt;/code&gt; 的时候需要用到，我们在这里利用 &lt;code&gt;PP_IS_BEGIN_PARENS&lt;/code&gt;，可以先写出不完整的版本：&lt;/p&gt;
&lt;p&gt;``` cpp
#define PP_IS_EMPTY_PROCESS(...) \
    PP_IS_BEGIN_PARENS(PP_IS_EMPTY_PROCESS_EAT &lt;strong&gt;VA_ARGS&lt;/strong&gt; ())&lt;/p&gt;
&lt;h1&gt;define PP_IS_EMPTY_PROCESS_EAT(...) ()&lt;/h1&gt;
&lt;p&gt;PP_IS_EMPTY_PROCESS()       // -&amp;gt; 1
PP_IS_EMPTY_PROCESS(1)      // -&amp;gt; 0
PP_IS_EMPTY_PROCESS(1, 2)   // -&amp;gt; 0
PP_IS_EMPTY_PROCESS(())     // -&amp;gt; 1
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PP_IS_EMPTY_PROCESS&lt;/code&gt; 的作用是判断 &lt;code&gt;PP_IS_EMPTY_PROCESS_EAT __VA_ARGS__ ()&lt;/code&gt; 是否以括号开始。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;__VA_ARGS__&lt;/code&gt; 是空，&lt;code&gt;PP_IS_EMPTY_PROCESS_EAT __VA_ARGS__ () -&amp;gt; PP_IS_EMPTY_PROCESS_EAT() -&amp;gt; ()&lt;/code&gt;，得到的是一对括号 &lt;code&gt;()&lt;/code&gt;，再传给 &lt;code&gt;PP_IS_BEGIN_PARENS&lt;/code&gt; 返回 &lt;code&gt;1&lt;/code&gt;，表示参数是空。&lt;/p&gt;
&lt;p&gt;否则，&lt;code&gt;PP_IS_EMPTY_PROCESS_EAT __VA_ARGS__ ()&lt;/code&gt; 保持不变地传给 &lt;code&gt;PP_IS_BEGIN_PARENS&lt;/code&gt;，返回 0，表示非空。&lt;/p&gt;
&lt;p&gt;留意第 4 个例子 &lt;code&gt;PP_IS_EMPTY_PROCESS(()) -&amp;gt; 1&lt;/code&gt;，&lt;code&gt;PP_IS_EMPTY_PROCESS&lt;/code&gt; 不能正确处理以括号开始的变长参数，因为这时变长参数带来的括号会匹配 &lt;code&gt;PP_IS_EMPTY_PROCESS_EAT&lt;/code&gt; 导致求值得到 &lt;code&gt;()&lt;/code&gt;。为了解决这个问题，我们需要区别对待参数是否以括号开始的情况：&lt;/p&gt;
&lt;p&gt;``` cpp
#define PP_IS_EMPTY(...) \
    PP_IS_EMPTY_IF(PP_IS_BEGIN_PARENS(&lt;strong&gt;VA_ARGS&lt;/strong&gt;)) \
        (PP_IS_EMPTY_ZERO, PP_IS_EMPTY_PROCESS)(&lt;strong&gt;VA_ARGS&lt;/strong&gt;)&lt;/p&gt;
&lt;h1&gt;define PP_IS_EMPTY_IF(if) PP_CONCAT(PP_IS_EMPTY_IF_, if)&lt;/h1&gt;
&lt;h1&gt;define PP_IS_EMPTY_IF_1(then, else) then&lt;/h1&gt;
&lt;h1&gt;define PP_IS_EMPTY_IF_0(then, else) else&lt;/h1&gt;
&lt;h1&gt;define PP_IS_EMPTY_ZERO(...) 0&lt;/h1&gt;
&lt;p&gt;PP_IS_EMPTY()       // -&amp;gt; 1
PP_IS_EMPTY(1)      // -&amp;gt; 0
PP_IS_EMPTY(1, 2)   // -&amp;gt; 0
PP_IS_EMPTY(())     // -&amp;gt; 0
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PP_IS_EMPTY_IF&lt;/code&gt; 根据 &lt;code&gt;if&lt;/code&gt; 条件来返回第 0 或者 第 1 个参数。&lt;/p&gt;
&lt;p&gt;如果传入的变长参数以括号开始，&lt;code&gt;PP_IS_EMPTY_IF&lt;/code&gt; 返回 &lt;code&gt;PP_IS_EMPTY_ZERO&lt;/code&gt;，最后返回 &lt;code&gt;0&lt;/code&gt;，表示变长参数非空。&lt;/p&gt;
&lt;p&gt;反之 &lt;code&gt;PP_IS_EMPTY_IF&lt;/code&gt; 返回 &lt;code&gt;PP_IS_EMPTY_PROCESS&lt;/code&gt;，最后由 &lt;code&gt;PP_IS_EMPTY_PROCESS&lt;/code&gt; 来判断变长参数是否非空。&lt;/p&gt;
&lt;h4&gt;下标访问&lt;/h4&gt;
&lt;p&gt;获取变长参数指定位置的元素：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define PP_ARGS_ELEM(I, ...) PP_CONCAT(PP_ARGS_ELEM_, I)(&lt;strong&gt;VA_ARGS&lt;/strong&gt;)&lt;/h1&gt;
&lt;h1&gt;define PP_ARGS_ELEM_0(a0, ...) a0&lt;/h1&gt;
&lt;h1&gt;define PP_ARGS_ELEM_1(a0, a1, ...) a1&lt;/h1&gt;
&lt;h1&gt;define PP_ARGS_ELEM_2(a0, a1, a2, ...) a2&lt;/h1&gt;
&lt;h1&gt;define PP_ARGS_ELEM_3(a0, a1, a2, a3, ...) a3&lt;/h1&gt;
&lt;p&gt;// ...&lt;/p&gt;
&lt;h1&gt;define PP_ARGS_ELEM_7(a0, a1, a2, a3, a4, a5, a6, a7, ...) a7&lt;/h1&gt;
&lt;h1&gt;define PP_ARGS_ELEM_8(a0, a1, a2, a3, a4, a5, a6, a7, a8, ...) a8&lt;/h1&gt;
&lt;p&gt;PP_ARGS_ELEM(0, &#34;Hello&#34;, &#34;World&#34;)   // -&amp;gt; PP_ARGS_ELEM_0(&#34;Hello&#34;, &#34;World&#34;) -&amp;gt; &#34;Hello&#34;
PP_ARGS_ELEM(1, &#34;Hello&#34;, &#34;World&#34;)   // -&amp;gt; PP_ARGS_ELEM_1(&#34;Hello&#34;, &#34;World&#34;) -&amp;gt; &#34;World&#34;
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PP_ARGS_ELEM&lt;/code&gt; 的第一个参数是元素下标 &lt;code&gt;I&lt;/code&gt;，后面是变长参数。利用 &lt;code&gt;PP_CONCAT&lt;/code&gt; 拼接 &lt;code&gt;PP_ARGS_ELEM_&lt;/code&gt; 和 &lt;code&gt;I&lt;/code&gt;，即可以得到返回相应位置元素的宏 &lt;code&gt;PP_ARGS_ELEM_0..8&lt;/code&gt;，再把变长参数传给该宏，展开返回下标对应位置的元素。&lt;/p&gt;
&lt;h4&gt;PP_IS_EMPTY2&lt;/h4&gt;
&lt;p&gt;利用 &lt;code&gt;PP_ARGS_ELEM&lt;/code&gt; 也可以实现另一版本的 &lt;code&gt;PP_IS_EMPTY&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;``` cpp
#define PP_IS_EMPTY2(...) \
    PP_AND( \
        PP_AND( \
            PP_NOT(PP_HAS_COMMA(&lt;strong&gt;VA_ARGS&lt;/strong&gt;)), \
            PP_NOT(PP_HAS_COMMA(&lt;strong&gt;VA_ARGS&lt;/strong&gt;())) \
        ), \
        PP_AND( \
            PP_NOT(PP_HAS_COMMA(PP_COMMA_ARGS &lt;strong&gt;VA_ARGS&lt;/strong&gt;)), \
            PP_HAS_COMMA(PP_COMMA_ARGS &lt;strong&gt;VA_ARGS&lt;/strong&gt; ()) \
        ) \
    )&lt;/p&gt;
&lt;h1&gt;define PP_HAS_COMMA(...) PP_ARGS_ELEM(8, &lt;strong&gt;VA_ARGS&lt;/strong&gt;, 1, 1, 1, 1, 1, 1, 1, 0)&lt;/h1&gt;
&lt;h1&gt;define PP_COMMA_ARGS(...) ,&lt;/h1&gt;
&lt;p&gt;PP_IS_EMPTY2()              // -&amp;gt; 1
PP_IS_EMPTY2(a)             // -&amp;gt; 0
PP_IS_EMPTY2(a, b)          // -&amp;gt; 0
PP_IS_EMPTY2(())            // -&amp;gt; 0
PP_IS_EMPTY2(PP_COMMA)      // -&amp;gt; 0
```&lt;/p&gt;
&lt;p&gt;借用 &lt;code&gt;PP_ARGS_ELEM&lt;/code&gt; 实现判断参数是否含有逗号 &lt;code&gt;PP_HAS_COMMA&lt;/code&gt;。&lt;code&gt;PP_COMMA_ARGS&lt;/code&gt; 会吞掉传入的任意参数，返回一个逗号。&lt;/p&gt;
&lt;p&gt;判断变长参数是否为空的基础逻辑是 &lt;code&gt;PP_COMMA_ARGS __VA_ARGS__ ()&lt;/code&gt; 返回一个逗号，也就是 &lt;code&gt;__VA_ARGS__&lt;/code&gt; 为空，&lt;code&gt;PP_COMMA_ARGS&lt;/code&gt; 和 &lt;code&gt;()&lt;/code&gt; 拼接在一起求值，具体的写法就是 &lt;code&gt;PP_HAS_COMMA(PP_COMMA_ARGS __VA_ARGS__ ())&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是会有例外的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__VA_ARGS__&lt;/code&gt; 本身有可能会带来逗号；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__VA_ARGS__ ()&lt;/code&gt; 拼接在一起发生求值带来逗号；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PP_COMMA_ARGS __VA_ARGS__&lt;/code&gt; 拼接在一起发生求值带来逗号；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对上面说到的三种例外情况，需要做排除，所以最后的写法等价于对以下 4 个条件执行与逻辑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PP_NOT(PP_HAS_COMMA(__VA_ARGS__))&lt;/code&gt; &amp;amp;&amp;amp;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PP_NOT(PP_HAS_COMMA(__VA_ARGS__()))&lt;/code&gt; &amp;amp;&amp;amp;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PP_NOT(PP_HAS_COMMA(PP_COMMA_ARGS __VA_ARGS__))&lt;/code&gt; &amp;amp;&amp;amp;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PP_HAS_COMMA(PP_COMMA_ARGS __VA_ARGS__ ())&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;__VA_OPT__&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;利用 &lt;code&gt;PP_IS_EMPTY&lt;/code&gt; 终于可以来实现类似 &lt;code&gt;__VA_OPT__&lt;/code&gt; 的宏：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define PP_REMOVE_PARENS(tuple) PP_REMOVE_PARENS_IMPL tuple&lt;/h1&gt;
&lt;h1&gt;define PP_REMOVE_PARENS_IMPL(...) &lt;strong&gt;VA_ARGS&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;#define PP_ARGS_OPT(data_tuple, empty_tuple, ...) \
    PP_ARGS_OPT_IMPL(PP_IF(PP_IS_EMPTY(&lt;strong&gt;VA_ARGS&lt;/strong&gt;), empty_tuple, data_tuple))&lt;/p&gt;
&lt;h1&gt;define PP_ARGS_OPT_IMPL(tuple) PP_REMOVE_PARENS(tuple)&lt;/h1&gt;
&lt;p&gt;PP_ARGS_OPT((data), (empty))        // -&amp;gt; empty
PP_ARGS_OPT((data), (empty), 1)     // -&amp;gt; data
PP_ARGS_OPT((,), (), 1)             // -&amp;gt; ,
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PP_ARGS_OPT&lt;/code&gt; 接受两个固定参数和变长参数，变长参数非空时返回 &lt;code&gt;data&lt;/code&gt;，否则返回 &lt;code&gt;empty&lt;/code&gt;。为了让 &lt;code&gt;data&lt;/code&gt; 和 &lt;code&gt;empty&lt;/code&gt; 支持逗号，要求两者都要用括号包住实际的参数，最后用 &lt;code&gt;PP_REMOVE_PARENS&lt;/code&gt; 来移除外层的括号。&lt;/p&gt;
&lt;p&gt;有了 &lt;code&gt;PP_ARGS_OPT&lt;/code&gt; 可以实现 &lt;code&gt;LOG3&lt;/code&gt; 来模拟 &lt;code&gt;LOG2&lt;/code&gt; 实现的功能：&lt;/p&gt;
&lt;p&gt;``` cpp
#define LOG3(format, ...) \
    printf(&#34;log: &#34; format PP_ARGS_OPT((,), (), &lt;strong&gt;VA_ARGS&lt;/strong&gt;) &lt;strong&gt;VA_ARGS&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;LOG3(&#34;Hello&#34;);                  // -&amp;gt; printf(&#34;log: &#34; &#34;Hello&#34; );
LOG3(&#34;Hello %s&#34;, &#34;World&#34;);      // -&amp;gt; printf(&#34;log: &#34; &#34;Hello %s&#34; , &#34;World&#34;);
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;data_tuple&lt;/code&gt; 是 &lt;code&gt;(,)&lt;/code&gt;，如果变长参数非空，则会返回 &lt;code&gt;data_tuple&lt;/code&gt; 里面的所有元素，在这里就是逗号 &lt;code&gt;,&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;求参数个数&lt;/h4&gt;
&lt;p&gt;获取变长参数的个数：&lt;/p&gt;
&lt;p&gt;``` cpp
#define PP_ARGS_SIZE_IMCOMPLETE(...) \
    PP_ARGS_ELEM(8, &lt;strong&gt;VA_ARGS&lt;/strong&gt;, 8, 7, 6, 5, 4, 3, 2, 1, 0)&lt;/p&gt;
&lt;p&gt;PP_ARGS_SIZE_IMCOMPLETE(a)             // -&amp;gt; 1
PP_ARGS_SIZE_IMCOMPLETE(a, b)          // -&amp;gt; 2
PP_ARGS_SIZE_IMCOMPLETE(PP_COMMA())    // -&amp;gt; 2
PP_ARGS_SIZE_IMCOMPLETE()              // -&amp;gt; 1
```&lt;/p&gt;
&lt;p&gt;计算变长参数的个数，是通过数参数的位置来获得的。&lt;code&gt;__VA_ARGS__&lt;/code&gt; 会导致后续的参数全体往右移动，用宏 &lt;code&gt;PP_ARGS_ELEM&lt;/code&gt; 来获取第 8 个位置的参数，如果 &lt;code&gt;__VA_ARGS__&lt;/code&gt; 只有一个参数，则第 8 个参数等于 &lt;code&gt;1&lt;/code&gt;；同理如果 &lt;code&gt;__VA_ARGS__&lt;/code&gt; 有两个参数，则第 8 个参数就变为 &lt;code&gt;2&lt;/code&gt;，刚好等于变长参数的个数。&lt;/p&gt;
&lt;p&gt;这里给的例子只最高支持个数 8 的变长参数，这是依赖于 &lt;code&gt;PP_ARGS_ELEM&lt;/code&gt; 所能支持的最大长度。&lt;/p&gt;
&lt;p&gt;但是这个宏还不完整，在变长参数为空的情况下，这个宏会错误返回 &lt;code&gt;1&lt;/code&gt;。如果需要处理空的变长参数，则需要用到我们前面说到的 &lt;code&gt;PP_ARGS_OPT&lt;/code&gt; 宏：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define PP_COMMA_IF_ARGS(...) PP_ARGS_OPT((,), (), &lt;strong&gt;VA_ARGS&lt;/strong&gt;)&lt;/h1&gt;
&lt;h1&gt;define PP_ARGS_SIZE(...) PP_ARGS_ELEM(8, &lt;strong&gt;VA_ARGS&lt;/strong&gt; PP_COMMA_IF_ARGS(&lt;strong&gt;VA_ARGS&lt;/strong&gt;) 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0)&lt;/h1&gt;
&lt;p&gt;PP_ARGS_SIZE(a)             // -&amp;gt; 1
PP_ARGS_SIZE(a, b)          // -&amp;gt; 2
PP_ARGS_SIZE(PP_COMMA())    // -&amp;gt; 2
PP_ARGS_SIZE()              // -&amp;gt; 0
PP_ARGS_SIZE(,,,)           // -&amp;gt; 4
```&lt;/p&gt;
&lt;p&gt;问题的关键就是逗号 &lt;code&gt;,&lt;/code&gt;，在 &lt;code&gt;__VA_ARGS__&lt;/code&gt; 为空的时候，把逗号隐去就能正确返回 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;遍历访问&lt;/h4&gt;
&lt;p&gt;类似 C++ 的 &lt;code&gt;for_each&lt;/code&gt;，我们可以实现宏的 &lt;code&gt;PP_FOR_EACH&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;``` cpp
#define PP_FOR_EACH(macro, contex, ...) \
    PP_CONCAT(PP_FOR_EACH_, PP_ARGS_SIZE(&lt;strong&gt;VA_ARGS&lt;/strong&gt;))(0, macro, contex, &lt;strong&gt;VA_ARGS&lt;/strong&gt;)&lt;/p&gt;
&lt;h1&gt;define PP_FOR_EACH_0(index, macro, contex, ...)&lt;/h1&gt;
&lt;h1&gt;define PP_FOR_EACH_1(index, macro, contex, arg, ...) macro(index, contex, arg)&lt;/h1&gt;
&lt;p&gt;#define PP_FOR_EACH_2(index, macro, contex, arg, ...) \
    macro(index, contex, arg) \
    PP_FOR_EACH_1(PP_INC(index), macro, contex, &lt;strong&gt;VA_ARGS&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;#define PP_FOR_EACH_3(index, macro, contex, arg, ...) \
    macro(index, contex, arg) \
    PP_FOR_EACH_2(PP_INC(index), macro, contex, &lt;strong&gt;VA_ARGS&lt;/strong&gt;)
// ...
#define PP_FOR_EACH_8(index, macro, contex, arg, ...) \
    macro(index, contex, arg) \
    PP_FOR_EACH_7(PP_INC(index), macro, contex, &lt;strong&gt;VA_ARGS&lt;/strong&gt;)&lt;/p&gt;
&lt;h1&gt;define DECLARE_EACH(index, contex, arg)    PP_IF(index, PP_COMMA, PP_EMPTY)() contex arg&lt;/h1&gt;
&lt;p&gt;PP_FOR_EACH(DECLARE_EACH, int, x, y, z);    // -&amp;gt; int x, y, z;
PP_FOR_EACH(DECLARE_EACH, bool, a, b);      // -&amp;gt; bool a, b;
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PP_FOR_EACH&lt;/code&gt; 接收两个固定参数： &lt;code&gt;macro&lt;/code&gt; 可以理解为遍历的时候调用的宏，&lt;code&gt;contex&lt;/code&gt; 可以作为固定值参数传给 &lt;code&gt;macro&lt;/code&gt;。&lt;code&gt;PP_FOR_EACH&lt;/code&gt; 先通过 &lt;code&gt;PP_ARGS_SIZE&lt;/code&gt; 获取变长参数的长度 &lt;code&gt;N&lt;/code&gt;，再用 &lt;code&gt;PP_CONCAT&lt;/code&gt; 拼接得到 &lt;code&gt;PP_FOR_EACH_N&lt;/code&gt;，之后 &lt;code&gt;PP_FOR_EACH_N&lt;/code&gt; 会迭代调用 &lt;code&gt;PP_FOR_EACH_N-1&lt;/code&gt; 来实现跟变长参数个数相同的遍历次数。&lt;/p&gt;
&lt;p&gt;例子里我们声明了 &lt;code&gt;DECLARE_EACH&lt;/code&gt; 作为参数 &lt;code&gt;macro&lt;/code&gt;，&lt;code&gt;DECLARE_EACH&lt;/code&gt; 的作用就是返回 &lt;code&gt;contex arg&lt;/code&gt;，如果 &lt;code&gt;contex&lt;/code&gt; 是类型名字，&lt;code&gt;arg&lt;/code&gt; 是变量名字，&lt;code&gt;DECLARE_EACH&lt;/code&gt; 就可以用来声明变量。&lt;/p&gt;
&lt;h4&gt;条件循环&lt;/h4&gt;
&lt;p&gt;有了 &lt;code&gt;FOR_EACH&lt;/code&gt; 之后，我们还可以用类似的写法写出 &lt;code&gt;PP_WHILE&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define PP_WHILE PP_WHILE_1&lt;/h1&gt;
&lt;h1&gt;define PP_WHILE_1(pred, op, val) PP_WHILE_1_IMPL(PP_BOOL(pred(val)), pred, op, val)&lt;/h1&gt;
&lt;p&gt;#define PP_WHILE_1_IMPL(cond, pred, op, val) \
    PP_IF(cond, PP_WHILE_2, val PP_EMPTY_EAT)(pred, op, PP_IF(cond, op, PP_EMPTY_EAT)(val))&lt;/p&gt;
&lt;h1&gt;define PP_WHILE_2(pred, op, val) PP_WHILE_2_IMPL(PP_BOOL(pred(val)), pred, op, val)&lt;/h1&gt;
&lt;p&gt;#define PP_WHILE_2_IMPL(cond, pred, op, val) \
    PP_IF(cond, PP_WHILE_3, val PP_EMPTY_EAT)(pred, op, PP_IF(cond, op, PP_EMPTY_EAT)(val))&lt;/p&gt;
&lt;h1&gt;define PP_WHILE_3(pred, op, val) PP_WHILE_3_IMPL(PP_BOOL(pred(val)), pred, op, val)&lt;/h1&gt;
&lt;p&gt;#define PP_WHILE_3_IMPL(cond, pred, op, val) \
    PP_IF(cond, PP_WHILE_4, val PP_EMPTY_EAT)(pred, op, PP_IF(cond, op, PP_EMPTY_EAT)(val))&lt;/p&gt;
&lt;h1&gt;define PP_WHILE_4(pred, op, val) PP_WHILE_4_IMPL(PP_BOOL(pred(val)), pred, op, val)&lt;/h1&gt;
&lt;p&gt;#define PP_WHILE_4_IMPL(cond, pred, op, val) \
    PP_IF(cond, PP_WHILE_5, val PP_EMPTY_EAT)(pred, op, PP_IF(cond, op, PP_EMPTY_EAT)(val))
// ...&lt;/p&gt;
&lt;h1&gt;define PP_WHILE_8(pred, op, val) PP_WHILE_8_IMPL(PP_BOOL(pred(val)), pred, op, val)&lt;/h1&gt;
&lt;p&gt;#define PP_WHILE_8_IMPL(cond, pred, op, val) \
    PP_IF(cond, PP_WHILE_8, val PP_EMPTY_EAT)(pred, op, PP_IF(cond, op, PP_EMPTY_EAT)(val))&lt;/p&gt;
&lt;h1&gt;define PP_EMPTY_EAT(...)&lt;/h1&gt;
&lt;h1&gt;define SUM_OP(xy_tuple) SUM_OP_OP_IMPL xy_tuple&lt;/h1&gt;
&lt;h1&gt;define SUM_OP_OP_IMPL(x, y) (PP_DEC(x), y + x)&lt;/h1&gt;
&lt;h1&gt;define SUM_PRED(xy_tuple) SUM_PRED_IMPL xy_tuple&lt;/h1&gt;
&lt;h1&gt;define SUM_PRED_IMPL(x, y) x&lt;/h1&gt;
&lt;p&gt;#define SUM(max_num, origin_num) \
    PP_IDENTITY(SUM_IMPL PP_WHILE(SUM_PRED, SUM_OP, (max_num, origin_num)))&lt;/p&gt;
&lt;h1&gt;define SUM_IMPL(ignore, ret) ret&lt;/h1&gt;
&lt;p&gt;PP_WHILE(SUM_PRED, SUM_OP, (2, a))      // -&amp;gt; (0, a + 2 + 1)
SUM(2, a)                               // -&amp;gt; a + 2 + 1
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PP_WHILE&lt;/code&gt; 接受三个参数： &lt;code&gt;pred&lt;/code&gt; 条件判断函数，&lt;code&gt;op&lt;/code&gt; 操作函数，&lt;code&gt;val&lt;/code&gt; 初始值；循环的过程中不断用 &lt;code&gt;pred(val)&lt;/code&gt; 来做循环终止判断，把 &lt;code&gt;op(val)&lt;/code&gt; 得到的值传给后续的宏，可以理解为执行以下代码：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
while (pred(val)) {
    val = op(val);
}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PP_WHILE_N&lt;/code&gt; 首先用 &lt;code&gt;pred(val)&lt;/code&gt; 得到条件判断结果，把条件结果 &lt;code&gt;cond&lt;/code&gt; 和其余参数再传给 &lt;code&gt;PP_WHILE_N_IMPL&lt;/code&gt;。
&lt;code&gt;PP_WHILE_N_IMPL&lt;/code&gt; 可以分两部分看：后半部分 &lt;code&gt;(pred, op, PP_IF(cond, op, PP_EMPTY_EAT)(val))&lt;/code&gt; 是作为前半部分的参数，&lt;code&gt;PP_IF(cond, op, PP_EMPTY_EAT)(val)&lt;/code&gt; 是如果 &lt;code&gt;cond&lt;/code&gt; 为真，则求值 &lt;code&gt;op(val)&lt;/code&gt;， 否则求值 &lt;code&gt;PP_EMPTY_EAT(val)&lt;/code&gt; 得到空。前半部分 &lt;code&gt;PP_IF(cond, PP_WHILE_N+1, val PP_EMPTY_EAT)&lt;/code&gt;，如果 &lt;code&gt;cond&lt;/code&gt; 为真，则返回 &lt;code&gt;PP_WHILE_N+1&lt;/code&gt;，结合后半部分的参数继续执行循环；否则返回 &lt;code&gt;val PP_EMPTY_EAT&lt;/code&gt;，此时 &lt;code&gt;val&lt;/code&gt; 就是最终的计算结果，而 &lt;code&gt;PP_EMPTY_EAT&lt;/code&gt; 会吞掉后半部分的结果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SUM&lt;/code&gt; 实现 &lt;code&gt;N + N-1 + ... + 1&lt;/code&gt;。初始值 &lt;code&gt;(max_num, origin_num)&lt;/code&gt;；&lt;code&gt;SUM_PRED&lt;/code&gt; 取值的第一个元素 &lt;code&gt;x&lt;/code&gt;，判断是否大于 0；&lt;code&gt;SUM_OP&lt;/code&gt; 对 &lt;code&gt;x&lt;/code&gt; 执行递减操作 &lt;code&gt;x = x - 1&lt;/code&gt;，对 &lt;code&gt;y&lt;/code&gt; 执行 &lt;code&gt;+ x&lt;/code&gt; 操作 &lt;code&gt;y = y + x&lt;/code&gt;。直接用 &lt;code&gt;SUM_PRED&lt;/code&gt; 和 &lt;code&gt;SUM_OP&lt;/code&gt; 传给 &lt;code&gt;PP_WHILE&lt;/code&gt;，返回的结果是一个元组，我们真正想要的结果是元组的第 2 个元素，于是再用 &lt;code&gt;SUM&lt;/code&gt; 取第 2 个元素的值。&lt;/p&gt;
&lt;h4&gt;递归重入&lt;/h4&gt;
&lt;p&gt;到目前为止，我们的遍历访问和条件循环都运作的很好，结果符合预期。还记得我们在讲宏展开规则的时候提到的禁止递归重入么，当我们想要执行两重循环的时候就不幸遇到到了禁止递归重入：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define SUM_OP2(xy_tuple) SUM_OP_OP_IMPL2 xy_tuple&lt;/h1&gt;
&lt;h1&gt;define SUM_OP_OP_IMPL2(x, y) (PP_DEC(x), y + SUM(x, 0))&lt;/h1&gt;
&lt;p&gt;#define SUM2(max_num, origin_num) \
    PP_IDENTITY(SUM_IMPL PP_WHILE(SUM_PRED, SUM_OP2, (max_num, origin_num)))&lt;/p&gt;
&lt;p&gt;SUM2(1, a)      // -&amp;gt; a + SUM_IMPL PP_WHILE_1(SUM_PRED, SUM_OP, (1, a))
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SUM2&lt;/code&gt; 把参数 &lt;code&gt;op&lt;/code&gt; 改用 &lt;code&gt;SUM_OP2&lt;/code&gt;，&lt;code&gt;SUM_OP2&lt;/code&gt; 里面会调用到 &lt;code&gt;SUM&lt;/code&gt;，而 &lt;code&gt;SUM&lt;/code&gt; 展开还会是 &lt;code&gt;PP_WHILE_1&lt;/code&gt;，相当于 &lt;code&gt;PP_WHILE_1&lt;/code&gt; 递归调用到了自身，预处理器停止展开。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们可以用一种自动推导递归的方法（Automatic Recursion）：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define PP_AUTO_WHILE PP_CONCAT(PP_WHILE_, PP_AUTO_REC(PP_WHILE_PRED))&lt;/h1&gt;
&lt;h1&gt;define PP_AUTO_REC(check) PP_IF(check(2), PP_AUTO_REC_12, PP_AUTO_REC_34)(check)&lt;/h1&gt;
&lt;h1&gt;define PP_AUTO_REC_12(check) PP_IF(check(1), 1, 2)&lt;/h1&gt;
&lt;h1&gt;define PP_AUTO_REC_34(check) PP_IF(check(3), 3, 4)&lt;/h1&gt;
&lt;p&gt;#define PP_WHILE_PRED(n) \
    PP_CONCAT(PP_WHILE_CHECK_, PP_WHILE_ ## n(PP_WHILE_FALSE, PP_WHILE_FALSE, PP_WHILE_FALSE))&lt;/p&gt;
&lt;h1&gt;define PP_WHILE_FALSE(...) 0&lt;/h1&gt;
&lt;h1&gt;define PP_WHILE_CHECK_PP_WHILE_FALSE 1&lt;/h1&gt;
&lt;h1&gt;define PP_WHILE_CHECK_PP_WHILE_1(...) 0&lt;/h1&gt;
&lt;h1&gt;define PP_WHILE_CHECK_PP_WHILE_2(...) 0&lt;/h1&gt;
&lt;h1&gt;define PP_WHILE_CHECK_PP_WHILE_3(...) 0&lt;/h1&gt;
&lt;h1&gt;define PP_WHILE_CHECK_PP_WHILE_4(...) 0&lt;/h1&gt;
&lt;p&gt;// ...&lt;/p&gt;
&lt;h1&gt;define PP_WHILE_CHECK_PP_WHILE_8(...) 0&lt;/h1&gt;
&lt;p&gt;PP_AUTO_WHILE       // -&amp;gt; PP_WHILE_1&lt;/p&gt;
&lt;p&gt;#define SUM3(max_num, origin_num) \
    PP_IDENTITY(SUM_IMPL PP_AUTO_WHILE(SUM_PRED, SUM_OP, (max_num, origin_num)))&lt;/p&gt;
&lt;h1&gt;define SUM_OP4(xy_tuple) SUM_OP_OP_IMPL4 xy_tuple&lt;/h1&gt;
&lt;h1&gt;define SUM_OP_OP_IMPL4(x, y) (PP_DEC(x), y + SUM3(x, 0))&lt;/h1&gt;
&lt;p&gt;#define SUM4(max_num, origin_num) \
    PP_IDENTITY(SUM_IMPL PP_AUTO_WHILE(SUM_PRED, SUM_OP4, (max_num, origin_num)))&lt;/p&gt;
&lt;p&gt;SUM4(2, a)          // -&amp;gt; a + 0 + 2 + 1 + 0 + 1
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PP_AUTO_WHILE&lt;/code&gt; 就是 &lt;code&gt;PP_WHILE&lt;/code&gt; 的自动推导递归版本，核心的宏是 &lt;code&gt;PP_AUTO_REC(PP_WHILE_PRED)&lt;/code&gt;，这个宏可以找出当前可用的 &lt;code&gt;PP_WHILE_N&lt;/code&gt; 版本的数字 &lt;code&gt;N&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;推导的原理很简单，就是搜索所有版本，找出能够正确展开的版本，返回该版本的数字，为了提升搜索的速度，一般的做法是使用二分查找，这就是 &lt;code&gt;PP_AUTO_REC&lt;/code&gt; 在做的事情。&lt;code&gt;PP_AUTO_REC&lt;/code&gt; 接受一个参数 &lt;code&gt;check&lt;/code&gt;，&lt;code&gt;check&lt;/code&gt; 负责检查版本可用性，这里给出的是支持搜索版本范围 &lt;code&gt;[1, 4]&lt;/code&gt;。&lt;code&gt;PP_AUTO_REC&lt;/code&gt; 会首先检查 &lt;code&gt;check(2)&lt;/code&gt;，如果 &lt;code&gt;check(2)&lt;/code&gt; 为真，则调用 &lt;code&gt;PP_AUTO_REC_12&lt;/code&gt; 搜索范围 &lt;code&gt;[1, 2]&lt;/code&gt;，否则用 &lt;code&gt;PP_AUTO_REC_34&lt;/code&gt; 搜索 &lt;code&gt;[3, 4]&lt;/code&gt;。&lt;code&gt;PP_AUTO_REC_12&lt;/code&gt; 检查 &lt;code&gt;check(1)&lt;/code&gt; 如果为真，说明版本 &lt;code&gt;1&lt;/code&gt; 可用，否则用版本 &lt;code&gt;2&lt;/code&gt;，&lt;code&gt;PP_AUTO_REC_34&lt;/code&gt; 同理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;check&lt;/code&gt; 宏要怎么写才能知道版本是否可用呢？在这里，&lt;code&gt;PP_WHILE_PRED&lt;/code&gt; 会展开成两部分的拼接，我们来看后部分 &lt;code&gt;PP_WHILE_ ## n(PP_WHILE_FALSE, PP_WHILE_FALSE, PP_WHILE_FALSE)&lt;/code&gt;：如果 &lt;code&gt;PP_WHILE_ ## n&lt;/code&gt; 可用，由于 &lt;code&gt;PP_WHILE_FALSE&lt;/code&gt; 固定返回 &lt;code&gt;0&lt;/code&gt;，这部分会展开得到 &lt;code&gt;val&lt;/code&gt; 参数的值，也就是 &lt;code&gt;PP_WHILE_FALSE&lt;/code&gt;；否则这部分宏会保持不变，依然是 &lt;code&gt;PP_WHILE_n(PP_WHILE_FALSE, PP_WHILE_FALSE, PP_WHILE_FALSE)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;把后部分的结果跟前部分 &lt;code&gt;PP_WHILE_CHECK_&lt;/code&gt; 拼接起来，得到两种结果：&lt;code&gt;PP_WHILE_CHECK_PP_WHILE_FALSE&lt;/code&gt; 或者 &lt;code&gt;PP_WHILE_CHECK_PP_WHILE_n(PP_WHILE_FALSE, PP_WHILE_FALSE, PP_WHILE_FALSE)&lt;/code&gt;，于是我们让 &lt;code&gt;PP_WHILE_CHECK_PP_WHILE_FALSE&lt;/code&gt; 返回 &lt;code&gt;1&lt;/code&gt; 表明可用，&lt;code&gt;PP_WHILE_CHECK_PP_WHILE_n&lt;/code&gt; 返回 &lt;code&gt;0&lt;/code&gt; 表示不可用。至此，我们完成了自动推导递归的功能。&lt;/p&gt;
&lt;h4&gt;算术比较&lt;/h4&gt;
&lt;p&gt;不相等：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define PP_NOT_EQUAL(x, y) PP_NOT_EQUAL_IMPL(x, y)&lt;/h1&gt;
&lt;p&gt;#define PP_NOT_EQUAL_IMPL(x, y) \
    PP_CONCAT(PP_NOT_EQUAL_CHECK_, PP_NOT_EQUAL_ ## x(0, PP_NOT_EQUAL_ ## y))&lt;/p&gt;
&lt;h1&gt;define PP_NOT_EQUAL_CHECK_PP_EQUAL_NIL 1&lt;/h1&gt;
&lt;h1&gt;define PP_NOT_EQUAL_CHECK_PP_NOT_EQUAL_0(...) 0&lt;/h1&gt;
&lt;h1&gt;define PP_NOT_EQUAL_CHECK_PP_NOT_EQUAL_1(...) 0&lt;/h1&gt;
&lt;h1&gt;define PP_NOT_EQUAL_CHECK_PP_NOT_EQUAL_2(...) 0&lt;/h1&gt;
&lt;h1&gt;define PP_NOT_EQUAL_CHECK_PP_NOT_EQUAL_3(...) 0&lt;/h1&gt;
&lt;h1&gt;define PP_NOT_EQUAL_CHECK_PP_NOT_EQUAL_4(...) 0&lt;/h1&gt;
&lt;p&gt;// ...&lt;/p&gt;
&lt;h1&gt;define PP_NOT_EQUAL_CHECK_PP_NOT_EQUAL_8(...) 0&lt;/h1&gt;
&lt;h1&gt;define PP_NOT_EQUAL_0(cond, y) PP_IF(cond, PP_EQUAL_NIL, y(1, PP_EQUAL_NIL))&lt;/h1&gt;
&lt;h1&gt;define PP_NOT_EQUAL_1(cond, y) PP_IF(cond, PP_EQUAL_NIL, y(1, PP_EQUAL_NIL))&lt;/h1&gt;
&lt;h1&gt;define PP_NOT_EQUAL_2(cond, y) PP_IF(cond, PP_EQUAL_NIL, y(1, PP_EQUAL_NIL))&lt;/h1&gt;
&lt;h1&gt;define PP_NOT_EQUAL_3(cond, y) PP_IF(cond, PP_EQUAL_NIL, y(1, PP_EQUAL_NIL))&lt;/h1&gt;
&lt;h1&gt;define PP_NOT_EQUAL_4(cond, y) PP_IF(cond, PP_EQUAL_NIL, y(1, PP_EQUAL_NIL))&lt;/h1&gt;
&lt;p&gt;// ...&lt;/p&gt;
&lt;h1&gt;define PP_NOT_EQUAL_8(cond, y) PP_IF(cond, PP_EQUAL_NIL, y(1, PP_EQUAL_NIL))&lt;/h1&gt;
&lt;p&gt;PP_NOT_EQUAL(1, 1)          // -&amp;gt; 0
PP_NOT_EQUAL(3, 1)          // -&amp;gt; 1
```&lt;/p&gt;
&lt;p&gt;判断数值是否相等，用到了禁止递归重入的特性，把 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 递归拼接成 &lt;code&gt;PP_NOT_EQUAL_x PP_NOT_EQUAL_y&lt;/code&gt; 宏，如果 &lt;code&gt;x == y&lt;/code&gt;，则不会展开 &lt;code&gt;PP_NOT_EQUAL_y&lt;/code&gt; 宏，跟 &lt;code&gt;PP_NOT_EQUAL_CHECK_&lt;/code&gt; 拼接成 &lt;code&gt;PP_NOT_EQUAL_CHECK_PP_NOT_EQUAL_y&lt;/code&gt; 返回 &lt;code&gt;0&lt;/code&gt;；反之，两次都成功展开最后得到 &lt;code&gt;PP_EQUAL_NIL&lt;/code&gt;，拼接得到 &lt;code&gt;PP_NOT_EQUAL_CHECK_PP_EQUAL_NIL&lt;/code&gt; 返回 &lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;相等：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define PP_EQUAL(x, y) PP_NOT(PP_NOT_EQUAL(x, y))&lt;/h1&gt;
&lt;p&gt;PP_EQUAL(1, 1)              // -&amp;gt; 1
PP_EQUAL(1, 3)              // -&amp;gt; 0&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;小于等于：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define PP_LESS_EQUAL(x, y) PP_NOT(PP_SUB(x, y))&lt;/h1&gt;
&lt;p&gt;PP_LESS_EQUAL(2, 1)         // -&amp;gt; 0
PP_LESS_EQUAL(1, 1)         // -&amp;gt; 1
PP_LESS_EQUAL(1, 2)         // -&amp;gt; 1
```&lt;/p&gt;
&lt;p&gt;小于：&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define PP_LESS(x, y) PP_AND(PP_LESS_EQUAL(x, y), PP_NOT_EQUAL(x, y))&lt;/h1&gt;
&lt;p&gt;PP_LESS(2, 1)               // -&amp;gt; 0
PP_LESS(1, 2)               // -&amp;gt; 1
PP_LESS(2, 2)               // -&amp;gt; 0
```&lt;/p&gt;
&lt;p&gt;另外还有大于，大于等于等等算术比较，这里不再赘述。&lt;/p&gt;
&lt;h4&gt;算术运算&lt;/h4&gt;
&lt;p&gt;利用 &lt;code&gt;PP_AUTO_WHILE&lt;/code&gt; 我们可以实现基础的算术运算了，而且支持嵌套运算。&lt;/p&gt;
&lt;p&gt;加法：&lt;/p&gt;
&lt;p&gt;``` cpp
#define PP_ADD(x, y) \
    PP_IDENTITY(PP_ADD_IMPL PP_AUTO_WHILE(PP_ADD_PRED, PP_ADD_OP, (x, y)))&lt;/p&gt;
&lt;h1&gt;define PP_ADD_IMPL(x, y) x&lt;/h1&gt;
&lt;h1&gt;define PP_ADD_PRED(xy_tuple) PP_ADD_PRED_IMPL xy_tuple&lt;/h1&gt;
&lt;h1&gt;define PP_ADD_PRED_IMPL(x, y) y&lt;/h1&gt;
&lt;h1&gt;define PP_ADD_OP(xy_tuple) PP_ADD_OP_IMPL xy_tuple&lt;/h1&gt;
&lt;h1&gt;define PP_ADD_OP_IMPL(x, y) (PP_INC(x), PP_DEC(y))&lt;/h1&gt;
&lt;p&gt;PP_ADD(1, 2)                  // -&amp;gt; 3
PP_ADD(1, PP_ADD(1, 2))       // -&amp;gt; 4
```&lt;/p&gt;
&lt;p&gt;减法：&lt;/p&gt;
&lt;p&gt;``` cpp
#define PP_SUB(x, y) \
    PP_IDENTITY(PP_SUB_IMPL PP_AUTO_WHILE(PP_SUB_PRED, PP_SUB_OP, (x, y)))&lt;/p&gt;
&lt;h1&gt;define PP_SUB_IMPL(x, y) x&lt;/h1&gt;
&lt;h1&gt;define PP_SUB_PRED(xy_tuple) PP_SUB_PRED_IMPL xy_tuple&lt;/h1&gt;
&lt;h1&gt;define PP_SUB_PRED_IMPL(x, y) y&lt;/h1&gt;
&lt;h1&gt;define PP_SUB_OP(xy_tuple) PP_SUB_OP_IMPL xy_tuple&lt;/h1&gt;
&lt;h1&gt;define PP_SUB_OP_IMPL(x, y) (PP_DEC(x), PP_DEC(y))&lt;/h1&gt;
&lt;p&gt;PP_SUB(2, 1)                // -&amp;gt; 1
PP_SUB(3, PP_ADD(2, 1))     // -&amp;gt; 0
```&lt;/p&gt;
&lt;p&gt;乘法：&lt;/p&gt;
&lt;p&gt;``` cpp
#define PP_MUL(x, y) \
    IDENTITY(PP_MUL_IMPL PP_AUTO_WHILE(PP_MUL_PRED, PP_MUL_OP, (0, x, y)))&lt;/p&gt;
&lt;h1&gt;define PP_MUL_IMPL(ret, x, y) ret&lt;/h1&gt;
&lt;h1&gt;define PP_MUL_PRED(rxy_tuple) PP_MUL_PRED_IMPL rxy_tuple&lt;/h1&gt;
&lt;h1&gt;define PP_MUL_PRED_IMPL(ret, x, y) y&lt;/h1&gt;
&lt;h1&gt;define PP_MUL_OP(rxy_tuple) PP_MUL_OP_IMPL rxy_tuple&lt;/h1&gt;
&lt;h1&gt;define PP_MUL_OP_IMPL(ret, x, y) (PP_ADD(ret, x), x, PP_DEC(y))&lt;/h1&gt;
&lt;p&gt;PP_MUL(1, 1)                // -&amp;gt; 1
PP_MUL(2, PP_ADD(0, 1))     // -&amp;gt; 2
```&lt;/p&gt;
&lt;p&gt;乘法实现这里增加了一个参数 &lt;code&gt;ret&lt;/code&gt;，初始值为 &lt;code&gt;0&lt;/code&gt;，每次迭代会执行 &lt;code&gt;ret = ret + x&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;除法：&lt;/p&gt;
&lt;p&gt;``` cpp
#define PP_DIV(x, y) \
    IDENTITY(PP_DIV_IMPL PP_AUTO_WHILE(PP_DIV_PRED, PP_DIV_OP, (0, x, y)))&lt;/p&gt;
&lt;h1&gt;define PP_DIV_IMPL(ret, x, y) ret&lt;/h1&gt;
&lt;h1&gt;define PP_DIV_PRED(rxy_tuple) PP_DIV_PRED_IMPL rxy_tuple&lt;/h1&gt;
&lt;h1&gt;define PP_DIV_PRED_IMPL(ret, x, y) PP_LESS_EQUAL(y, x)&lt;/h1&gt;
&lt;h1&gt;define PP_DIV_OP(rxy_tuple) PP_DIV_OP_IMPL rxy_tuple&lt;/h1&gt;
&lt;h1&gt;define PP_DIV_OP_IMPL(ret, x, y) (PP_INC(ret), PP_SUB(x, y), y)&lt;/h1&gt;
&lt;p&gt;PP_DIV(1, 2)                // -&amp;gt; 0
PP_DIV(2, 1)                // -&amp;gt; 2
PP_DIV(2, PP_ADD(1, 1))     // -&amp;gt; 1
```&lt;/p&gt;
&lt;p&gt;除法利用了 &lt;code&gt;PP_LESS_EQUAL&lt;/code&gt;，只有 &lt;code&gt;y &amp;lt;= x&lt;/code&gt; 的情况下才继续循环。&lt;/p&gt;
&lt;h4&gt;数据结构&lt;/h4&gt;
&lt;p&gt;宏也可以有数据结构，其实我们在前面的也稍微用到了一种数据结构 &lt;code&gt;tuple&lt;/code&gt;，&lt;code&gt;PP_REMOVE_PARENS&lt;/code&gt; 就是可以去掉 &lt;code&gt;tuple&lt;/code&gt; 的外层括号，返回里面的元素。我们这里就以 &lt;code&gt;tuple&lt;/code&gt; 为例子讨论相关的实现，其他的数据结构 &lt;code&gt;list, array&lt;/code&gt; 等有兴趣可以去看 &lt;code&gt;Boost&lt;/code&gt; 的实现。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tuple&lt;/code&gt; 定义为用括号包住的逗号分开的元素集合：&lt;code&gt;(a, b, c)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;``` cpp&lt;/p&gt;
&lt;h1&gt;define PP_TUPLE_REMOVE_PARENS(tuple) PP_REMOVE_PARENS(tuple)&lt;/h1&gt;
&lt;p&gt;// 获取指定下标的元素&lt;/p&gt;
&lt;h1&gt;define PP_TUPLE_ELEM(i, tuple) PP_ARGS_ELEM(i, PP_TUPLE_REMOVE_PARENS(tuple))&lt;/h1&gt;
&lt;p&gt;// 吞掉整个 tuple 返回空&lt;/p&gt;
&lt;h1&gt;define PP_TUPLE_EAT() PP_EMPTY_EAT&lt;/h1&gt;
&lt;p&gt;// 获取大小&lt;/p&gt;
&lt;h1&gt;define PP_TUPLE_SIZE(tuple) PP_ARGS_SIZE(PP_TUPLE_REMOVE_PARENS(tuple))&lt;/h1&gt;
&lt;p&gt;// 添加元素
#define PP_TUPLE_PUSH_BACK(elem, tuple) \
    PP_TUPLE_PUSH_BACK_IMPL(PP_TUPLE_SIZE(tuple), elem, tuple)
#define PP_TUPLE_PUSH_BACK_IMPL(size, elem, tuple) \
    (PP_TUPLE_REMOVE_PARENS(tuple) PP_IF(size, PP_COMMA, PP_EMPTY)() elem)&lt;/p&gt;
&lt;p&gt;// 插入元素
#define PP_TUPLE_INSERT(i, elem, tuple) \
    PP_TUPLE_ELEM( \
        3, \
        PP_AUTO_WHILE( \
            PP_TUPLE_INSERT_PRED, \
            PP_TUPLE_INSERT_OP, \
            (0, i, elem, (), tuple) \
        ) \
    )&lt;/p&gt;
&lt;h1&gt;define PP_TUPLE_INSERT_PRED(args) PP_TUPLE_INSERT_PERD_IMPL args&lt;/h1&gt;
&lt;p&gt;#define PP_TUPLE_INSERT_PERD_IMPL(curi, i, elem, ret, tuple) \
    PP_NOT_EQUAL(PP_TUPLE_SIZE(ret), PP_INC(PP_TUPLE_SIZE(tuple)))&lt;/p&gt;
&lt;h1&gt;define PP_TUPLE_INSERT_OP(args) PP_TUPLE_INSERT_OP_IMPL args&lt;/h1&gt;
&lt;p&gt;#define PP_TUPLE_INSERT_OP_IMPL(curi, i, elem, ret, tuple) \
    ( \
    PP_IF(PP_NOT_EQUAL(PP_TUPLE_SIZE(ret), i), PP_INC(curi), curi), \
    i, elem, \
    PP_TUPLE_PUSH_BACK(\
        PP_IF( \
            PP_NOT_EQUAL(PP_TUPLE_SIZE(ret), i), \
            PP_TUPLE_ELEM(curi, tuple), elem \
        ), \
        ret \
    ), \
    tuple \
    )&lt;/p&gt;
&lt;p&gt;// 删除末尾元素
#define PP_TUPLE_POP_BACK(tuple) \
    PP_TUPLE_ELEM( \
        1, \
        PP_AUTO_WHILE( \
            PP_TUPLE_POP_BACK_PRED, \
            PP_TUPLE_POP_BACK_OP, \
            (0, (), tuple) \
        ) \
    )&lt;/p&gt;
&lt;h1&gt;define PP_TUPLE_POP_BACK_PRED(args) PP_TUPLE_POP_BACK_PRED_IMPL args&lt;/h1&gt;
&lt;p&gt;#define PP_TUPLE_POP_BACK_PRED_IMPL(curi, ret, tuple) \
    PP_IF( \
        PP_TUPLE_SIZE(tuple), \
        PP_NOT_EQUAL(PP_TUPLE_SIZE(ret), PP_DEC(PP_TUPLE_SIZE(tuple))), \
        0 \
    )&lt;/p&gt;
&lt;h1&gt;define PP_TUPLE_POP_BACK_OP(args) PP_TUPLE_POP_BACK_OP_IMPL args&lt;/h1&gt;
&lt;p&gt;#define PP_TUPLE_POP_BACK_OP_IMPL(curi, ret, tuple) \
    (PP_INC(curi), PP_TUPLE_PUSH_BACK(PP_TUPLE_ELEM(curi, tuple), ret), tuple)&lt;/p&gt;
&lt;p&gt;// 删除元素
#define PP_TUPLE_REMOVE(i, tuple) \
    PP_TUPLE_ELEM( \
        2, \
        PP_AUTO_WHILE( \
            PP_TUPLE_REMOVE_PRED, \
            PP_TUPLE_REMOVE_OP, \
            (0, i, (), tuple) \
        ) \
    )&lt;/p&gt;
&lt;h1&gt;define PP_TUPLE_REMOVE_PRED(args) PP_TUPLE_REMOVE_PRED_IMPL args&lt;/h1&gt;
&lt;p&gt;#define PP_TUPLE_REMOVE_PRED_IMPL(curi, i, ret, tuple) \
    PP_IF( \
        PP_TUPLE_SIZE(tuple), \
        PP_NOT_EQUAL(PP_TUPLE_SIZE(ret), PP_DEC(PP_TUPLE_SIZE(tuple))), \
        0 \
    )&lt;/p&gt;
&lt;h1&gt;define PP_TUPLE_REMOVE_OP(args) PP_TUPLE_REMOVE_OP_IMPL args&lt;/h1&gt;
&lt;p&gt;#define PP_TUPLE_REMOVE_OP_IMPL(curi, i, ret, tuple) \
    ( \
    PP_INC(curi), \
    i, \
    PP_IF( \
        PP_NOT_EQUAL(curi, i), \
        PP_TUPLE_PUSH_BACK(PP_TUPLE_ELEM(curi, tuple), ret), \
        ret \
    ), \
    tuple \
    )&lt;/p&gt;
&lt;p&gt;PP_TUPLE_SIZE(())               // -&amp;gt; 0&lt;/p&gt;
&lt;p&gt;PP_TUPLE_PUSH_BACK(2, (1))      // -&amp;gt; (1, 2)
PP_TUPLE_PUSH_BACK(2, ())       // -&amp;gt; (2)&lt;/p&gt;
&lt;p&gt;PP_TUPLE_INSERT(1, 2, (1, 3))   // -&amp;gt; (1, 2, 3)&lt;/p&gt;
&lt;p&gt;PP_TUPLE_POP_BACK(())           // -&amp;gt; ()
PP_TUPLE_POP_BACK((1))          // -&amp;gt; ()
PP_TUPLE_POP_BACK((1, 2, 3))    // -&amp;gt; (1, 2)&lt;/p&gt;
&lt;p&gt;PP_TUPLE_REMOVE(1, (1, 2, 3))   // -&amp;gt; (1, 3)
PP_TUPLE_REMOVE(0, (1, 2, 3))   // -&amp;gt; (2, 3)
```&lt;/p&gt;
&lt;p&gt;这里稍微解释一下插入元素的实现，其他删除元素等操作也是通过类似的原理来实现的。&lt;code&gt;PP_TUPLE_INSERT(i, elem, tuple)&lt;/code&gt; 可以在 &lt;code&gt;tuple&lt;/code&gt; 的位置 &lt;code&gt;i&lt;/code&gt; 插入元素 &lt;code&gt;elem&lt;/code&gt;，为了完成这个操作，先把位置小于 &lt;code&gt;i&lt;/code&gt; 的元素都先用 &lt;code&gt;PP_TUPLE_PUSH_BACK&lt;/code&gt; 放到一个新的 &lt;code&gt;tuple&lt;/code&gt; 上（&lt;code&gt;ret&lt;/code&gt;），然后在位置 &lt;code&gt;i&lt;/code&gt; 放入元素 &lt;code&gt;elem&lt;/code&gt;，之后再把原 &lt;code&gt;tuple&lt;/code&gt; 位置大于等于 &lt;code&gt;i&lt;/code&gt; 的元素放到 &lt;code&gt;ret&lt;/code&gt; 后面，最后 &lt;code&gt;ret&lt;/code&gt; 就得到我们想要的结果。&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;本文的目的是想要阐述清楚 C/C++ 宏编程的原理和基本实现，在记录我本人的一些理解和认识的同时，希望能够对其他人能带来一些解惑和启发。需要注意的是，尽管本文篇幅有点长，但还是有一些关于宏编程的技巧和用法是没有涉及到的，譬如 CHAOS_PP 提出的&lt;a href=&#34;https://github.com/pfultz2/Cloak/wiki/C-Preprocessor-tricks,-tips,-and-idioms#deferred-expression&#34;&gt;基于延迟展开的递归调用方法&lt;/a&gt;，BOOST_PP 里面的 &lt;code&gt;REPEAT&lt;/code&gt; 相关宏等等，有兴趣的可以自行查阅资料。&lt;/p&gt;
&lt;p&gt;宏编程的调试是一个痛苦的过程，我们可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用 &lt;code&gt;-P -E&lt;/code&gt; 选项输出预处理结果；&lt;/li&gt;
&lt;li&gt;用前面提到的我自己修改的 &lt;code&gt;clang&lt;/code&gt; 版本仔细研究展开过程；&lt;/li&gt;
&lt;li&gt;把复杂的宏拆解，查看中间宏的展开结果；&lt;/li&gt;
&lt;li&gt;屏蔽无关的头文件和宏；&lt;/li&gt;
&lt;li&gt;最后就是要脑补宏展开的过程了，熟悉宏展开之后调试的效率也会提升。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文中的宏是我自己在理解了原理之后重新实现出来的，有部分宏借鉴了 &lt;code&gt;Boost&lt;/code&gt; 的实现和引用里面的文章，有任何错误之处，欢迎随时指正，也欢迎找我来讨论相关的问题。&lt;/p&gt;
&lt;p&gt;本文的代码全部都在这里：&lt;a href=&#34;assets/img/2021-3-31-cpp-preprocess/macros.cpp&#34;&gt;下载&lt;/a&gt;，&lt;a href=&#34;https://godbolt.org/z/coWvc5Pse&#34;&gt;在线演示&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;引用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.boost.org/doc/libs/1_75_0/libs/preprocessor/doc/&#34;&gt;Boost.Preprocessor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bot-man-jl.github.io/articles/?post=2020/Macro-Programming-Art&#34;&gt;C/C++ 宏编程的艺术&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/cpp-C%E5%92%8CCpp%E5%AE%8F%E7%BC%96%E7%A8%8B%E8%A7%A3%E6%9E%90/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Sun, 14 Apr 2024 16:51:54 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/cpp-C%E5%92%8CCpp%E5%AE%8F%E7%BC%96%E7%A8%8B%E8%A7%A3%E6%9E%90/</guid>
      
    </item>
    
    <item>
      <title>UE 通过插件源码添加插件</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;UE 通过插件源码添加插件&#34; /&gt;&lt;/p&gt;
&lt;h1&gt;UE 通过插件源码添加插件&lt;/h1&gt;
&lt;h1&gt;添加插件&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;简单记录一下如何在拥有插件源码的情况下添加插件.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以插件 &lt;a href=&#34;https://github.com/disenone/UE.EditorPlus&#34;&gt;UE.EditorPlus&lt;/a&gt; 为例&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把源码放到 Plugins 目录下&lt;/li&gt;
&lt;li&gt;（这一步可以不执行）修改项目 .uproject 文件，Plugins 字段下增加：
    &lt;code&gt;json
        &#34;Plugins&#34;: [
        {
            &#34;Name&#34;: &#34;EditorPlus&#34;,
            &#34;Enabled&#34;: true,
            &#34;TargetAllowList&#34;: [
                &#34;Editor&#34;
            ]
        }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;右键 uproject 文件，执行 &#34;Generate Visual Studio Project Files&#34;，更新 sln 项目文件&lt;/li&gt;
&lt;li&gt;打开 sln 文件，编译项目&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;设置多语言&lt;/h1&gt;
&lt;p&gt;修改项目的配置文件 &lt;code&gt;DefaultEditor.ini&lt;/code&gt;，加上新路径：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ini
[Internationalization]
+LocalizationPaths=%GAMEDIR%Plugins/UE.EditorPlus/Content/Localization/EditorPlusTools&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/ue-%E9%80%9A%E8%BF%87%E6%8F%92%E4%BB%B6%E6%BA%90%E7%A0%81%E6%B7%BB%E5%8A%A0%E6%8F%92%E4%BB%B6/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Sat, 13 Jan 2024 03:55:10 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/ue-%E9%80%9A%E8%BF%87%E6%8F%92%E4%BB%B6%E6%BA%90%E7%A0%81%E6%B7%BB%E5%8A%A0%E6%8F%92%E4%BB%B6/</guid>
      
    </item>
    
    <item>
      <title>Python 杂谈 2 - Python3.12 热更新</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;Python 杂谈 2 - Python3.12 热更新&#34; /&gt;&lt;/p&gt;
&lt;h1&gt;Python 杂谈 2 - Python3.12 热更新&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;记录如何在 Python3.12 中实现热更新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;热更新&lt;/h2&gt;
&lt;p&gt;热更新（Hot Reload）可以理解在不需要重启程序的情况下对其进行更新的技术。这项技术在游戏行业有广泛的应用，开发者对游戏问题进行修复的时候，为了不对玩家造成影响，往往需要采用一些静默更新的方式，也就是热更新。&lt;/p&gt;
&lt;h2&gt;Python 热更新&lt;/h2&gt;
&lt;p&gt;Python 本身是动态语言，一切皆是对象，是有能力做到热更新的。我们可以粗略把 Python 中的需要热更的对象分成两种：数据 和 函数。&lt;/p&gt;
&lt;p&gt;数据，可以理解成游戏中的数值或者设定，譬如玩家的等级，装备等等一些数据，部分数据是不应该热更的（譬如玩家当前等级，玩家身上拥有哪些装备，这些数据的修改不应该通过热更来实现），部分数据是我们想要热更的（譬如装备的基础数值设定，技能的基础数值设定，UI 上的文字等等）。&lt;/p&gt;
&lt;p&gt;函数，可以理解成游戏逻辑，这基本都是我们想要热更的，逻辑错误基本都需要通过热更新函数来实现。&lt;/p&gt;
&lt;p&gt;下面我们来具体看看有什么方法可以对 Python3.12 执行热更新。&lt;/p&gt;
&lt;h2&gt;Hotfix&lt;/h2&gt;
&lt;p&gt;第一种方法我们叫做 Hotfix，通过让程序（客户端程序 / 服务端程序都可以）执行一段特定的 Python 代码，实现对数据和函数的热更新。一段简单的 Hotfix 代码可能是这样：&lt;/p&gt;
&lt;p&gt;```python&lt;/p&gt;
&lt;h1&gt;hotfix code&lt;/h1&gt;
&lt;h1&gt;hotfix data&lt;/h1&gt;
&lt;p&gt;import weapon_data
weapon_data.gun.damage = 100&lt;/p&gt;
&lt;h1&gt;hotfix func&lt;/h1&gt;
&lt;p&gt;import player
def new_fire_func(self, target):
    target.health -= weapon_data.gun.damage
    # ...
player.Player.fire_func = new_fire_func
```&lt;/p&gt;
&lt;p&gt;以上代码简单展示 Hotfix 的写法，数据 / 函数修改之后，程序后续访问的时候就会读到新的数据 / 函数来执行。&lt;/p&gt;
&lt;p&gt;如果你比较细致，你可能会有一个疑问：那如果其他代码里面引用住了这些需要修改数据和函数，会发生什么事情？&lt;/p&gt;
&lt;p&gt;```python&lt;/p&gt;
&lt;h1&gt;attack.py module&lt;/h1&gt;
&lt;p&gt;player_fire = player.Player.fire_func&lt;/p&gt;
&lt;p&gt;def player_attack_by_gun(player, target):
    player_fire(player, target)
    # ...
```&lt;/p&gt;
&lt;p&gt;答案是，前面的 Hotfix 对这种情况是不生效的，&lt;code&gt;fire_func&lt;/code&gt; 这个函数相当于在其他模块多了一份副本，该模块中调用的是函数的副本，我们修改函数本体对副本不生效。&lt;/p&gt;
&lt;p&gt;所以需要注意，一般代码中尽量减少模块级别的数据引用和函数引用，避免出现这种 Hotfix 不生效的情况，如果代码已经是这样写的，Hotfix 需要多做一些工作：&lt;/p&gt;
&lt;p&gt;```python&lt;/p&gt;
&lt;h1&gt;hotfix code&lt;/h1&gt;
&lt;h1&gt;...&lt;/h1&gt;
&lt;p&gt;import attack
attack.player_fire = player.Player.fire_func&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;在对数据 / 函数本体 Hotfix 修改之后，再额外对引用的地方进行修改。这些额外的修改很容易被遗漏，所以我们还是建议，从代码规范上来尽量避免多处引用的写法。&lt;/p&gt;
&lt;p&gt;综上，Hotfix 能满足热更的基本需求，同时存在以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果数据/函数被其他模块明确引用住，需要额外对这些模块的引用 Hotfix&lt;/li&gt;
&lt;li&gt;如果有大量的数据/函数需要 Hotfix，那么 Hotfix 的代码会变得很庞大，维护难度上升，也更容易出错&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Reload&lt;/h2&gt;
&lt;p&gt;本章节源码可从这里获得：&lt;a href=&#34;https://github.com/disenone/python_reloader&#34;&gt;python_reloader&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们更想要的是自动热更新，不需要额外写 Hotfix，只需要更新代码文件，让程序执行一个 Reload 函数则会自动替换新的函数和新的数据。我们把这个自动热更新的功能叫做 Reload。&lt;/p&gt;
&lt;p&gt;Python3.12 提供了 importlib.reload 函数，可以重新加载模块，但是却是全量加载，并且返回新的模块对象，对于其他模块中的引用，并不能自动修改，也就是其他模块如果 import 了 reload 的模块，那么访问的依然是旧的模块对象。这个功能比我们的 Hotfix 好不了多少，更何况是全量 reload 模块，不能由我们控制哪些数据应该保留。我们想要自己实现一个 Reload 功能，满足这些要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动替换函数，同时旧函数的引用依然有效，并会执行新函数的内容&lt;/li&gt;
&lt;li&gt;自动替换数据，同时可控制部分替换&lt;/li&gt;
&lt;li&gt;保留旧模块的引用，通过旧模块就能访问到新的内容&lt;/li&gt;
&lt;li&gt;需要 Reload 的模块可控&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要完成这些要求，我们需要借助 Python 里面 meta_path 的机制，详细的介绍可以看官方文档 &lt;a href=&#34;https://docs.python.org/zh-cn/3/reference/import.html?highlight=meta_path#the-meta-path&#34;&gt;the-meta-path&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;sys.meta_path 里面可以定义我们的元路径查找器对象，譬如我们把用于 Reload 的查找器叫做 reload_finder，reload_finder 需要实现一个函数 find_spec 并返回 spec 对象。Python 拿到 spec 对象后，会依次执行 spec.loader.create_module 和 spec.loader.exec_module 完成模块的导入。&lt;/p&gt;
&lt;p&gt;如果我们在这个过程中，执行新的模块代码，并把新的模块里面的函数和需要的数据复制到旧模块中，则可以达到 Reload 的目的：&lt;/p&gt;
&lt;p&gt;```python linenums=&#34;1&#34;
class MetaFinder:
    def &lt;strong&gt;init&lt;/strong&gt;(self, reloader):
        self._reloader = reloader&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def find_spec(self, fullname, path, target=None):
    # find source file
    finder = importlib.machinery.PathFinder()
    spec = finder.find_spec(fullname, path)
    if not spec:
        return

    old_module = self._reloader.GetOldModule(fullname)
    if old_module:
        # run new code in old module dict
        code = spec.loader.get_code(fullname)
        exec(code, old_module.__dict__)
        module = old_module
    else:
        # if old module not exists, just create a new one
        module = import_util.module_from_spec(spec)
        spec.loader.exec_module(module)

    try:
        self._reloader.ReloadModule(module)
    except:
        sys.excepthook(*sys.exc_info())

    return import_util.spec_from_loader(fullname, MetaLoader(module))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;class MetaLoader:
    def &lt;strong&gt;init&lt;/strong&gt;(self, module):
        self._module = module&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def create_module(self, spec):
    return self._module

def exec_module(self, module):
    # restore __spec__
    module.__spec__ = module.__dict__.pop(&#39;__backup_spec__&#39;)
    module.__loader__ = module.__dict__.pop(&#39;__backup_loader__&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;如上，&lt;code&gt;find_spec&lt;/code&gt; 加载最新的模块源码，并在旧模块的 &lt;code&gt;__dict__&lt;/code&gt; 里面执行新模块的代码，之后我们调用 &lt;code&gt;ReloadModule&lt;/code&gt; 来处理类 / 函数 / 数据的引用和替换。&lt;code&gt;MetaLoader&lt;/code&gt; 的目的是适配 meta_path 机制，给 Python 虚拟机返回我们处理过的模块对象。&lt;/p&gt;
&lt;p&gt;处理完加载的流程，再来看 &lt;code&gt;ReloadModule&lt;/code&gt; 的大致实现&lt;/p&gt;
&lt;p&gt;```python linenums=&#34;1&#34;&lt;/p&gt;
&lt;h1&gt;...&lt;/h1&gt;
&lt;p&gt;def ReloadModule(self, module):
    old_module_info = self._old_module_infos.get(module.&lt;strong&gt;name&lt;/strong&gt;)
    if not old_module_info:
        return&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;self.ReloadDict(module, old_module_info, module.__dict__)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;def ReloadDict(self, module, old_dict, new_dict, _reload_all_data=False, _del_func=False):
    dels = []&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for attr_name, old_attr in old_dict.items():

    if attr_name in self.IGNORE_ATTRS:
        continue

    if attr_name not in new_dict:
        if _del_func and (inspect.isfunction(old_attr) or inspect.ismethod(old_attr)):
            dels.append(attr_name)
        continue

    new_attr = new_dict[attr_name]

    if inspect.isclass(old_attr):
        new_dict[attr_name] = self.ReloadClass(module, old_attr, new_attr)

    elif inspect.isfunction(old_attr):
        new_dict[attr_name] = self.ReloadFunction(module, old_attr, new_attr)

    elif inspect.ismethod(old_attr) or isinstance(old_attr, classmethod) or isinstance(old_attr, staticmethod):
        self.ReloadFunction(module, old_attr.__func__, new_attr.__func__)
        new_dict[attr_name] = old_attr

    elif inspect.isbuiltin(old_attr) \
            or inspect.ismodule(old_attr) \
            or inspect.ismethoddescriptor(old_attr) \
            or isinstance(old_attr, property):
        # keep new
        pass

    elif not _reload_all_data and not self.NeedUpdateData(module, new_dict, attr_name):
        # keep old data
        new_dict[attr_name] = old_attr

if dels:
    for name in dels:
        old_dict.pop(name)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;...&lt;/h1&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ReloadDict&lt;/code&gt; 里面会区分处理不同类型的对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是 class，则调用 &lt;code&gt;ReloadClass&lt;/code&gt;，会返回旧模块的引用，并更新 class 的成员&lt;/li&gt;
&lt;li&gt;如果是 function / method ，则调用 &lt;code&gt;ReloadFunction&lt;/code&gt;，会返回旧模块的引用，并更新函数的内部数据&lt;/li&gt;
&lt;li&gt;如果是数据，并且需要保留，则会回滚 &lt;code&gt;new_dict[attr_name] = old_attr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其余的都保持新的引用&lt;/li&gt;
&lt;li&gt;删除新模块不存在的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;ReloadClass&lt;/code&gt;，&lt;code&gt;ReloadFunction&lt;/code&gt; 的具体代码这里不再展开分析，有兴趣可以直接看&lt;a href=&#34;https://github.com/disenone/python_reloader&#34;&gt;源码&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;整个 Reload 的过程，可以概括为：旧瓶装新酒。为了保持模块/模块的函数/模块的类/模块的数据有效，我们需要保留原来的这些对象的引用（躯壳），转而去更新它们内部的具体数据，譬如对于函数，更新 &lt;code&gt;__code__&lt;/code&gt;，&lt;code&gt;__dict__&lt;/code&gt; 等数据，函数执行的时候，就会转而执行新的代码。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本文详细介绍了 Python3 的两种热更新方式，每种都有相应的应用场景，希望能对你有帮助。有任何疑问欢迎随时交流。&lt;/p&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/py-Python%E6%9D%82%E8%B0%882-Python312-%E7%83%AD%E6%9B%B4%E6%96%B0/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Fri, 12 Jan 2024 08:16:26 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/py-Python%E6%9D%82%E8%B0%882-Python312-%E7%83%AD%E6%9B%B4%E6%96%B0/</guid>
      
    </item>
    
    <item>
      <title>Python 杂谈 1 - 探究 __builtins__</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;Python 杂谈 1 - 探究 __builtins__ - Disenone&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;引子&lt;/h2&gt;
&lt;p&gt;我们知道，&lt;code&gt;__builtins__&lt;/code&gt; 本身是在全局命名空间中就有的一个对象，是 &lt;code&gt;Python&lt;/code&gt; 故意暴露出来给代码层的，在代码的任意地方都可以直接使用。但是有点冷的知识是，&lt;code&gt;__builtins__&lt;/code&gt; 在 &lt;code&gt;main&lt;/code&gt; 模块（也就是 &lt;code&gt;__main__&lt;/code&gt;，指的都是同一个模块，后文可能会混用）里面是 &lt;code&gt;__builtin__&lt;/code&gt; 这个模块，但在其他模块里面，它表示的是 &lt;code&gt;__builtin__.__dict__&lt;/code&gt;，这就有点让人莫名其妙了。虽然官方不推荐直接使用 &lt;code&gt;__builtins__&lt;/code&gt;，但你给我搞两种情况是怎么回事？本文我们就来盘一盘这个设定的由来，在这个过程中，我们还可以找到这些问题的答案：&lt;code&gt;__builtin__&lt;/code&gt; 跟 &lt;code&gt;__builtins__&lt;/code&gt; 有什么区别？&lt;code&gt;__builtins__&lt;/code&gt; 在 &lt;code&gt;main&lt;/code&gt; 模块跟其他模块为什么会设定成不同？&lt;code&gt;__builtins__&lt;/code&gt; 是在哪里定义的？&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;__builtin__&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在探讨 &lt;code&gt;__builtins__&lt;/code&gt; 之前，我们需要先看看 &lt;code&gt;__builtin__&lt;/code&gt; 是什么。&lt;code&gt;__builtin__&lt;/code&gt; 是存放所有内建对象的模块，我们平常可以直接使用的 &lt;code&gt;Python&lt;/code&gt; 内建对象，本质上都是 &lt;code&gt;__builtin__&lt;/code&gt; 模块里的对象，即放在 &lt;code&gt;__builtin__.__dict__&lt;/code&gt; 里，对应着的是 &lt;code&gt;Python&lt;/code&gt; 的内建名字空间。记住这个关键知识点：&lt;code&gt;__buintin__&lt;/code&gt; 是一个模块 &lt;code&gt;module&lt;/code&gt;。我们可以在 &lt;code&gt;Python&lt;/code&gt; 源码中找到 &lt;code&gt;__builtin__&lt;/code&gt; 模块的定义和使用（注意，下文提到的 &lt;code&gt;Python&lt;/code&gt; 源码，都是指 CPython-2.7.18 源码）：&lt;/p&gt;
&lt;p&gt;``` c
// pythonrun.c
void
Py_InitializeEx(int install_sigs)
{
    PyInterpreterState *interp;
    ...
    // 初始化 &lt;strong&gt;builtin&lt;/strong&gt;
    bimod = _PyBuiltin_Init();
    // interp-&amp;gt;builtins = &lt;strong&gt;builtin&lt;/strong&gt;.&lt;strong&gt;dict&lt;/strong&gt;
    interp-&amp;gt;builtins = PyModule_GetDict(bimod);
    ...
}&lt;/p&gt;
&lt;p&gt;// bltinmodule.c
PyObject *
_PyBuiltin_Init(void)
{
    PyObject &lt;em&gt;mod, &lt;/em&gt;dict, &lt;em&gt;debug;
    mod = Py_InitModule4(&#34;&lt;strong&gt;builtin&lt;/strong&gt;&#34;, builtin_methods,
                         builtin_doc, (PyObject &lt;/em&gt;)NULL,
                         PYTHON_API_VERSION);
    if (mod == NULL)
        return NULL;
    dict = PyModule_GetDict(mod);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 给 dict 加上内建的对象
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;// ceval.c
// 获取 builtins
PyObject *
PyEval_GetBuiltins(void)
{
    PyFrameObject *current_frame = PyEval_GetFrame();
    if (current_frame == NULL)
        return PyThreadState_GET()-&amp;gt;interp-&amp;gt;builtins;
    else
        return current_frame-&amp;gt;f_builtins;
}
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Python&lt;/code&gt; 初始化的时候会调用 &lt;code&gt;_PyBuiltin_Init&lt;/code&gt; 来创建 &lt;code&gt;__builtin__&lt;/code&gt; 模块，并在里面添加上内建的对象，解释器本身会引用住 &lt;code&gt;interp-&amp;gt;builtins = __buintin__.__dict__&lt;/code&gt;，当前执行的栈帧结构同时也会引用一份 &lt;code&gt;current_frame-&amp;gt;f_builtins&lt;/code&gt;。那么很自然地，当执行代码需要根据名字寻找对象的时候，&lt;code&gt;Python&lt;/code&gt; 会去 &lt;code&gt;current_frame-&amp;gt;f_builtins&lt;/code&gt; 里面来找，自然就能拿到所有的内建对象：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c
// ceval.c
TARGET(LOAD_NAME)
{
    // 先在 f-&amp;gt;f_locals 名字空间里面找
    ...
    if (x == NULL) {
        // 再找找全局空间
        x = PyDict_GetItem(f-&amp;gt;f_globals, w);
        if (x == NULL) {
            // 这里就去内建空间找
            x = PyDict_GetItem(f-&amp;gt;f_builtins, w);
            if (x == NULL) {
                format_exc_check_arg(
                            PyExc_NameError,
                            NAME_ERROR_MSG, w);
                break;
            }
        }
        Py_INCREF(x);
    }
    PUSH(x);
    DISPATCH();
}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后，由于 &lt;code&gt;__builtin__&lt;/code&gt; 这个名字实在是太有迷惑性了，&lt;code&gt;Python3&lt;/code&gt; 中已经改名为 &lt;code&gt;builtins&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;__builtins__&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;__builtins__&lt;/code&gt; 的表现是有点奇怪的：
* 在 &lt;code&gt;main&lt;/code&gt; 模块中（&lt;code&gt;main&lt;/code&gt; 模块，或者叫&lt;code&gt;最高层级代码运行所在环境&lt;/code&gt;，是用户指定最先启动运行的 &lt;code&gt;Python&lt;/code&gt; 模块，也就是通常我们在命令行执行 &lt;code&gt;python xxx.py&lt;/code&gt; 时，&lt;code&gt;xxx.py&lt;/code&gt; 这个模块），&lt;code&gt;__builtins__ = __builtin__&lt;/code&gt;；
* 在其他模块中 &lt;code&gt;__builtins__ = __builtin__.__dict__&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;相同的名字，但在不同的模块下表现却是不相同的，这样的设定很容易让人疑惑。不过只要知道这个设定，就足够支持你在 &lt;code&gt;Python&lt;/code&gt; 中使用 &lt;code&gt;__builtins__&lt;/code&gt;，疑惑并不会影响你写出足够安全的代码，诸如：&lt;/p&gt;
&lt;p&gt;``` python
def SetBuiltins(builtins, key, val):
    if isinstance(builtins, dict):
        builtins[key] = val
    else:
        setattr(builtins, key, val)&lt;/p&gt;
&lt;p&gt;SetBuiltins(&lt;strong&gt;builtins&lt;/strong&gt;, &#39;test&#39;, 1)
```&lt;/p&gt;
&lt;p&gt;需要注意，其实并不建议使用 &lt;code&gt;__builtins__&lt;/code&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;CPython implementation detail&lt;/strong&gt;: Users should not touch &lt;code&gt;__builtins__&lt;/code&gt;; it is strictly an implementation detail. Users wanting to override values in the builtins namespace should import the &lt;code&gt;__builtin__&lt;/code&gt; (no ‘s’) module and modify its attributes appropriately.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，这样的疑惑，总有一天会让你心痒难耐，我这里就决定继续探究下去，也因为这样，才有了这篇文章。我们下面的内容会深入到 &lt;strong&gt;CPython implementation detail&lt;/strong&gt; 中去。&lt;/p&gt;
&lt;h2&gt;Restricted Execution&lt;/h2&gt;
&lt;p&gt;Restricted Execution 可以理解为有限制地执行不安全的代码，所谓有限制，可以是限制网络、io 等等，把代码限制在一定的执行环境中，控制代码的执行权限，防止代码影响到外部的环境和系统。常见的用例就是一些在线代码执行网站，譬如这个：&lt;a href=&#34;https://pythonsandbox.dev/&#34;&gt;pythonsandbox&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;跟你猜想的一样，&lt;code&gt;Python&lt;/code&gt; 对 &lt;code&gt;__builtins__&lt;/code&gt; 的设定是跟 Restricted Execution 有关。&lt;code&gt;Python&lt;/code&gt; 在 2.3 版本之前，曾经提供过类似的功能 &lt;a href=&#34;https://docs.python.org/2.7/library/restricted.html&#34;&gt;Restricted Execution&lt;/a&gt;，只是由于后来被证实为不可行的，只好把这个功能作废了，但代码在 2.7.18 版本还保留着，所以我们可以来考古。&lt;/p&gt;
&lt;p&gt;首先来看 &lt;code&gt;Python&lt;/code&gt; 源码里面对 &lt;code&gt;__builtins__&lt;/code&gt; 的设置：&lt;/p&gt;
&lt;p&gt;``` c
// pythonrun.c
static void initmain(void)
{
    PyObject &lt;em&gt;m, &lt;/em&gt;d;
    // 获取 &lt;strong&gt;main&lt;/strong&gt; 模块
    m = PyImport_AddModule(&#34;&lt;strong&gt;main&lt;/strong&gt;&#34;);
    if (m == NULL)
        Py_FatalError(&#34;can&#39;t create &lt;strong&gt;main&lt;/strong&gt; module&#34;);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// d = __main__.__dict__
d = PyModule_GetDict(m);

// 设置 __main__.__dict__[&#39;__builtins__&#39;]，如果已有，则跳过
if (PyDict_GetItemString(d, &#34;__builtins__&#34;) == NULL) {
    PyObject *bimod = PyImport_ImportModule(&#34;__builtin__&#34;);
    if (bimod == NULL ||
        PyDict_SetItemString(d, &#34;__builtins__&#34;, bimod) != 0)
        Py_FatalError(&#34;can&#39;t add __builtins__ to __main__&#34;);
    Py_XDECREF(bimod);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;initmain&lt;/code&gt; 中，&lt;code&gt;Python&lt;/code&gt; 会给 &lt;code&gt;__main__&lt;/code&gt; 模块设置 &lt;code&gt;__builtins__&lt;/code&gt; 属性，默认等于 &lt;code&gt;__builtin__&lt;/code&gt; 模块，但如果已有，则跳过不会重新设置。利用这个特点，我们就可以通过修改 &lt;code&gt;__main__.__builtins__&lt;/code&gt; 来修改内建的一些功能，以达到限制代码执行权限的目的，具体的方法先按下不表，我们看看 &lt;code&gt;__builtins__&lt;/code&gt; 是怎么被传递的。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;__builtins__&lt;/code&gt; 的传递&lt;/h2&gt;
&lt;p&gt;在创建新的栈帧的时候：&lt;/p&gt;
&lt;p&gt;```c
PyFrameObject *
PyFrame_New(PyThreadState &lt;em&gt;tstate, PyCodeObject &lt;/em&gt;code, PyObject &lt;em&gt;globals,
            PyObject &lt;/em&gt;locals)
{
    ...
    if (back == NULL || back-&amp;gt;f_globals != globals) {
        // 取 globals[&#39;&lt;strong&gt;builtins&lt;/strong&gt;&#39;] 作为新栈帧的 &lt;strong&gt;builtins&lt;/strong&gt;
        // builtin_object 就是字符串 &#39;&lt;strong&gt;builtins&lt;/strong&gt;&#39;
        builtins = PyDict_GetItem(globals, builtin_object);
        if (builtins) {
            if (PyModule_Check(builtins)) {
                builtins = PyModule_GetDict(builtins);
                assert(!builtins || PyDict_Check(builtins));
            }
            else if (!PyDict_Check(builtins))
                builtins = NULL;
        }
        ...&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;}
else {
    /* If we share the globals, we share the builtins.
       Save a lookup and a call. */
    // 或者直接继承上一层栈帧的 f_builtins
    builtins = back-&amp;gt;f_builtins;
    assert(builtins != NULL &amp;amp;&amp;amp; PyDict_Check(builtins));
    Py_INCREF(builtins);
}
...
f-&amp;gt;f_builtins = builtins;
f-&amp;gt;f_globals = globals;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;创建新的栈帧时，对于 &lt;code&gt;__builtins__&lt;/code&gt; 的处理主要有两种情况：一种是没有上层栈帧的情况下，取 &lt;code&gt;globals[&#39;__builtins__&#39;]&lt;/code&gt;；另一种是直接取上层栈帧的 &lt;code&gt;f_builtins&lt;/code&gt;。联合起来看的话，可以理解为，一般情况下，在 &lt;code&gt;__main__&lt;/code&gt; 中设置好的 &lt;code&gt;__builtins__&lt;/code&gt;，会一直继承给后面的栈帧，相当于共用同一份。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt; 模块时：&lt;/p&gt;
&lt;p&gt;```c
static PyObject *
load_compiled_module(char &lt;em&gt;name, char &lt;/em&gt;cpathname, FILE &lt;em&gt;fp)
{
    long magic;
    PyCodeObject &lt;/em&gt;co;
    PyObject &lt;em&gt;m;
    ...
    co = read_compiled_module(cpathname, fp);
    ...
    m = PyImport_ExecCodeModuleEx(name, (PyObject &lt;/em&gt;)co, cpathname);
    ...
}&lt;/p&gt;
&lt;p&gt;PyObject *
PyImport_ExecCodeModuleEx(char &lt;em&gt;name, PyObject &lt;/em&gt;co, char *pathname)
{
    ...
    m = PyImport_AddModule(name);
    ...
    // d = m.&lt;strong&gt;dict&lt;/strong&gt;
    d = PyModule_GetDict(m);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 在这里设置新加载模块的 __builtins__ 属性
if (PyDict_GetItemString(d, &#34;__builtins__&#34;) == NULL) {
    if (PyDict_SetItemString(d, &#34;__builtins__&#34;,
                             PyEval_GetBuiltins()) != 0)
        goto error;
}
...
// globals = d, locals = d
v = PyEval_EvalCode((PyCodeObject *)co, d, d);
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;PyObject *
PyEval_EvalCode(PyCodeObject &lt;em&gt;co, PyObject &lt;/em&gt;globals, PyObject &lt;em&gt;locals)
{
    return PyEval_EvalCodeEx(co,
                      globals, locals,
                      (PyObject &lt;/em&gt;&lt;em&gt;)NULL, 0,
                      (PyObject &lt;/em&gt;&lt;em&gt;)NULL, 0,
                      (PyObject &lt;/em&gt;*)NULL, 0,
                      NULL);
}
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt; 其他模块的时候，会把该模块的 &lt;code&gt;__builtins__&lt;/code&gt; 设置为 &lt;code&gt;PyEval_GetBuiltins()&lt;/code&gt; 的返回结果，这个函数我们已经说过，大部分情况下相当于 &lt;code&gt;current_frame-&amp;gt;f_builtins&lt;/code&gt;。对于 &lt;code&gt;__main__&lt;/code&gt; 模块的里面的 &lt;code&gt;import&lt;/code&gt;，&lt;code&gt;current_frame&lt;/code&gt; 就是 &lt;code&gt;__main__&lt;/code&gt; 模块的栈帧，&lt;code&gt;current_frame-&amp;gt;f_builtins = __main__.__dict__[&#39;__builtins__&#39;]&lt;/code&gt;（上文 &lt;code&gt;PyFrame_New&lt;/code&gt; 的第一种情况）。&lt;/p&gt;
&lt;p&gt;加载的新模块，会使用 &lt;code&gt;PyEval_EvalCode&lt;/code&gt; 来执行新模块中的代码，可以看到，传给 &lt;code&gt;PyEval_EvalCode&lt;/code&gt; 的参数 &lt;code&gt;globals&lt;/code&gt;、&lt;code&gt;locals&lt;/code&gt; 其实都是模块自身的 &lt;code&gt;__dict__&lt;/code&gt;，并且模块 &lt;code&gt;m.__dict__[&#39;__builtins__&#39;] = PyEval_GetBuiltins()&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;综合来看，我们可以得知，从 &lt;code&gt;__main__&lt;/code&gt; 模块开始 &lt;code&gt;import&lt;/code&gt; 的模块，也会继承 &lt;code&gt;__main__&lt;/code&gt; 中的 &lt;code&gt;__builtins__&lt;/code&gt;，并会在内部的 &lt;code&gt;import&lt;/code&gt; 中传递下去，这样就可以确保，所有从 &lt;code&gt;__main__&lt;/code&gt; 加载的模块和子模块，都能共用同一份来自 &lt;code&gt;__main__&lt;/code&gt; 的 &lt;code&gt;__builtins__&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;那么如果是在模块中调用的函数呢？对于模块中的函数，创建和调用时：&lt;/p&gt;
&lt;p&gt;```c
// ceval.c
// 创建函数
TARGET(MAKE_FUNCTION)
{
    v = POP(); /&lt;em&gt; code object &lt;/em&gt;/&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 这里的 f-&amp;gt;f_globals，相当于模块自身的 globals，由上文可知，也相当于 m.__dict__
x = PyFunction_New(v, f-&amp;gt;f_globals);
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;PyObject *
PyFunction_New(PyObject &lt;em&gt;code, PyObject &lt;/em&gt;globals)
{
    PyFunctionObject *op = PyObject_GC_New(PyFunctionObject,
                                        &amp;amp;PyFunction_Type);
    ...
    // 这里相当于 op-&amp;gt;func_globals = globals = f-&amp;gt;f_globals
    op-&amp;gt;func_globals = globals;
}&lt;/p&gt;
&lt;p&gt;// 调用函数
static PyObject *
fast_function(PyObject &lt;em&gt;func, PyObject &lt;/em&gt;&lt;em&gt;&lt;em&gt;pp_stack, int n, int na, int nk)
{
    PyCodeObject &lt;/em&gt;co = (PyCodeObject &lt;/em&gt;)PyFunction_GET_CODE(func);
    // globals = func-&amp;gt;func_globals
    PyObject &lt;em&gt;globals = PyFunction_GET_GLOBALS(func);
    ...
    // globals 传给 PyEval_EvalCodeEx，里面就会传给 PyFrame_New 来创建新的栈帧
    return PyEval_EvalCodeEx(co, globals,
                             (PyObject &lt;/em&gt;)NULL, (&lt;em&gt;pp_stack)-n, na,
                             (&lt;/em&gt;pp_stack)-2*nk, nk, d, nd,
                             PyFunction_GET_CLOSURE(func));
}
```&lt;/p&gt;
&lt;p&gt;创建函数时，会把 &lt;code&gt;f-&amp;gt;f_globals&lt;/code&gt; 存到函数结构体变量 &lt;code&gt;func_globals&lt;/code&gt; 里面，而对于模块 &lt;code&gt;m&lt;/code&gt;，&lt;code&gt;f-&amp;gt;f_globals = m.__dict__&lt;/code&gt;。函数执行的时候，传给 &lt;code&gt;PyFrame_New&lt;/code&gt; 的 &lt;code&gt;globals&lt;/code&gt; 参数，就是创建时候保存起来的 &lt;code&gt;func_globals&lt;/code&gt;，&lt;code&gt;__builtins__&lt;/code&gt; 自然就可以在 &lt;code&gt;func_globals&lt;/code&gt; 中获取。&lt;/p&gt;
&lt;p&gt;至此，&lt;code&gt;__builtins__&lt;/code&gt; 的传递是能保证一致性的，所有模块、子模块 、函数，栈帧等都能引用到同一个，也就是拥有相同的内建名字空间。&lt;/p&gt;
&lt;h2&gt;指定 &lt;code&gt;__main__&lt;/code&gt; 模块执行&lt;/h2&gt;
&lt;p&gt;我们已经知道 &lt;code&gt;__main__&lt;/code&gt; 模块自身的 &lt;code&gt;__builtins__&lt;/code&gt; 可以传递给所有子模块、函数和栈帧，而在命令行执行 &lt;code&gt;python a.py&lt;/code&gt; 时，Python 会把 &lt;code&gt;a.py&lt;/code&gt; 作为 &lt;code&gt;__main__&lt;/code&gt; 模块来执行，那这是如何做到的呢：&lt;/p&gt;
&lt;p&gt;```c
// python.c
int
main(int argc, char **argv)
{
    ...
    return Py_Main(argc, argv);
}&lt;/p&gt;
&lt;p&gt;// main.c
int
Py_Main(int argc, char **argv)
{
    ...
    // 尝试用模块的 importer 来执行代码
    if (filename != NULL) {
        sts = RunMainFromImporter(filename);
    }
    ...
    // 一般我们自己的 py 文件，会使用这个来执行
    sts = PyRun_AnyFileExFlags(
            fp,
            filename == NULL ? &#34;&lt;stdin&gt;&#34; : filename,
            filename != NULL, &amp;amp;cf) != 0;
    }
    ...
}&lt;/p&gt;
&lt;p&gt;// pythonrun.c
int
PyRun_AnyFileExFlags(FILE &lt;em&gt;fp, const char &lt;/em&gt;filename, int closeit,
                     PyCompilerFlags *flags)
{
    ...
    return PyRun_SimpleFileExFlags(fp, filename, closeit, flags);
}&lt;/p&gt;
&lt;p&gt;int
PyRun_SimpleFileExFlags(FILE &lt;em&gt;fp, const char &lt;/em&gt;filename, int closeit,
                        PyCompilerFlags *flags)
{
    ...
    m = PyImport_AddModule(&#34;&lt;strong&gt;main&lt;/strong&gt;&#34;);
    d = PyModule_GetDict(m);
    ...
    // 设置 &lt;strong&gt;file&lt;/strong&gt; 属性
    if (PyDict_SetItemString(d, &#34;&lt;strong&gt;file&lt;/strong&gt;&#34;, f) &amp;lt; 0) {
        ...
    }
    ...
    // globals = locals = d = &lt;strong&gt;main&lt;/strong&gt;.&lt;strong&gt;dict&lt;/strong&gt;
    v = run_pyc_file(fp, filename, d, d, flags);
    ...
}&lt;/p&gt;
&lt;p&gt;static PyObject *
run_pyc_file(FILE &lt;em&gt;fp, const char &lt;/em&gt;filename, PyObject &lt;em&gt;globals,
             PyObject &lt;/em&gt;locals, PyCompilerFlags *flags)
{
    ...
    // 从 pyc 文件读取代码对象 co ，并执行代码
    // PyEval_EvalCode 里面也同样会调用 PyFrame_New 创建新栈帧
    v = PyEval_EvalCode(co, globals, locals);
    ...
}
```&lt;/p&gt;
&lt;p&gt;当执行 &lt;code&gt;python a.py&lt;/code&gt; 时，一般情况下会走到 &lt;code&gt;PyRun_SimpleFileExFlags&lt;/code&gt;，&lt;code&gt;PyRun_SimpleFileExFlags&lt;/code&gt; 里面会取出来 &lt;code&gt;__main__.__dict__&lt;/code&gt;，作为代码执行时的 &lt;code&gt;globals&lt;/code&gt; 和 &lt;code&gt;locals&lt;/code&gt;，最终也会传到 &lt;code&gt;PyFrame_New&lt;/code&gt; 中创建新的栈帧来执行 &lt;code&gt;a.py&lt;/code&gt;。结合我们上文提到的 &lt;code&gt;__builtins__&lt;/code&gt; 在模块和函数中传递，就可以让后续执行的代码都能共用同一份 &lt;code&gt;current_frame-&amp;gt;f_builtins = __main__.__builtins__.__dict__&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;再论 Restricted Execution&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Python&lt;/code&gt; 在 2.3 版本之前，曾经提供过的 &lt;a href=&#34;https://docs.python.org/2.7/library/restricted.html&#34;&gt;Restricted Execution&lt;/a&gt;，就是基于 &lt;code&gt;__builtins__&lt;/code&gt; 的特性来制作的。或者可以认为，&lt;code&gt;__builtins__&lt;/code&gt; 之所以设计成在 &lt;code&gt;__main__&lt;/code&gt; 模块中是一个模块对象，而在其他模块中是一个 &lt;code&gt;dict&lt;/code&gt; 对象，就是为了可以实现 &lt;strong&gt;Restricted Execution&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;考虑这种情况：如果我们可以自由定制自己的 &lt;code&gt;__builtin__&lt;/code&gt; 模块，并设置成 &lt;code&gt;__main__.__builtins__&lt;/code&gt;，那就相当于后续所有执行的代码，都会使用我们定制的模块，我们可以定制特定版本的 &lt;code&gt;open&lt;/code&gt;、&lt;code&gt;__import__&lt;/code&gt;、&lt;code&gt;file&lt;/code&gt; 等内建函数和类型，更进一步，这种方式是不是可以帮助我们限制执行代码的权限，防止代码做一些不安全的函数调用，或者访问一些不安全的文件？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Python&lt;/code&gt; 当时就做过这种尝试，实现这个功能的模块就叫做: &lt;code&gt;rexec&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;rexec&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;我无意太深入讲解 &lt;code&gt;rexec&lt;/code&gt; 的实现，因为原理其实上文已经讲清楚了，并且这个模块本身就已经废弃，我这些仅简单做一些关键代码的摘要，方便查阅。&lt;/p&gt;
&lt;p&gt;```python&lt;/p&gt;
&lt;h1&gt;rexec.py&lt;/h1&gt;
&lt;p&gt;class RExec(ihooks._Verbose):
    ...
    nok_builtin_names = (&#39;open&#39;, &#39;file&#39;, &#39;reload&#39;, &#39;&lt;strong&gt;import&lt;/strong&gt;&#39;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def __init__(self, hooks = None, verbose = 0):
    ...
    self.modules = {}
    ...
    self.make_builtin()
    self.make_initial_modules()
    self.make_sys()
    self.loader = RModuleLoader(self.hooks, verbose)
    self.importer = RModuleImporter(self.loader, verbose)

def make_builtin(self):
    m = self.copy_except(__builtin__, self.nok_builtin_names)
    m.__import__ = self.r_import
    m.reload = self.r_reload
    m.open = m.file = self.r_open

def add_module(self, mname):
    m = self.modules.get(mname)
    if m is None:
        self.modules[mname] = m = self.hooks.new_module(mname)
    m.__builtins__ = self.modules[&#39;__builtin__&#39;]
    return m

def r_exec(self, code):
    m = self.add_module(&#39;__main__&#39;)
    exec code in m.__dict__

def r_eval(self, code):
    m = self.add_module(&#39;__main__&#39;)
    return eval(code, m.__dict__)

def r_execfile(self, file):
    m = self.add_module(&#39;__main__&#39;)
    execfile(file, m.__dict__)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;r_execfile&lt;/code&gt; 函数会把文件当作 &lt;code&gt;__main__&lt;/code&gt; 模块来执行，只是 &lt;code&gt;__main__&lt;/code&gt; 是定制过的。&lt;code&gt;self.add_module(&#39;__main__&#39;)&lt;/code&gt; 里面，会设置模块的 &lt;code&gt;m.__builtins__ = self.modules[&#39;__builtin__&#39;]&lt;/code&gt;，这个 &lt;code&gt;__builtin__&lt;/code&gt; 是由 &lt;code&gt;make_builtin&lt;/code&gt; 来定制生成的，在里面替换了 &lt;code&gt;__import__&lt;/code&gt;、&lt;code&gt;reload&lt;/code&gt;、&lt;code&gt;open&lt;/code&gt; 函数，并删除了 &lt;code&gt;file&lt;/code&gt; 类型。这样，我们就能控制要执行的代码对内建命名空间的访问了。&lt;/p&gt;
&lt;p&gt;对于一些内建模块，&lt;code&gt;rexec&lt;/code&gt; 也做了定制，保护不安全的访问，譬如 &lt;code&gt;sys&lt;/code&gt; 模块，只保留了一部分的对象，并且通过定制的 &lt;code&gt;self.loader&lt;/code&gt;、&lt;code&gt;self.importer&lt;/code&gt;，来实现 &lt;code&gt;import&lt;/code&gt; 的时候，优先加载定制的模块。&lt;/p&gt;
&lt;p&gt;如果对代码细节感兴趣，请自行查阅相关源码。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;rexec&lt;/code&gt; 的失败&lt;/h3&gt;
&lt;p&gt;上文提到，&lt;code&gt;Python 2.3&lt;/code&gt; 之后，&lt;code&gt;rexec&lt;/code&gt; 就已经废弃了，因为这种方式已经被证实为不可行。带着好奇心，我们来简单溯源一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在社区有人报告了 &lt;a href=&#34;https://mail.python.org/pipermail/python-dev/2002-December/031160.html&#34;&gt;Bug&lt;/a&gt;，并引发了开发者之间的讨论：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;it&#39;s never going to be safe, and I doubt it&#39;s very useful as long as it&#39;s not safe.&lt;/p&gt;
&lt;p&gt;Every change is a potential security hole.&lt;/p&gt;
&lt;p&gt;it&#39;s hard to predict what change is going to break it.&lt;/p&gt;
&lt;p&gt;I don&#39;t expect you&#39;ll ever reach the point where it&#39;ll be wise to advertise this as safe.  I certainly won&#39;t.&lt;/p&gt;
&lt;p&gt;this is only a useful occupation if you expect to eventually reach a point where you expect that there aren&#39;t any security flaws left.  Jeremy &amp;amp; I both doubt that Python will ever reach that level, meaning that the whole exercise of fixing security flaws is a waste of time (if you know you &lt;em&gt;can&#39;t&lt;/em&gt; make it safe, don&#39;t waste time trying).&lt;/p&gt;
&lt;p&gt;I agree (but I have said that in past) the best thing is to deprecate/rip out rexec.&lt;/p&gt;
&lt;p&gt;The code will still be in older versions if someone decides to pick it up and work on it as a separate project.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该 Bug 的起因是 &lt;code&gt;Python&lt;/code&gt; 引入了新式类（new-style class） &lt;code&gt;object&lt;/code&gt;，导致 &lt;code&gt;rexec&lt;/code&gt; 不能正常工作。于是开发者表示，在可预见的未来，这种情况都很难避免，任意的修改都会可能导致 &lt;code&gt;rexec&lt;/code&gt; 出现漏洞，不能正常工作，或者被突破权限的限制，基本上无法实现没有漏洞地去提供一个安全环境的愿景，开发者需要不断地修修补补，浪费大量的时间。最终，&lt;code&gt;rexec&lt;/code&gt; 这个模块就被废弃掉了，&lt;code&gt;Python&lt;/code&gt; 也没有再提供类似的功能。但关于 &lt;code&gt;__builtins__&lt;/code&gt; 的设定，由于兼容性等问题，就继续保留下来了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后面在大概 2010 年的时候，有位程序员推出了 &lt;a href=&#34;https://github.com/vstinner/pysandbox&#34;&gt;pysandbox&lt;/a&gt;，致力于提供可以替代 &lt;code&gt;rexec&lt;/code&gt; 的 &lt;code&gt;Python&lt;/code&gt; 沙盒环境。但是 3 年后，作者主动放弃了这个项目，并详细说明了为什么作者认为这个项目是失败的：&lt;a href=&#34;https://mail.python.org/pipermail/python-dev/2013-November/130132.html&#34;&gt;The pysandbox project is broken&lt;/a&gt;，也有其他作者撰文总结了这个项目的失败：&lt;a href=&#34;https://lwn.net/Articles/574215/&#34;&gt;The failure of pysandbox&lt;/a&gt;。如果感兴趣的话，可以具体去翻翻原文，我这里也给一些摘要来帮助了解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;After having work during 3 years on a pysandbox project to sandbox untrusted code, I now reached a point where I am convinced that pysandbox is broken by design. Different developers tried to convinced me before that pysandbox design is unsafe, but I had to experience it myself to be convineced.&lt;/p&gt;
&lt;p&gt;I now agree that putting a sandbox in CPython is the wrong design. There are too many ways to escape the untrusted namespace using the various introspection features of the Python language. To guarantee the [safety] of a security product, the code should be [carefully] audited and the code to review must be as small as possible. Using pysandbox, the &#34;code&#34; is the whole Python core which is a really huge code base. For example, the Python and Objects directories of Python 3.4 contain more than 126,000 lines of C code.&lt;/p&gt;
&lt;p&gt;The security of pysandbox is the security of its weakest part. A single bug is enough to escape the whole sandbox.&lt;/p&gt;
&lt;p&gt;pysandbox cannot be used in practice. To protect the untrusted namespace, pysandbox installs a lot of different protections. Because of all these protections, it becomes hard to write Python code. Basic features like &#34;del dict[key]&#34; are denied. Passing an object to a sandbox is not possible to sandbox, pysandbox is unable to proxify arbitary objects. For something more complex than evaluating &#34;1+(2*3)&#34;, pysandbox cannot be used in practice, because of all these protections.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;pysandbox&lt;/strong&gt; 的作者认为，在 &lt;code&gt;Python&lt;/code&gt; 里面放一个沙盒环境是错误的设计，有太多的方式可以从沙盒中逃逸出去，&lt;code&gt;Python&lt;/code&gt; 提供的语言特性很丰富，&lt;code&gt;CPython&lt;/code&gt; 源码的代码量很大，基本不可能保证有足够的安全性。而 &lt;strong&gt;pysandbox&lt;/strong&gt; 的开发过程就是在不断地打补丁，补丁太多，限制太多，以至于作者认为 &lt;strong&gt;pysandbox&lt;/strong&gt; 已经没法实际使用，因为很多的语法特性和功能都被限制不能使用了，譬如简单的 &lt;code&gt;del dict[key]&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;Restricted Execution 出路在哪&lt;/h2&gt;
&lt;p&gt;既然 &lt;code&gt;rexec&lt;/code&gt; 和 &lt;strong&gt;pysandbox&lt;/strong&gt; 这种通过 Patch Python 来提供沙盒环境的方法（这里姑且把这种方法称作 Patch Python）已经走不通了，那我不禁好奇：要怎么才能给 Python 提供一个能用的沙盒环境？&lt;/p&gt;
&lt;p&gt;在这里我继续收集了一些其他的实现方法或者案例，方便参考和查阅：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://doc.pypy.org/en/latest/sandbox.html&#34;&gt;PyPy&lt;/a&gt; 有一个&lt;a href=&#34;https://foss.heptapod.net/pypy/pypy/-/tree/branch/sandbox-2&#34;&gt;分支&lt;/a&gt;提供了沙盒的功能，结合额外的 &lt;a href=&#34;https://foss.heptapod.net/pypy/sandboxlib&#34;&gt;sandboxlib&lt;/a&gt;，可以自行编译出带沙盒环境版本的 PyPy。如果感兴趣，可以尝试自行配置，参考这里的一些&lt;a href=&#34;https://foss.heptapod.net/pypy/pypy/-/issues/3192&#34;&gt;说明&lt;/a&gt;。PyPy 实现的原理是创建一个子进程，子进程的所有输入输出和系统调用，都会重定向到外部进程，由外部进程控制这些权限，另外也可以控制内存和 CPU 的使用量。需要注意的是，这个分支也有段时间没有新的提交了，请谨慎使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;借助操作系统提供的沙盒环境工具。&lt;a href=&#34;https://en.wikipedia.org/wiki/Seccomp&#34;&gt;seccomp&lt;/a&gt; 是 Linux 内核提供的计算安全工具，&lt;a href=&#34;https://github.com/seccomp/libseccomp/tree/main/src/python&#34;&gt;libsecoomp&lt;/a&gt; 提供了 Python 绑定，可以内嵌到代码里面使用；或者使用基于 seccomp 实现的工具来执行代码，譬如 &lt;a href=&#34;https://firejail.wordpress.com/&#34;&gt;Firejail&lt;/a&gt;。&lt;a href=&#34;https://apparmor.net/&#34;&gt;AppArmor&lt;/a&gt; 是一个 Linux 内核安全模块，允许管理员控制程序能访问的系统资源和功能，保护操作系统。&lt;a href=&#34;https://github.com/openedx/codejail&#34;&gt;codejail&lt;/a&gt; 是基于 AppArmor 实现的 Python 沙盒环境，有兴趣可以尝试。还有很多类似的工具，这里不一一列举。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用沙盒虚拟环境或者容器。&lt;a href=&#34;https://learn.microsoft.com/zh-cn/windows/security/threat-protection/windows-sandbox/windows-sandbox-overview&#34;&gt;Windows 沙盒&lt;/a&gt;，&lt;a href=&#34;https://linuxcontainers.org/&#34;&gt;LXC&lt;/a&gt;, &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; 等等，这里不再详述。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本文篇幅有点长，感谢看到这里，文章一开始所列出的疑问，相信都已经解答完毕。&lt;/p&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/py-Python%E6%9D%82%E8%B0%881-%E6%8E%A2%E7%A9%B6__builtins__/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Fri, 12 Jan 2024 06:37:04 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/py-Python%E6%9D%82%E8%B0%881-%E6%8E%A2%E7%A9%B6__builtins__/</guid>
      
    </item>
    
    <item>
      <title>使用 FASTBuild 编译 UE4 和 UE5</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;使用 FASTBuild 编译 UE4 和 UE5&#34; /&gt;&lt;/p&gt;
&lt;!-- no translate --&gt;

&lt;blockquote&gt;
&lt;p&gt;本文方法经测试支持 UE4.27 - UE5.3，其他版本未测试过，可以尝试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.fastbuild.org/docs/home.html&#34;&gt;FASTBuild&lt;/a&gt; 是一个免费开源的分布式编译工具，UE 本身编译比较耗时，如果可以用上 FASTBuild，能够大大减少耗时。&lt;/p&gt;
&lt;p&gt;UE 从 4.x 开始能够支持 FASTBuild，官方源码自带了魔改过的 FASTBuild 工具，基于 FASTBuild 0.99 版本，位置在 &lt;code&gt;Engine\Extras\ThirdPartyNotUE\FASTBuild&lt;/code&gt;，UE5.3 同样使用的是这个版本。这个已经是比较久以前的版本了，截止本文创建时间，FASTBuild 官方最新版本是 1.11，有了更多新的功能支持和 bug 修复。本文着重记录如何使用 1.11 版本同时支持 UE4 和 UE5。&lt;/p&gt;
&lt;h2&gt;简易配置&lt;/h2&gt;
&lt;p&gt;要达到目的，我们需要对 FASTBuild 1.11 和 UE 源码做一些修改。在这里，其实我已经都修改完了，于是我们可以直接用我修改完的版本来使用。&lt;/p&gt;
&lt;p&gt;FASTBuild 下载我提交的 &lt;a href=&#34;https://github.com/disenone/fastbuild/releases&#34;&gt;最新版本&lt;/a&gt; 里面的执行文件 FBuild.exe, FBuildCoordinator.exe, FBuildWorker.exe。为了清晰表达，下面把使用 FBuild.exe 来进行编程的机器叫做&lt;code&gt;本机&lt;/code&gt;，其他提供 CPU 参与编辑的远程机器叫做&lt;code&gt;远程机&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;本机配置&lt;/h3&gt;
&lt;p&gt;把 FBuild.exe 所在目录加入系统环境变量 Path 中，保证 cmd 里面能直接执行 FBuild.exe。&lt;/p&gt;
&lt;p&gt;配置 Cache 共享目录（如果不需要生成 Cache 的话，可以不配置）：把一个空目录设置成共享路径，并确认远程机可以访问。&lt;/p&gt;
&lt;p&gt;打开本机 UE4 / UE5 的源码项目，修改编译配置文件 Engine\Saved\UnrealBuildTool\BuildConfiguration.xml 如下：&lt;/p&gt;
&lt;p&gt;```xml&lt;/p&gt;
&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34; ?&gt;
&lt;p&gt;&lt;Configuration xmlns=&#34;https://www.unrealengine.com/BuildConfiguration&#34;&gt;
    &lt;BuildConfiguration&gt;
        &lt;bAllowFASTBuild&gt;true&lt;/bAllowFASTBuild&gt;
    &lt;/BuildConfiguration&gt;
    &lt;FASTBuild&gt;
        &lt;bEnableDistribution&gt;true&lt;/bEnableDistribution&gt;
        &lt;bEnableCaching&gt;true&lt;/bEnableCaching&gt;
        &lt;FBuildCachePath&gt;\127.0.0.1\Cache\&lt;/FBuildCachePath&gt;
        &lt;FBuildCoordinator&gt;127.0.0.1&lt;/FBuildCoordinator&gt;
    &lt;/FASTBuild&gt;
&lt;/Configuration&gt;
```&lt;/p&gt;
&lt;p&gt;本机运行之前下载的 FBuildCoordinator.exe。&lt;/p&gt;
&lt;h3&gt;远程机配置&lt;/h3&gt;
&lt;p&gt;同样配置 Cache，只是 ip 需要指定到本机 ip，这里假定为 192.168.1.100&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FASTBUILD_CACHE_PATH: \192.168.1.100\Cache&lt;/li&gt;
&lt;li&gt;FASTBUILD_CACHE_MODE: rw&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同样配置 Coordinator ip&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FASTBUILD_COORDINATOR: 192.168.1.100&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置完如下图&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-fastbuild/remote_vars.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;远程机上运行 FBuildWorker.exe，如果配置成功，可以看到本机的 FBuildCoordinator.exe 上会打印日志（这里 192.168.1.101 是远程机的 ip）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FBuildCoordinator - v1.11-UE
[2023-12-01-20:06:38] Listening on port 31392
[2023-12-01-20:06:38] current [0] workers: []
[2023-12-01-20:06:42] New worker available: 192.168.1.101
[2023-12-01-20:06:42] current [1] workers: [192.168.1.101]&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;测试 UE 编译&lt;/h3&gt;
&lt;p&gt;用 VisualStudio 打开 UE 源码工程 sln，选一个 C++ 的项目，点击 Rebuild。如果配置正常，可以看到类似如下的日志&lt;/p&gt;
&lt;p&gt;&lt;code&gt;11&amp;gt;FBuild Command Line Arguments: &#39;-monitor -summary -dist -cache -ide -j12 -clean -config &#34;E:\UE\ue5.3_git\Engine\Intermediate\Build\fbuild.bff&#34; -nostoponerror
11&amp;gt;FBuild Executable: &#39;d:\libs\FASTBuild\bin\FBuild.exe
11&amp;gt;FBuild Coordinator: &#39;127.0.0.1
11&amp;gt;FBuild BrokeragePath: &#39;\\127.0.0.1\Brokerage\
11&amp;gt;FBuild CachePath: &#39;\\127.0.0.1\Cache\
11&amp;gt;BFF file &#39;E:\UE\ue5.3_git\Engine\Intermediate\Build\fbuild.bff&#39; has changed (reparsing will occur).
11&amp;gt;Using Coordinator: 127.0.0.1
11&amp;gt;Requesting worker list from Corrdinator
11&amp;gt;Get Worker List from Coordinator.
11&amp;gt;2 workers in payload: [192.168.1.101]
11&amp;gt;Worker list received: 1 workers
11&amp;gt;Distributed Compilation : 1 Workers in pool &#39;127.0.0.1&#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;FASTBuild 能找到远程机的 ip，并开始给远程机发送编译。在远程机的 FBuildWorker 上也能看到当前有编译任务在执行。&lt;/p&gt;
&lt;h2&gt;进阶配置&lt;/h2&gt;
&lt;h3&gt;支持更久版本的 UE&lt;/h3&gt;
&lt;p&gt;如果你发现自己的 UE 没有 FASTBuild 工具（Engine\Extras\ThirdPartyNotUE\FASTBuild），并且项目 UnrealBuildTool 里面没有 FASTBuild.cs 文件，那么很大概率是你的 UE 版本还不支持 FASTBuild。&lt;/p&gt;
&lt;p&gt;那么你需要参考 UE4.27 的源码，也创建一个类似的 FASTBuild.cs，并补上其他相关代码的修改，这里不详述。&lt;/p&gt;
&lt;h3&gt;编译自己的 FASTBuild&lt;/h3&gt;
&lt;p&gt;如果你对 FASTBuild 本身也感兴趣，或者想要做一些修改，可以尝试用 FASTBuild 来编译 FASTBuild。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载我的 &lt;a href=&#34;https://github.com/disenone/fastbuild/releases&#34;&gt;最新源码&lt;/a&gt;，并解压&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 External\SDK\VisualStudio\VS2019.bff，把 .VS2019_BasePath 和 .VS2019_Version 修改成你本机对应的内容，Version 可以在 .VS2019_BasePath\Tools\MSVC 目录下面看，例如
    &lt;code&gt;.VS2019_BasePath        = &#39;C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC&#39;    // &amp;lt;-- Set path here
    .VS2019_Version         = &#39;14.29.30133&#39; // &amp;lt;-- Set version here
    .VS2019_MSC_VER         = &#39;1929&#39; // &amp;lt;-- Set MSC_VER here&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 External\SDK\Windows\Windows10SDK.bff 的 .Windows10_SDKBasePath 和 .Windows10_SDKVersion，版本可以在 .Windows10_SDKBasePath/bin 里面看：
    &lt;code&gt;.Windows10_SDKBasePath        = &#39;C:\Program Files (x86)\Windows Kits/10&#39;    // &amp;lt;-- Set path here
    .Windows10_SDKVersion         = &#39;10.0.19041.0&#39; // &amp;lt;-- Set version here&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 External\SDK\Clang\Windows\Clang11.bff 的 .Clang11_BasePath 和 .Clang11_Version，路径在 .VS2019_BasePath\Tools\Tools/LLVM/x64
    &lt;code&gt;.Clang11_BasePath = &#39;C:/Program Files (x86)/Microsoft Visual Studio/2019/Professional/VC/Tools/LLVM/x64&#39;    // &amp;lt;-- Set path here
    .Clang11_Version  = &#39;12.x.x&#39;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入 Code 目录，在 cmd 执行 &lt;code&gt;FBuild.exe All-x64-Release&lt;/code&gt;，如果配置正常，可以看到编译成功，在 tmp\x64-Release\Tools\FBuild\FBuild 能看到 FBuild.exe。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FBuild.exe All-x64-Release -dist -coordinator=127.0.0.1&lt;/code&gt; 可以开启分布式编译。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;FBuild 更多选项&lt;/h3&gt;
&lt;p&gt;我提供的 FBuild 本身支持以下常用的选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;coordinator: 指定 Coordinator ip 地址（可以覆盖系统环境变量的值）&lt;/li&gt;
&lt;li&gt;brokerage: 指定 Brokerage 地址（可以覆盖系统环境变量的值）&lt;/li&gt;
&lt;li&gt;nocache：强制不使用 cache&lt;/li&gt;
&lt;li&gt;dist：开启分布式编译&lt;/li&gt;
&lt;li&gt;forceremote：强制在远程机编译&lt;/li&gt;
&lt;li&gt;summary: 编辑结束后输出统计报告&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等等，更多选项可以运行 &lt;code&gt;FBuild.exe -help&lt;/code&gt; 来看。&lt;/p&gt;
&lt;p&gt;FBuildWorker 常用的选项有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;coordinator: 指定 Coordinator ip 地址（可以覆盖系统环境变量的值）&lt;/li&gt;
&lt;li&gt;brokerage: 指定 Brokerage 地址（可以覆盖系统环境变量的值）&lt;/li&gt;
&lt;li&gt;nocache：强制不使用 cache&lt;/li&gt;
&lt;li&gt;cpus: 指定分配多少个核参与编译&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多选项可以运行 &lt;code&gt;FBuildWorder.exe -help&lt;/code&gt; 来看。&lt;/p&gt;
&lt;h3&gt;修改 UE 自带的 FASTBuild.cs&lt;/h3&gt;
&lt;p&gt;UE 自带的 FASTBuild.cs 并没有很好的处理系统环境变量，跟 BuildConfiguration.xml 指定的参数的关系，很多参数是优先读取了系统环境变量，这显然跟 BuildConfiguration.xml 的使用逻辑是相反的。&lt;/p&gt;
&lt;p&gt;为此，可以把相关的代码改成这样，这里以 UE5.3 为例：&lt;/p&gt;
&lt;p&gt;```csharp
private bool ExecuteBffFile(string BffFilePath, ILogger Logger)
{
    string CacheArgument = &#34;&#34;;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (bEnableCaching)
{
    switch (CacheMode)
    {
        case FASTBuildCacheMode.ReadOnly:
            CacheArgument = &#34;-cacheread&#34;;
            break;
        case FASTBuildCacheMode.WriteOnly:
            CacheArgument = &#34;-cachewrite&#34;;
            break;
        case FASTBuildCacheMode.ReadWrite:
            CacheArgument = &#34;-cache&#34;;
            break;
    }
}
else
{
    CacheArgument = &#34;-nocache&#34;;
}

string DistArgument = bEnableDistribution ? &#34;-dist&#34; : &#34;&#34;;
string ForceRemoteArgument = bForceRemote ? &#34;-forceremote&#34; : &#34;&#34;;
string NoStopOnErrorArgument = bStopOnError ? &#34;&#34; : &#34;-nostoponerror&#34;;
string IDEArgument = IsApple() ? &#34;&#34; : &#34;-ide&#34;;
string MaxProcesses = &#34;-j&#34; + ((ParallelExecutor)LocalExecutor).NumParallelProcesses;

// Interesting flags for FASTBuild:
// -nostoponerror, -verbose, -monitor (if FASTBuild Monitor Visual Studio Extension is installed!)
// Yassine: The -clean is to bypass the FASTBuild internal
// dependencies checks (cached in the fdb) as it could create some conflicts with UBT.
// Basically we want FB to stupidly compile what UBT tells it to.
string FBCommandLine = $&#34;-monitor -summary {DistArgument} {CacheArgument} {IDEArgument} {MaxProcesses} -clean -config \&#34;{BffFilePath}\&#34; {NoStopOnErrorArgument} {ForceRemoteArgument}&#34;;

Logger.LogInformation(&#34;FBuild Command Line Arguments: &#39;{FBCommandLine}&#34;, FBCommandLine);

string FBExecutable = GetExecutablePath()!;
Logger.LogInformation(&#34;FBuild Executable: &#39;{FBExecutable}&#34;, FBExecutable);

string WorkingDirectory = Path.GetFullPath(Path.Combine(Unreal.EngineDirectory.MakeRelativeTo(DirectoryReference.GetCurrentDirectory()), &#34;Source&#34;));

ProcessStartInfo FBStartInfo = new ProcessStartInfo(FBExecutable, FBCommandLine);
FBStartInfo.UseShellExecute = false;
FBStartInfo.WorkingDirectory = WorkingDirectory;
FBStartInfo.RedirectStandardError = true;
FBStartInfo.RedirectStandardOutput = true;

string? Coordinator = GetCoordinator();
if (!String.IsNullOrEmpty(Coordinator))
{
    Logger.LogInformation(&#34;FBuild Coordinator: &#39;{Coordinator}&#34;, Coordinator);
    FBStartInfo.EnvironmentVariables[&#34;FASTBUILD_COORDINATOR&#34;] = Coordinator;
}

string? BrokeragePath = GetBrokeragePath();
if (!String.IsNullOrEmpty(BrokeragePath))
{
    Logger.LogInformation(&#34;FBuild BrokeragePath: &#39;{BrokeragePath}&#34;, BrokeragePath);
    FBStartInfo.EnvironmentVariables[&#34;FASTBUILD_BROKERAGE_PATH&#34;] = BrokeragePath;
}

string? CachePath = GetCachePath();
if (!String.IsNullOrEmpty(CachePath))
{
    Logger.LogInformation(&#34;FBuild CachePath: &#39;{CachePath}&#34;, CachePath);
    FBStartInfo.EnvironmentVariables[&#34;FASTBUILD_CACHE_PATH&#34;] = CachePath;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;...
```&lt;/p&gt;
&lt;h3&gt;BuildConfiguration.xml 进阶配置&lt;/h3&gt;
&lt;p&gt;```xml&lt;/p&gt;
&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34; ?&gt;
&lt;p&gt;&lt;Configuration xmlns=&#34;https://www.unrealengine.com/BuildConfiguration&#34;&gt;
    &lt;ProjectFileGenerator&gt;
        &lt;!-- 指定vs版本 --&gt;
        &lt;Format&gt;VisualStudio2022&lt;/Format&gt; &lt;br&gt;
    &lt;/ProjectFileGenerator&gt;
    &lt;BuildConfiguration&gt;
        &lt;!-- 开启 FASTBuild --&gt;
        &lt;bAllowFASTBuild&gt;true&lt;/bAllowFASTBuild&gt;
        &lt;!-- 指定本机参与编译的 cpu 核数 --&gt;
        &lt;MaxParallelActions&gt;12&lt;/MaxParallelActions&gt;
        &lt;!-- 关闭 Incredibuild --&gt;
        &lt;bAllowXGE&gt;false&lt;/bAllowXGE&gt;
    &lt;/BuildConfiguration&gt;
    &lt;FASTBuild&gt;
        &lt;!-- 指定 FBuild 路径 --&gt;
        &lt;FBuildExecutablePath&gt;d:\libs\FASTBuild\bin\FBuild.exe&lt;/FBuildExecutablePath&gt;
        &lt;!-- 开启分布式编译 --&gt;
        &lt;bEnableDistribution&gt;true&lt;/bEnableDistribution&gt;
        &lt;!-- 指定 brokerage 路径 --&gt;
        &lt;FBuildBrokeragePath&gt;\127.0.0.1\Brokerage\&lt;/FBuildBrokeragePath&gt;
        &lt;!-- 指定 cache 路径 --&gt;
        &lt;FBuildCachePath&gt;\127.0.0.1\Cache\&lt;/FBuildCachePath&gt;
        &lt;!-- 开启 cache --&gt;
        &lt;bEnableCaching&gt;true&lt;/bEnableCaching&gt;
        &lt;!-- cache 的读写权限 Read/Write/ReadWrite --&gt;
        &lt;CacheMode&gt;ReadWrite&lt;/CacheMode&gt;
        &lt;!-- 指定 coordinator ip --&gt;
        &lt;FBuildCoordinator&gt;127.0.0.1&lt;/FBuildCoordinator&gt;
        &lt;!-- 强制远程编译 --&gt;
        &lt;!-- &lt;bForceRemote&gt;true&lt;/bForceRemote&gt; --&gt;
    &lt;/FASTBuild&gt;
&lt;/Configuration&gt;
```&lt;/p&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/ue-%E4%BD%BF%E7%94%A8FASTBuild%E7%BC%96%E8%AF%91UE4%E5%92%8CUE5/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Thu, 28 Dec 2023 18:29:00 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/ue-%E4%BD%BF%E7%94%A8FASTBuild%E7%BC%96%E8%AF%91UE4%E5%92%8CUE5/</guid>
      
    </item>
    
    <item>
      <title>UE 扩展编辑器菜单</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;UE 扩展编辑器菜单&#34; /&gt;&lt;/p&gt;
&lt;h1&gt;UE 扩展编辑器菜单&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;记录 UE 如何扩展编辑器菜单&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Hook&lt;/h2&gt;
&lt;p&gt;Hook 可以理解为扩展菜单的锚点，我们可以设置新加的菜单命令在 Hook 的前面或者后面，UE 自带的编辑器菜单命令基本都带有 Hook，UE5 下打开 &lt;code&gt;编辑 - 编辑器偏好设置 - 通用 - 其他 - 显示 UI 扩展点&lt;/code&gt; 来显示所有菜单的 Hook：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-extend_menu/show_hook.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-extend_menu/show_hook2.png&#34;&gt;&lt;/p&gt;
&lt;h2&gt;模块依赖&lt;/h2&gt;
&lt;p&gt;需要在项目 .Build.cs 文件里面加上依赖的模块 LevelEditor, Slate, SlateCore, EditorStyle, EditorWidgets, UnrealEd, ToolMenus：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
PrivateDependencyModuleNames.AddRange(
    new string[]
    {
        &#34;Core&#34;,
        &#34;Engine&#34;,
        &#34;CoreUObject&#34;,
        &#34;LevelEditor&#34;,
        &#34;Slate&#34;,
        &#34;SlateCore&#34;,
        &#34;EditorStyle&#34;,
        &#34;EditorWidgets&#34;,
        &#34;UnrealEd&#34;,
        &#34;ToolMenus&#34;,
    }
    );&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;添加菜单栏&lt;/h2&gt;
&lt;p&gt;直接上代码&lt;/p&gt;
&lt;p&gt;```cpp
auto MenuExtender = MakeShared&lt;FExtender&gt;();&lt;/p&gt;
&lt;p&gt;MenuExtender-&amp;gt;AddMenuBarExtension(
    &#34;Help&#34;, EExtensionHook::After,      // Create After Help
    nullptr,
    FMenuBarExtensionDelegate::CreateLambda(&lt;a href=&#34;FMenuBarBuilder&amp;amp; MenuBarBuilder&#34;&gt;&lt;/a&gt;
    {
        MenuBarBuilder.AddPullDownMenu(
            TEXT(&#34;MenuTest&#34;),       // Name
            TEXT(&#34;MenuTest&#34;),       // Tips
            FNewMenuDelegate::CreateLambda(&lt;a href=&#34;FMenuBuilder&amp;amp; MenuBuilder&#34;&gt;&lt;/a&gt;
            {
                // create sub menus
            }),
            TEXT(&#34;MenuText&#34;));      // New Hook
    })
);
FModuleManager::LoadModuleChecked&lt;FLevelEditorModule&gt;(&#34;LevelEditor&#34;).GetMenuExtensibilityManager()-&amp;gt;AddExtender(MenuExtender);
```&lt;/p&gt;
&lt;p&gt;执行以上代码可以看到在 帮助 后面加上了一个菜单栏 MenuTest:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-extend_menu/bar.png&#34;&gt;&lt;/p&gt;
&lt;h2&gt;添加命令&lt;/h2&gt;
&lt;p&gt;使用接口 &lt;code&gt;MenuBuilder.AddMenuEntry&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
// Inside MenuTest Lambda
MenuBuilder.AddMenuEntry(
    FText::FromName(&#34;MenuTestAction&#34;), FText::FromName(&#34;MenuTestAction&#34;),
    FSlateIcon(), FUIAction(FExecuteAction::CreateLambda([]()
    {
        // do action
    })));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;把以上代码放到 CreateLambda 里面，即可生成菜单命令：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-extend_menu/action.png&#34;&gt;&lt;/p&gt;
&lt;h2&gt;菜单分节&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;MenuBuilder.BeginSection&lt;/code&gt; 和 &lt;code&gt;MenuBuilder.EndSection&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
MenuBuilder.BeginSection(NAME_None, FText::FromName(&#34;MenuTestSection&#34;));
// code to create action
MenuBuilder.EndSection();&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;分隔符&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;cpp
MenuBuilder.AddMenuSeparator();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-extend_menu/section&amp;amp;sperator.png&#34;&gt;&lt;/p&gt;
&lt;h2&gt;子菜单&lt;/h2&gt;
&lt;p&gt;子菜单类似菜单栏，需要在 Lambda 里面定义：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
MenuBuilder.AddSubMenu(
    FText::FromName(&#34;MenuTestSub&#34;), 
    FText::FromName(&#34;MenuTestSub&#34;), 
    FNewMenuDelegate::CreateLambda([](FMenuBuilder&amp;amp; MenuBuilder)
    {
        MenuBuilder.AddMenuEntry(
            FText::FromName(&#34;MenuTestSubAction&#34;), FText::FromName(&#34;MenuTestSubAction&#34;),
            FSlateIcon(), FUIAction(FExecuteAction::CreateLambda([]()
            {
                // do action
            })));
    }));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-extend_menu/submenu.png&#34;&gt;&lt;/p&gt;
&lt;h1&gt;SlateUI 控件&lt;/h1&gt;
&lt;p&gt;还可以添加 UI 控件：&lt;/p&gt;
&lt;p&gt;```cpp
MenuBuilder.AddWidget(
    SNew(SHorizontalBox)
        + SHorizontalBox::Slot()
        .AutoWidth()
        [
            SNew(SEditableTextBox)
            .MinDesiredWidth(50)
            .Text(FText::FromName(&#34;MenuTestWidget&#34;))
        ]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    + SHorizontalBox::Slot()
    .AutoWidth()
    .Padding(5, 0, 0, 0)
    [
    SNew(SButton)
    .Text(FText::FromName(&#34;ExtendWidget&#34;))
    .OnClicked(FOnClicked::CreateLambda([]()
    {
        // do action
        return FReply::Handled();
    }))
    ],
FText::GetEmpty()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;);
```&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-extend_menu/widget.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Slate UI 相关的内容这里不详细展开，有兴趣可以去另外找文章看。&lt;/p&gt;
&lt;h1&gt;Hook 增加菜单&lt;/h1&gt;
&lt;p&gt;譬如在 &lt;code&gt;工具 - 编程&lt;/code&gt; 里面增加一个命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
MenuExtender-&amp;gt;AddMenuExtension(
    &#34;Programming&#34;, EExtensionHook::After,
    nullptr,
    FMenuExtensionDelegate::CreateLambda([](FMenuBuilder&amp;amp; MenuBuilder)
    {
        MenuBuilder.AddMenuEntry(
        FText::FromName(&#34;MenuTestAction&#34;), FText::FromName(&#34;MenuTestAction&#34;),
        FSlateIcon(), FUIAction(FExecuteAction::CreateLambda([]()
        {
            // do action
        })));
    })
);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-extend_menu/other_hook.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;同理可以添加其他菜单类型。&lt;/p&gt;
&lt;h1&gt;完整代码&lt;/h1&gt;
&lt;p&gt;```cpp
void BuildTestMenu()
{
    auto MenuExtender = MakeShared&lt;FExtender&gt;();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MenuExtender-&amp;gt;AddMenuBarExtension(
    &#34;Help&#34;, EExtensionHook::After,
    nullptr,
    FMenuBarExtensionDelegate::CreateLambda([](FMenuBarBuilder&amp;amp; MenuBarBuilder)
    {
        MenuBarBuilder.AddPullDownMenu(
            FText::FromName(&#34;MenuTest&#34;),
            FText::FromName(&#34;MenuTest&#34;),
            FNewMenuDelegate::CreateLambda([](FMenuBuilder&amp;amp; MenuBuilder)
            {
                MenuBuilder.BeginSection(NAME_None, FText::FromName(&#34;MenuTestSection&#34;));
                MenuBuilder.AddMenuSeparator();
                MenuBuilder.AddMenuEntry(
                    FText::FromName(&#34;MenuTestAction&#34;), FText::FromName(&#34;MenuTestAction&#34;),
                    FSlateIcon(), FUIAction(FExecuteAction::CreateLambda([]()
                    {
                        // do action
                    })));

                MenuBuilder.AddSubMenu(
                    FText::FromName(&#34;MenuTestSubb&#34;),
                    FText::FromName(&#34;MenuTestSubb&#34;),
                    FNewMenuDelegate::CreateLambda([](FMenuBuilder&amp;amp; MenuBuilder)
                    {
                        MenuBuilder.AddMenuEntry(
                            FText::FromName(&#34;MenuTestSubAction&#34;), FText::FromName(&#34;MenuTestSubAction&#34;),
                            FSlateIcon(), FUIAction(FExecuteAction::CreateLambda([]()
                            {
                                // do action
                            })));
                    }));
                MenuBuilder.EndSection();

                MenuBuilder.AddWidget(
                SNew(SHorizontalBox)
                     + SHorizontalBox::Slot()
                     .AutoWidth()
                     [
                         SNew(SEditableTextBox)
                         .MinDesiredWidth(50)
                         .Text(FText::FromName(&#34;MenuTestWidget&#34;))
                     ]
                     + SHorizontalBox::Slot()
                     .AutoWidth()
                     .Padding(5, 0, 0, 0)
                     [
                        SNew(SButton)
                        .Text(FText::FromName(&#34;ExtendWidget&#34;))
                        .OnClicked(FOnClicked::CreateLambda([]()
                        {
                            // do action
                            return FReply::Handled();
                        }))
                     ],
                 FText::GetEmpty()
                );
            }),
            &#34;MenuTest&#34;);
    })
);

MenuExtender-&amp;gt;AddMenuExtension(
    &#34;Programming&#34;, EExtensionHook::After,
    nullptr,
    FMenuExtensionDelegate::CreateLambda([](FMenuBuilder&amp;amp; MenuBuilder)
    {
        MenuBuilder.AddMenuEntry(
        FText::FromName(&#34;MenuTestAction&#34;), FText::FromName(&#34;MenuTestAction&#34;),
        FSlateIcon(), FUIAction(FExecuteAction::CreateLambda([]()
        {
            // do action
        })));
    })
);

FModuleManager::LoadModuleChecked&amp;lt;FLevelEditorModule&amp;gt;(&#34;LevelEditor&#34;).GetMenuExtensibilityManager()-&amp;gt;AddExtender(MenuExtender);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-extend_menu/overall.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/ue-%E6%89%A9%E5%B1%95%E7%BC%96%E8%BE%91%E5%99%A8%E8%8F%9C%E5%8D%95/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Thu, 28 Dec 2023 18:06:38 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/ue-%E6%89%A9%E5%B1%95%E7%BC%96%E8%BE%91%E5%99%A8%E8%8F%9C%E5%8D%95/</guid>
      
    </item>
    
    <item>
      <title>UE 设置本地化多语言</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;UE 设置本地化多语言&#34; /&gt;&lt;/p&gt;
&lt;h1&gt;UE 设置本地化多语言&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;记录如何在 UE 中实现本地化多语言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果不熟悉 UE 扩展菜单，建议先简单看下：&lt;a href=&#34;ue-扩展编辑器菜单.md&#34;&gt;UE 扩展编辑器菜单&lt;/a&gt;，&lt;a href=&#34;ue-使用路径形式扩展菜单.md&#34;&gt;ue-使用路径形式扩展菜单&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文代码基于插件：&lt;a href=&#34;https://github.com/disenone/UE.EditorPlus&#34;&gt;UE.EditorPlus&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;功能介绍&lt;/h2&gt;
&lt;p&gt;UE 自带工具可以实现本地化多语言，譬如我们可以为编辑器菜单实现本地化：&lt;/p&gt;
&lt;p&gt;中文菜单：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-localization/chinese.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;英文菜单：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-localization/english.png&#34;&gt;&lt;/p&gt;
&lt;h2&gt;代码声明&lt;/h2&gt;
&lt;p&gt;为了实现菜单本地化，我们需要在代码中明确声明需要 UE 处理的字符串，使用 UE 定义好的宏 &lt;code&gt;LOCTEXT&lt;/code&gt; 和 &lt;code&gt;NSLOCTEXT&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件全局定义方式，先开始定义一个叫做 &lt;code&gt;LOCTEXT_NAMESPACE&lt;/code&gt; 的宏，内容是当前多语言文本所在的名字空间，之后文件中的文本就可以用 &lt;code&gt;LOCTEXT&lt;/code&gt; 来定义，文件最后取消宏 &lt;code&gt;LOCTEXT_NAMESPACE&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;```cpp
// #define LOCTEXT(InKey, InTextLiteral)&lt;/p&gt;
&lt;h1&gt;define LOCTEXT_NAMESPACE &#34;EditorPlusTools&#34;&lt;/h1&gt;
&lt;p&gt;LOCTEXT(&#34;Key&#34;, &#34;Content&#34;);&lt;/p&gt;
&lt;h1&gt;undef LOCTEXT_NAMESPACE&lt;/h1&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部定义方式，使用 &lt;code&gt;NSLOCTEXT&lt;/code&gt;，定义文本的时候带上名字空间参数：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;```cpp
// #define NSLOCTEXT(InNamespace, InKey, InTextLiteral)&lt;/p&gt;
&lt;p&gt;NSLOCTEXT(&#34;EditorPlusTools&#34;, &#34;Key&#34;, &#34;Content&#34;);
```&lt;/p&gt;
&lt;p&gt;UE 工具通过查找宏 &lt;code&gt;LOCTEXT&lt;/code&gt; 和 &lt;code&gt;NSLOCTEXT&lt;/code&gt; 的出现来收集出所有需要翻译的文本。&lt;/p&gt;
&lt;h2&gt;使用工具翻译文本&lt;/h2&gt;
&lt;p&gt;假设我们有如下代码定义文本：&lt;/p&gt;
&lt;p&gt;```cpp&lt;/p&gt;
&lt;h1&gt;define LOCTEXT_NAMESPACE &#34;EditorPlusTools&#34;&lt;/h1&gt;
&lt;p&gt;// register path node loctext
FEditorPlusPath::GetNodeByPath(&#34;/MenuTest&#34;)-&amp;gt;SetFriendlyName(LOCTEXT(&#34;MenuTest&#34;, &#34;MenuTest&#34;))-&amp;gt;SetFriendlyTips(LOCTEXT(&#34;MenuTestTips&#34;, &#34;MenuTestTips&#34;));
FEditorPlusPath::GetNodeByPath(&#34;/MenuTest/&lt;SubMenu&gt;SubMenu1&#34;)-&amp;gt;SetFriendlyName(LOCTEXT(&#34;SubMenu1&#34;, &#34;SubMenu1&#34;))-&amp;gt;SetFriendlyTips(LOCTEXT(&#34;SubMenu1Tips&#34;, &#34;SubMenu1Tips&#34;));
FEditorPlusPath::GetNodeByPath(&#34;/MenuTest/&lt;SubMenu&gt;SubMenu1/&lt;SubMenu&gt;SubMenu1&#34;)-&amp;gt;SetFriendlyName(LOCTEXT(&#34;SubMenu1&#34;, &#34;SubMenu1&#34;))-&amp;gt;SetFriendlyTips(LOCTEXT(&#34;SubMenu1Tips&#34;, &#34;SubMenu1Tips&#34;));
FEditorPlusPath::GetNodeByPath(&#34;/&lt;Hook&gt;Help/&lt;MenuBar&gt;MenuTest/&lt;SubMenu&gt;SubMenu1/&lt;Section&gt;Section1&#34;)-&amp;gt;SetFriendlyName(LOCTEXT(&#34;Section1&#34;, &#34;Section1&#34;))-&amp;gt;SetFriendlyTips(LOCTEXT(&#34;Section1Tips&#34;, &#34;Section1Tips&#34;));&lt;/p&gt;
&lt;h1&gt;undef LOCTEXT_NAMESPACE&lt;/h1&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;首先开启翻译工具，打开编辑器设置 &lt;code&gt;编辑 - 编辑器偏好设置&lt;/code&gt;，勾选 &lt;code&gt;通用 - 试验性功能 - Tools - 翻译选取器&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-localization/editor_enable_tool.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后打开翻译工具 &lt;code&gt;工具 - 本地化控制板&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-localization/editor_open_tool.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;新建一个目标（在默认的 Game 下面也行，新建一个是为了方便管理和移动这些翻译文本）&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-localization/tool_new_target.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;配置目标的参数，我这里名字改为 &lt;code&gt;EditorPlusTools&lt;/code&gt;，加载政策是 &lt;code&gt;编辑器&lt;/code&gt;，从文本收集，并加上插件目录，目标依赖性是 &lt;code&gt;Engine, Editor&lt;/code&gt;，其他配置保持不变：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-localization/tool_target_config.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;添加语系，保证有中文（简体）和英文两个语系，确认鼠标放在语言名字上分别显示 &lt;code&gt;zh-Hans&lt;/code&gt; 和 &lt;code&gt;en&lt;/code&gt;，并选中英语（因为我们代码里面是用英文定义的文本，我们这里需要收集这些英语文本）：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-localization/tool_target_lang.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;点击收集文本：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-localization/tool_target_collect.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;会弹出收集进度框，等待收集成功，会显示绿色对钩：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-localization/tool_target_collected.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;关掉收集进度框，回到翻译工具可以看到英文一行有显示收集到的数量，本身英文的我们不需要翻译，点开中文一行的翻译按钮：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-localization/tool_go_trans.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;打开后我们可以看到未翻译一栏有内容，在英文文本的右边一栏输入翻译后的内容，翻译内容都完成之后，保存退出窗口：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-localization/tool_trans.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;点击统计字数，结束后能看到中文一栏显示了翻译的数量：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-localization/tool_count.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后编译文本：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-localization/tool_build.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;翻译的数据会放在 &lt;code&gt;Content\Localization\EditorPlusTools&lt;/code&gt; 里面，每种语言一个文件夹，在 zh-Hans 里面能看到两个文件，&lt;code&gt;.archive&lt;/code&gt; 是收集和翻译的文本，&lt;code&gt;.locres&lt;/code&gt; 则是编译之后的数据：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-localization/tool_ret.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-localization/tool_ret2.png&#34;&gt;&lt;/p&gt;
&lt;h2&gt;翻译好的文本放入插件目录中&lt;/h2&gt;
&lt;p&gt;我们上面给插件生成的翻译文本放在了项目目录下面，我们需要把这些文本移动到插件里面，方便随着插件一起发布。&lt;/p&gt;
&lt;p&gt;把 &lt;code&gt;Content\Localization\EditorPlusTools&lt;/code&gt; 目录移动到插件目录 Content 下面，我这里是 &lt;code&gt;Plugins\UE.EditorPlus\Content\Localization\EditorPlusTools&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;修改项目的配置文件 &lt;code&gt;DefaultEditor.ini&lt;/code&gt;，加上新路径：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ini
[Internationalization]
+LocalizationPaths=%GAMEDIR%Plugins/UE.EditorPlus/Content/Localization/EditorPlusTools&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样，其他项目拿到插件后，只要修改 &lt;code&gt;DefaultEditor.ini&lt;/code&gt; 则可以直接使用翻译文本，不需要重新配置翻译。&lt;/p&gt;
&lt;h2&gt;注意事项&lt;/h2&gt;
&lt;p&gt;在生成翻译数据的过程中，遇到过一些问题，以下总结出来注意的事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码里面定义文本必须要用宏 &lt;code&gt;LOCTEXT&lt;/code&gt; 和 &lt;code&gt;NSLOCTEXT&lt;/code&gt;，文本需要是字符串常量，这样 UE 才是收集出来。&lt;/li&gt;
&lt;li&gt;翻译目标名字不能带有符号 &lt;code&gt;.&lt;/code&gt;，&lt;code&gt;Content\Localiztion\&lt;/code&gt; 下的目录名字不能带有 &lt;code&gt;.&lt;/code&gt;，UE 只会截取 &lt;code&gt;.&lt;/code&gt; 前面的名字。会导致 UE 在读取翻译文本的时候，由于名字错误，读取失败。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于编辑器插件，需要判断如果是命令行模式 &lt;code&gt;IsRunningCommandlet()&lt;/code&gt; 则不生成菜单和 SlateUI ，因为命令行模式下没有 Slate 模块，会导致收集文本的时候报错 &lt;code&gt;Assertion failed: CurrentApplication.IsValid()&lt;/code&gt;。如果你也遇到类似的报错，可以尝试加上这个判断。具体报错信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Assertion failed: CurrentApplication.IsValid() [File:E:\UE\ue5.3_git\Engine\Source\Runtime\Slate\Public\Framework\Application\SlateApplication.h] [Line: 255] &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2023-ue-localization/tool_error.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/ue-%E8%AE%BE%E7%BD%AE%E6%9C%AC%E5%9C%B0%E5%8C%96%E5%A4%9A%E8%AF%AD%E8%A8%80/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Thu, 28 Dec 2023 18:06:38 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/ue-%E8%AE%BE%E7%BD%AE%E6%9C%AC%E5%9C%B0%E5%8C%96%E5%A4%9A%E8%AF%AD%E8%A8%80/</guid>
      
    </item>
    
    <item>
      <title>UE 使用路径形式扩展菜单</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;UE 使用路径形式扩展菜单&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;记录如何在 UE 中实现路径形式扩展菜单&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果不熟悉 UE 扩展菜单，建议先简单看下：&lt;a href=&#34;ue-扩展编辑器菜单.md&#34;&gt;UE 扩展编辑器菜单&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文代码基于插件：&lt;a href=&#34;https://github.com/disenone/UE.EditorPlus&#34;&gt;UE.EditorPlus&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;节点管理&lt;/h2&gt;
&lt;p&gt;把菜单按照树的结构来管理，父节点可以包含孩子：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
class EDITORPLUS_API FEditorPlusMenuBase: public TSharedFromThis&amp;lt;FEditorPlusMenuBase&amp;gt;
{
protected:
    // sub menus
    TArray&amp;lt;TSharedRef&amp;lt;FEditorPlusMenuBase&amp;gt;&amp;gt; Children;
}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在创建父节点的同时创建子节点：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
void FEditorPlusMenuBase::Register(FMenuBuilder&amp;amp; MenuBuilder)
{
    for (const auto Menu: Children)
    {
        Menu-&amp;gt;Register(MenuBuilder);
    }
}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当然每个节点的具体创建行为会有点不同，覆写虚函数来实现：&lt;/p&gt;
&lt;p&gt;```cpp
// Menubar
void FEditorPlusMenuBar::Register(FMenuBarBuilder&amp;amp; MenuBarBuilder)
{
    MenuBarBuilder.AddPullDownMenu(
        GetFriendlyName(),
        GetFriendlyTips(),
        // Delegate to call Register
        FEditorPlusMenuManager::GetDelegate&lt;FNewMenuDelegate&gt;(GetUniqueId()),     &lt;br&gt;
        Hook);
}&lt;/p&gt;
&lt;p&gt;// Section
void FEditorPlusSection::Register(FMenuBuilder&amp;amp; MenuBuilder)
{
    MenuBuilder.BeginSection(Hook, GetFriendlyName());
    FEditorPlusMenuBase::Register(MenuBuilder);
    MenuBuilder.EndSection();
}&lt;/p&gt;
&lt;p&gt;// Separator
void FEditorPlusSeparator::Register(FMenuBuilder&amp;amp; MenuBuilder)
{
    MenuBuilder.AddMenuSeparator(Hook);
    FEditorPlusMenuBase::Register(MenuBuilder);
}&lt;/p&gt;
&lt;p&gt;// SubMenu
void FEditorPlusSubMenu::Register(FMenuBuilder&amp;amp; MenuBuilder)
{
    MenuBuilder.AddSubMenu(
        GetFriendlyName(),
        GetFriendlyTips(),
        FNewMenuDelegate::CreateSP(this, &amp;amp;FEditorPlusSubMenu::MakeSubMenu),
        false,
        FSlateIcon(),
        true,
        Hook
    );
}&lt;/p&gt;
&lt;p&gt;// Command
void FEditorPlusCommand::Register(FMenuBuilder&amp;amp; MenuBuilder)
{
    MenuBuilder.AddMenuEntry(
        CommandInfo-&amp;gt;Label, CommandInfo-&amp;gt;Tips, CommandInfo-&amp;gt;Icon,
        CommandInfo-&amp;gt;ExecuteAction, CommandInfo-&amp;gt;Hook, CommandInfo-&amp;gt;Type);
}&lt;/p&gt;
&lt;p&gt;// ......
```&lt;/p&gt;
&lt;h2&gt;通过路径生成节点&lt;/h2&gt;
&lt;p&gt;按照树形结构组织好菜单，路径格式就可以定义一条菜单的树形结构：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
&#34;/&amp;lt;Hook&amp;gt;Help/&amp;lt;MenuBar&amp;gt;BarTest/&amp;lt;SubMenu&amp;gt;SubTest/&amp;lt;Command&amp;gt;Action&#34;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以上路径即可以定义一系列菜单的创建：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Hook&amp;gt;Help&lt;/code&gt;：位置在 Hook 名字为 Help 的菜单后&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;MenuBar&amp;gt;BarTest&lt;/code&gt;：创建类型 MenuBar 的菜单，名字为 BarTest&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;SubMenu&amp;gt;SubTest&lt;/code&gt;：创建子节点，类型 SubMenu, 名字 SubTest&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Command&amp;gt;Action&lt;/code&gt;：最后创建一个命令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接口调用形式可以很简洁：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
const FString Path = &#34;/&amp;lt;Hook&amp;gt;Help/&amp;lt;MenuBar&amp;gt;BarTest/&amp;lt;SubMenu&amp;gt;SubTest/&amp;lt;Command&amp;gt;Action&#34;;
FEditorPlusPath::RegisterPathAction(
    Path, 
    FExecuteAction::CreateLambda([]
    {
        // do action
    })
);&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;自定义形式生成节点&lt;/h2&gt;
&lt;p&gt;我们依然保留了笨重的方式来创建菜单，笨重的方式可以允许有更详细的设置，代码的组织形式跟 UE 的 SlateUI 写法有些像：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
EP_NEW_MENU(FEditorPlusMenuBar)(&#34;BarTest&#34;)
-&amp;gt;RegisterPath()
-&amp;gt;Content({
    EP_NEW_MENU(FEditorPlusSubMenu)(&#34;SubTest&#34;)
    -&amp;gt;Content({
        EP_NEW_MENU(FEditorPlusCommand)(&#34;Action&#34;)
        -&amp;gt;BindAction(FExecuteAction::CreateLambda([]
            {
                // do action
            })),
    })
});&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;混合形式&lt;/h2&gt;
&lt;p&gt;当然，本身路径形式和自定义生成的菜单，都是相同的，它们之间可以混用，有很大的灵活性：&lt;/p&gt;
&lt;p&gt;```cpp
FEditorPlusPath::RegisterPath(
    &#34;/&lt;MenuBar&gt;BarTest/&lt;SubMenu&gt;SubMenu/&lt;Command&gt;Action1&#34;, 
    EP_NEW_MENU(FEditorPlusCommand)(&#34;Action1&#34;)
    -&amp;gt;BindAction(FExecuteAction::CreateLambda([]
        {
            // do action
        })),
);&lt;/p&gt;
&lt;p&gt;FEditorPlusPath::RegisterPath(
    &#34;/&lt;MenuBar&gt;BarTest/&lt;SubMenu&gt;SubMenu/&lt;Command&gt;Action2&#34;, 
    EP_NEW_MENU(FEditorPlusCommand)(&#34;Action2&#34;)
    -&amp;gt;BindAction(FExecuteAction::CreateLambda([]
        {
            // do action
        })),
);
```&lt;/p&gt;
&lt;p&gt;多个地方定义的菜单，会合并到同一个树形结构中，名字相同的节点会认为是同一个节点。换言之，路径是唯一的，同一个路径可以唯一确定一个菜单节点。
于是我们也可以把节点找出来，重新做一些设置和修改：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
// set Name and Tips
FEditorPlusPath::GetNodeByPath(&#34;/&amp;lt;MenuBar&amp;gt;BarTest&#34;)-&amp;gt;SetFriendlyName(LOCTEXT(&#34;MenuTest&#34;, &#34;MenuTest&#34;))-&amp;gt;SetFriendlyTips(LOCTEXT(&#34;MenuTestTips&#34;, &#34;MenuTestTips&#34;));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/ue-%E4%BD%BF%E7%94%A8%E8%B7%AF%E5%BE%84%E5%BD%A2%E5%BC%8F%E6%89%A9%E5%B1%95%E8%8F%9C%E5%8D%95/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Thu, 28 Dec 2023 12:51:24 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/ue-%E4%BD%BF%E7%94%A8%E8%B7%AF%E5%BE%84%E5%BD%A2%E5%BC%8F%E6%89%A9%E5%B1%95%E8%8F%9C%E5%8D%95/</guid>
      
    </item>
    
    <item>
      <title>Unity画深度图(Depth Map)和边缘检测(Edge Detection)</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;Unity画深度图(Depth Map)和边缘检测(Edge Detection)&#34; /&gt;&lt;/p&gt;
&lt;p&gt;刚接触Unity没多久，对Unity的ShaderLab一直很感兴趣，感觉它可以快速地实现各种各样的显示效果，很有意思。嘛，作为一个门都还没入的人，我就来搞一搞深度图和边缘检测吧。&lt;/p&gt;
&lt;h1&gt;小地图设置&lt;/h1&gt;
&lt;p&gt;因为我只是做了一个小雏形，所以我不打算详细地讲如何去在场景上画小地图，大致上说我做了以下一些事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取场景的 bounding box，这个在设置相机的参数和位置时有用&lt;/li&gt;
&lt;li&gt;把小地图相机配置成正交投影，根据 bounding box 设置相机的近平面和远平面&lt;/li&gt;
&lt;li&gt;为该相机增加一个人物目标，目标会显示在地图的中心&lt;/li&gt;
&lt;li&gt;每次更新相机的位置，根据目标的位置，还有场景的最大 y 值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体的配置可以参考后面给出的代码。&lt;/p&gt;
&lt;h1&gt;获取深度图&lt;/h1&gt;
&lt;h2&gt;depthTextureMode 来获取深度图&lt;/h2&gt;
&lt;p&gt;相机自己可以保存DepthBuffer或者一个DepthNormalBuffer(可用来做边缘检测)，只需要设置&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
Camera.depthTextureMode = DepthTextureMode.DepthNormals;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后在Shader里面引用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
sampler2D _CameraDepthNormalsTexture;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;就可以了，具体的做法可以参考我后面给出的代码。关于在Z-Buffer里面保存的深度值跟真实世界的深度的关系可以参考这两篇文章：
&lt;a href=&#34;http://www.sjbaker.org/steve/omniv/love_your_z_buffer.html&#34;&gt;Learning to Love your Z-buffer&lt;/a&gt;,&lt;a href=&#34;http://www.humus.name/temp/Linearize%20depth.txt&#34;&gt;Linearize depth&lt;/a&gt;。另外 Unity 也提供了一些函数来计算深度: &lt;code&gt;Linear01Depth&lt;/code&gt;, &lt;code&gt;LinearEyeDepth&lt;/code&gt; 等。&lt;/p&gt;
&lt;p&gt;这不是我这里讨论的重点，我想说的是，本来我的相机设置为正交投影，深度应该是线性的，但我测试出来却不是线性。然后我用上面链接介绍的方法来计算真实世界的深度，也一直都不正确，以至于一直计算不出真实的线性深度，不知道是Unity的Z_Buffer的问题还是什么，那位朋友知道的请教教我。当然，如果不需要真实的深度值，单单是比较深度的大小之类的，用上面的方法就足够了，而且很简单。但是对于我这里来说，我想要把真实深度映射为颜色值，需要获得真实的线性的深度值（虽然也是[0, 1]），我只好用另外一种用 RenderWithShader 方法了。&lt;/p&gt;
&lt;h2&gt;RenderWithShader 来获取深度图&lt;/h2&gt;
&lt;p&gt;这种方法其实就是用Unity Reference里面的一个例子：&lt;a href=&#34;http://docs.unity3d.com/Documentation/Components/SL-ShaderReplacement.html&#34;&gt;Rendering with Replaced Shaders&lt;/a&gt;。需要理解的是，&lt;code&gt;RenderWithShader&lt;/code&gt;会把场景中的相应的Mesh画一遍。&lt;/p&gt;
&lt;p&gt;创建一个 Shader :&lt;/p&gt;
&lt;p&gt;```glsl
Shader &#34;Custom/DepthByReplaceShader&#34; 
{
SubShader 
{
    Tags { &#34;RenderType&#34;=&#34;Opaque&#34; }
    Pass {
        Fog { Mode Off }
        CGPROGRAM
        #pragma vertex vert
        #pragma fragment frag
        #include &#34;UnityCG.cginc&#34;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    struct v2f {
        float4 pos : SV_POSITION;
        float2 depth : TEXCOORD0;
    };

    v2f vert (appdata_base v) {
        v2f o;
        o.pos = mul (UNITY_MATRIX_MVP, v.vertex);
        UNITY_TRANSFER_DEPTH(o.depth);
        return o;
    }

    float4 frag(v2f i) : COLOR {
        //UNITY_OUTPUT_DEPTH(i.depth);
        float d = i.depth.x/i.depth.y;
        return float4(d, d, d, 1);
    }
    ENDCG
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
}
```&lt;/p&gt;
&lt;p&gt;为你的小地图相机(没有的话创建之)添加一个脚本，把相机配置成正交投影等，并且在 &lt;code&gt;Update()&lt;/code&gt; 里面使用这个 Shader 来渲染场景：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
camera.targetTexture = depthTexture;
camera.RenderWithShader(depthShader, &#34;&#34;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;渲染的结果就会保存在 &lt;code&gt;depthTexture&lt;/code&gt;里面，很简单吧。&lt;/p&gt;
&lt;h2&gt;把深度映射成颜色&lt;/h2&gt;
&lt;p&gt;要完成这个工作，首先需要一张颜色图，这张图可以用 Matlab 很简单地生成，例如我用的是 Matlab 里面的 jet 图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2014-3-27-unity-depth-minimap/jet.png&#34;&gt;{ width=&#34;200&#34; }&lt;/p&gt;
&lt;p&gt;把这张图放到项目目录 &lt;code&gt;Assets\Resources&lt;/code&gt; 里面，就可以在程序中读取：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
colorMap = Resources.Load&amp;lt;Texture2D&amp;gt;(&#34;colormap&#34;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，这张图片的 &lt;code&gt;Wrap Mode&lt;/code&gt; 应该是 &lt;code&gt;Clamp&lt;/code&gt;，防止在两边缘的颜色值之间进行插值。&lt;/p&gt;
&lt;p&gt;之后就需要使用 &lt;code&gt;OnRenderImage&lt;/code&gt; 和 &lt;code&gt;Graphics.Blit&lt;/code&gt; 函数，函数的原型为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
void OnRenderImage(RenderTexture src, RenderTexture dst);
static void Blit(Texture source, RenderTexture dest, Material mat, int pass = -1);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个函数的 src 是相机渲染的结果，dst 是处理后传回给相机的结果，因此这个函数通常是用来在相机渲染完成后做图片的一些效果，例如我们这里的对深度做颜色映射，还有边缘检测。做法就是在&lt;code&gt;OnRenderImage&lt;/code&gt;中调用&lt;code&gt;Graphics.Blit&lt;/code&gt;，传入特定的&lt;code&gt;Material&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
depthEdgeMaterial.SetTexture(&#34;_DepthTex&#34;, src);
Graphics.Blit(src, dst, depthEdgeMaterial);
return;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;Graphics.Blit&lt;/code&gt;实际上做了这样一件事情：在相机前面画一个跟屏幕大小一样的平面，把&lt;code&gt;src&lt;/code&gt;作为这个平面的&lt;code&gt;_MainTex&lt;/code&gt;传进&lt;code&gt;Shader&lt;/code&gt;中，然后把结果放到&lt;code&gt;dst&lt;/code&gt;里面，而不是把实际场景中的Mesh重新画一遍。&lt;/p&gt;
&lt;p&gt;对颜色映射其实就是把深度 [0, 1] 看成图片的 uv，因为我想距离相机近的为红色，所以我对深度取了反：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;glsl
half4 color = tex2D(_ColorMap, float2(saturate(1-depth), 0.5));&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;边缘检测&lt;/h1&gt;
&lt;p&gt;边缘检测需要用到了相机自己的 &lt;code&gt;_CameraDepthNormalsTexture&lt;/code&gt;，主要是用 Normal 的值，深度还是用之前计算出来的。在 &lt;code&gt;_CameraDepthNormalsTexture&lt;/code&gt; 的每个像素 (x, y, z, w) 中，(x, y) 是法向，(z, w)是深度，法向是用了一种方法来存放的，有兴趣可以自己搜索。&lt;/p&gt;
&lt;p&gt;代码是参考了 Unity 自带的 Image Effect 里面的边缘检测，需要做的事情就是，比较当前像素的法向深度和邻近像素的差别，足够大我们就认为存在边缘：&lt;/p&gt;
&lt;p&gt;```c#
inline half CheckSame (half2 centerNormal, half2 sampleNormal, float centerDepth, float sampleDepth)
{
    // difference in normals
    // do not bother decoding normals - there&#39;s no need here
    half2 diff = abs(centerNormal - sampleNormal);
    half isSameNormal = (diff.x + diff.y) &amp;lt; 0.5;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// difference in depth
float zdiff = abs(centerDepth-sampleDepth);
// scale the required threshold by the distance
half isSameDepth = (zdiff &amp;lt; 0.09 * centerDepth) || (centerDepth &amp;lt; 0.1);

// return:
// 1 - if normals and depth are similar enough
// 0 - otherwise
return isSameNormal * isSameDepth;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;完整的 Shader 如下：&lt;/p&gt;
&lt;p&gt;```glsl
Shader &#34;Custom/DepthColorEdge&#34; {&lt;/p&gt;
&lt;p&gt;Properties 
{
    _DepthTex (&#34;Depth Tex&#34;, 2D) = &#34;white&#34; {}
    _ColorMap (&#34;Color Map&#34;, 2D) = &#34;white&#34; {}
}
    SubShader 
    {
        Tags { &#34;RenderType&#34;=&#34;Opaque&#34; }
        LOD 200
        Pass
        {
            ZTest Always Cull Off ZWrite Off
            Fog { Mode off }
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include &#34;UnityCG.cginc&#34;
            sampler2D _CameraDepthNormalsTexture;
            sampler2D _DepthTex;
            uniform float4 _DepthTex_TexelSize;
            sampler2D _ColorMap;
            float _ZNear;
            float _ZFar;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        struct v2f 
        {
            float4 pos : SV_POSITION;
            float2 uv[3] : TEXCOORD0;
        };

        v2f vert (appdata_base v)
        {
            v2f o;
            o.pos = mul (UNITY_MATRIX_MVP, v.vertex);
            o.uv[0] = MultiplyUV( UNITY_MATRIX_TEXTURE0, v.texcoord );
            o.uv[1] = o.uv[0] + float2(-_DepthTex_TexelSize.x, -_DepthTex_TexelSize.y);
            o.uv[2] = o.uv[0] + float2(+_DepthTex_TexelSize.x, -_DepthTex_TexelSize.y);
            return o;
        }


        inline half CheckSame (half2 centerNormal, half2 sampleNormal, float centerDepth, float sampleDepth)
        {
            // difference in normals
            // do not bother decoding normals - there&#39;s no need here
            half2 diff = abs(centerNormal - sampleNormal);
            half isSameNormal = (diff.x + diff.y) &amp;lt; 0.5;

            // difference in depth
            float zdiff = abs(centerDepth-sampleDepth);
            // scale the required threshold by the distance
            half isSameDepth = (zdiff &amp;lt; 0.09 * centerDepth) || (centerDepth &amp;lt; 0.1);

            // return:
            // 1 - if normals and depth are similar enough
            // 0 - otherwise
            return isSameNormal * isSameDepth;
        }

        half4 frag(v2f i) : COLOR 
        {
            // get color based on depth
            float depth = tex2D (_DepthTex, i.uv[0]).r;
            half4 color = tex2D(_ColorMap, float2(saturate(1-depth), 0.5));

            // detect normal diff
            half2 centerNormal = tex2D(_CameraDepthNormalsTexture, i.uv[0]).xy;
            half2 sampleNormal1 = tex2D (_CameraDepthNormalsTexture, i.uv[1]).xy;
            half2 sampleNormal2 = tex2D (_CameraDepthNormalsTexture, i.uv[2]).xy;
            float sampleDepth1 = tex2D (_DepthTex, i.uv[1]).r;
            float sampleDepth2 = tex2D (_DepthTex, i.uv[2]).r;
            color *= CheckSame(centerNormal, sampleNormal1, depth, sampleDepth1);
            color *= CheckSame(centerNormal, sampleNormal2, depth, sampleDepth2);

            return color;
        }
        ENDCG
    }

}
FallBack &#34;Diffuse&#34;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;结果类似于这个：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2014-3-27-unity-depth-minimap/topview.png&#34;&gt;{ width=&#34;200&#34; }&lt;/p&gt;
&lt;h1&gt;混合真实世界图像&lt;/h1&gt;
&lt;p&gt;单单是深度的颜色图可能有点无趣，那么我们可以混合上真实场景的颜色图，只需要再建一个 Shader，传入前面的图像和相机的真实图像，在 &lt;code&gt;OnRenderImage&lt;/code&gt; 中进行混合：&lt;/p&gt;
&lt;p&gt;```glsl
Shader &#34;Custom/ColorMixDepth&#34; {
    Properties {
        _MainTex (&#34;Base (RGBA)&#34;, 2D) = &#34;white&#34; {}
        _DepthTex (&#34;Depth (RGBA)&#34;, 2D) = &#34;white&#34; {}
    }
    SubShader {
        Tags { &#34;RenderType&#34;=&#34;Opaque&#34; }
        LOD 200&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    CGPROGRAM
    #pragma surface surf Lambert

    sampler2D _MainTex;
    sampler2D _DepthTex;

    struct Input {
        float2 uv_MainTex;
        float2 uv_DepthTex;
    };

    void surf (Input IN, inout SurfaceOutput o) {
        half4 c = tex2D (_MainTex, IN.uv_MainTex);
        half4 d = tex2D (_DepthTex, IN.uv_DepthTex);
        //d = d.x == 1? 0 : d;
        o.Albedo = c.rgb*0.1 + d.rgb*0.9;
        o.Alpha = 1;
    }
    ENDCG
} 
FallBack &#34;Diffuse&#34;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
void OnRenderImage(RenderTexture src, RenderTexture dst)
{
    // if now rendering depth map
    if (isRenderDepth)
    {
        depthEdgeMaterial.SetTexture(&#34;_DepthTex&#34;, src);
        if(isUseColorMap)
            Graphics.Blit(src, dst, depthEdgeMaterial);
        else
            Graphics.Blit(src, dst);
        return;
    }
    // else rendering real color scene, mix the real color with depth map
    else
    {
        mixMaterial.SetTexture(&#34;_MainTex&#34;, src);
        mixMaterial.SetTexture(&#34;_DepthTex&#34;, depthTexture);
        Graphics.Blit(src, dst, mixMaterial);
        ReleaseTexture();
    }
}&lt;/code&gt;
上面的代码就是完成这个工作，需要理解的是，我们在调用 &lt;code&gt;RenderWithShader&lt;/code&gt; 的时候，&lt;code&gt;OnRenderImage&lt;/code&gt; 也会被调用，也就是这个函数被调用了两次，而两次调用需要完成的功能是不同的，所以我这里用一个变量来指示当前的渲染状态是做深度图还是混合。&lt;/p&gt;
&lt;h1&gt;完整的代码&lt;/h1&gt;
&lt;p&gt;代码文件有点多，就放到这里了&lt;a href=&#34;assets/img/2014-3-27-unity-depth-minimap/2014-3-27-unity-depth-minimap.zip&#34;&gt;depth-minimap&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/unity-Unity%E7%94%BB%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%92%8C%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Mon, 04 Dec 2023 15:27:10 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/unity-Unity%E7%94%BB%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%92%8C%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</guid>
      
    </item>
    
    <item>
      <title>编写 Windows 下的 Memory Leak Detector</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;编写 Windows 下的 Memory Leak Detector&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://img.shields.io/badge/windows-10-blue.svg&#34;&gt;{:style=&#34;display: inline-block&#34;}
&lt;img alt=&#34;&#34; src=&#34;https://img.shields.io/badge/vs-2015-68217A.svg&#34;&gt;{:style=&#34;display: inline-block&#34;}&lt;/p&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;这一阵子读完了《程序员的自我修养：链接、装载与库》（后面简称《链接》），收获良多，寻思着能不能做些相关的小代码出来。刚好知道 Windows 下有个内存泄露检测工具 &lt;a href=&#34;https://vld.codeplex.com/&#34;&gt;Visual Leak Detector&lt;/a&gt;，这个工具是通过替换 Windows 下负责内存管理的 dll 接口来实现跟踪内存分配释放。所以决定参考 Visual Leak Detector （后面简称 VLD）来做个简易的内存泄露检测工具，理解 dll 链接。&lt;/p&gt;
&lt;h2&gt;预备知识&lt;/h2&gt;
&lt;p&gt;《链接》一书详细解释了在 Linux 和 Windows 下可执行文件的链接原理，其中 Windows 下的可执行文件格式叫做 PE（Portable Executable）文件。而 DLL 文件的解释是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DLL 即动态链接库（Dynamic-Link Library）的缩写，它相当于 Linux 下的共享对象。Windows 系统中大量采用了这种 DLL 机制，甚至包括 Windows 的内核的结构都很大程度依赖于 DLL 机制。Windows 下的 DLL 文件和 EXE 文件实际上是一个概念，它们都是有 PE 格式的二进制文件，稍微有些不同的是 PE 文件头部中有个符号位表示该文件是 EXE 或是 DLL，而 DLL 文件的扩展名不一定是 .dll，也有可能是别的比如 .ocx（OCX控件）或是 .CPL（控制面板程序）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还有比如 Python 的扩展文件 .pyd。而 DLL 中有关我们这里内存泄露检测的概念是&lt;strong&gt;符号导出导入表&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;符号导出表&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;当一个 PE 需要将一些函数或变量提供给其他 PE 文件使用时，我们把这种行为叫做&lt;strong&gt;符号导出（Symbol Exporting）&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单地理解，在 Windows PE 中，所有导出的符号被集中存放在被称作&lt;strong&gt;导出表（Export Table）&lt;/strong&gt;的结构中，它提供了一个符号名与符号地址的映射关系。需要导出的符号需要加上修饰符&lt;code&gt;__declspec(dllexport)&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;符号导入表&lt;/h4&gt;
&lt;p&gt;符号导入表就是我们这里的关键概念，它跟符号导出表相对应，先来看概念解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果我们在某个程序中使用到了来自 DLL 的函数或者变量，那么我们就把这种行为叫做&lt;strong&gt;符号导入（Symbol Importing）&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Windows PE 中保存模块需要导入的变量和函数的符号以及所在的模块等信息的结构叫做&lt;strong&gt;导入表（Import Table）&lt;/strong&gt;。Windows 加载 PE 文件时，其中一个要做的事情就是将所有需要导入的函数地址确定并将导入表中的元素调整到正确的地址，使得运行时候，程序通过查询导入表来定位实际函数的地址，并进行调用。导入表中最重要的结构是&lt;strong&gt;导入地址数组（Import Address Table，IAT）&lt;/strong&gt;，里面存放的就是导入的函数实际地址。&lt;/p&gt;
&lt;p&gt;看到这里是不是已经猜到我们要实现的内存泄露检测是怎么做 :)。没错就是 hack 导入表，具体地说就是把需要检测的模块的导入表中，关于内存申请和释放的函数的地址改成我们自定义的函数，那么我们就可以知道模块每一次的内存申请和释放情况了，可以尽情做我们想做的检测。&lt;/p&gt;
&lt;p&gt;有关 DLL 链接的更详细知识可以自行查阅《链接》或者其他资料。&lt;/p&gt;
&lt;h2&gt;Memory Leak Detector&lt;/h2&gt;
&lt;p&gt;知道了原理，下面就是根据原理来实现内存泄露检测。下面的讲解将基于我自己的实现，我放在了我的 Github 上：&lt;a href=&#34;https://github.com/disenone/LeakDetector&#34;&gt;LeakDetector&lt;/a&gt;。&lt;/p&gt;
&lt;h4&gt;替换函数&lt;/h4&gt;
&lt;p&gt;先来看关键的函数，位于&lt;a href=&#34;https://github.com/disenone/LeakDetector/blob/master/LeakDetector/RealDetector.cpp&#34;&gt;RealDetector.cpp&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;```cpp linenums=&#34;1&#34;
/&lt;em&gt; 把 importModule 中的 IAT (Import Address Table) 的某个函数替换成别的函数，
 * importModule 会调用到别的 module 的函数，这个函数就是需要 patch 的函数，
 * 我们要做的就是让 import module 改成调用我们自定义的函数。
 *
 * - importModule (IN): 要处理的 module，这个 module 调用到别的 module 的需要 patch 的函数
 *
 * - exportModuleName (IN): 需要 patch 的函数来自的 module 名字
 *
 * - exportModulePath (IN): export module 所在的路径，首先尝试用 path 来加载 export module，
 *          如果失败，则用 name 来加载
 * - importName (IN): 函数名
 *
 * - replacement (IN): 替代的函数指针
 *
 * Return Valur: 成功 true，否则 false
&lt;/em&gt;/
bool RealDetector::patchImport(
    HMODULE importModule,
    LPCSTR exportModuleName,
    LPCSTR exportModulePath,
    LPCSTR importName,
    LPCVOID replacement)
{
    HMODULE                  exportmodule;
    IMAGE_THUNK_DATA        &lt;em&gt;iate;
    IMAGE_IMPORT_DESCRIPTOR &lt;/em&gt;idte;
    FARPROC                  import;
    DWORD                    protect;
    IMAGE_SECTION_HEADER    *section;
    ULONG                    size;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;assert(exportModuleName != NULL);

idte = (IMAGE_IMPORT_DESCRIPTOR*)ImageDirectoryEntryToDataEx((PVOID)importModule, 
    TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &amp;amp;size, &amp;amp;section);
if (idte == NULL) 
{
    logMessage(&#34;patchImport failed: idte == NULL\n&#34;);
    return false;
}
while (idte-&amp;gt;FirstThunk != 0x0) 
{
    if (strcmp((PCHAR)R2VA(importModule, idte-&amp;gt;Name), exportModuleName) == 0) 
    {
        break;
    }
    idte++;
}
if (idte-&amp;gt;FirstThunk == 0x0) 
{
    logMessage(&#34;patchImport failed: idte-&amp;gt;FirstThunk == 0x0\n&#34;);
    return false;
}

if (exportModulePath != NULL) 
{
    exportmodule = GetModuleHandleA(exportModulePath);
}
else 
{
    exportmodule = GetModuleHandleA(exportModuleName);
}
assert(exportmodule != NULL);
import = GetProcAddress(exportmodule, importName);
assert(import != NULL);

iate = (IMAGE_THUNK_DATA*)R2VA(importModule, idte-&amp;gt;FirstThunk);
while (iate-&amp;gt;u1.Function != 0x0) 
{
    if (iate-&amp;gt;u1.Function == (DWORD_PTR)import) 
    {
        VirtualProtect(&amp;amp;iate-&amp;gt;u1.Function, sizeof(iate-&amp;gt;u1.Function), 
            PAGE_READWRITE, &amp;amp;protect);
        iate-&amp;gt;u1.Function = (DWORD_PTR)replacement;
        VirtualProtect(&amp;amp;iate-&amp;gt;u1.Function, sizeof(iate-&amp;gt;u1.Function), 
            protect, &amp;amp;protect);
        return true;
    }
    iate++;
}

return false;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;我们来分析一下这个函数，就像注释所说的，这个函数实现的功能就是把 IAT 里面的某函数的地址改成另一个函数的地址。先来看第 34-35 行：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
idte = (IMAGE_IMPORT_DESCRIPTOR*)ImageDirectoryEntryToDataEx((PVOID)importModule, 
    TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &amp;amp;size, &amp;amp;section);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ImageDirectoryEntryToDataEx&lt;/code&gt; 函数可以返回模块的文件头的某结构的地址，&lt;code&gt;IMAGE_DIRECTORY_ENTRY_IMPORT&lt;/code&gt; 指定要导入表结构，所以返回的 &lt;code&gt;idte&lt;/code&gt; 就指向了模块导入表了。&lt;/p&gt;
&lt;p&gt;36-40 行就是检查 &lt;code&gt;idte&lt;/code&gt; 有效。41 行 &lt;code&gt;idte-&amp;gt;FirstThunk&lt;/code&gt; 指向的就是实际的 IAT 了。所以 41-48 行就是在根据模块名字查找需要替换的函数的模块，如果找不到，说明没有调用到该模块的函数，只能提示错误并返回。&lt;/p&gt;
&lt;p&gt;找到模块后，自然地，我们需要找到替换的那个函数，55-62 行打开函数所属的模块，64 行找到函数地址。因为 IAT 没有保存名字，所以需要先根据原来的函数地址，定位到函数，再修改该函数地址，68-80 行就是在做这个事情。成功找到函数之后，就简单地把地址修改成 &lt;code&gt;replacement&lt;/code&gt; 的地址。&lt;/p&gt;
&lt;p&gt;至此，我们就成功地替换了 IAT 中的函数了。&lt;/p&gt;
&lt;h4&gt;模块和函数名字&lt;/h4&gt;
&lt;p&gt;虽然我们已经实现了替换 IAT 函数 &lt;code&gt;patchImport&lt;/code&gt;，但这个函数需要指定模块名字和函数名字呀，那我们怎么知道程序的内存分配和释放用了什么模块和函数呢？为了搞清楚这个问题，我们需要借助 Windows 下的工具 &lt;a href=&#34;http://www.dependencywalker.com/&#34;&gt;Dependency Walker&lt;/a&gt;。Visual Studio 下新建一个工程，在 &lt;code&gt;main&lt;/code&gt; 函数里面使用 &lt;code&gt;new&lt;/code&gt; 来申请内存，编译 Debug 版，之后使用 &lt;code&gt;depends.exe&lt;/code&gt; 来打开编译出来的 exe 文件，可以看到一下类似的界面（以我的工程 &lt;a href=&#34;https://github.com/disenone/LeakDetector/tree/master/LeakDetectorTest&#34;&gt;LeakDetectorTest&lt;/a&gt; 为例）：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2016-6-11-memory-leak-detector/depends.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到 LeakDetectorTest.exe 使用了 uscrtbased.dll 里面的 &lt;code&gt;malloc&lt;/code&gt; 和 &lt;code&gt;_free_dbg&lt;/code&gt; （没有在图中显示出来），这两个函数就是我们需要替换的函数了。要注意实际的模块函数名字可能跟你的 Windows 和 Visual Studio 版本有关，我的是 Windows 10 和 Visual Studio 2015，你需要做的就是用 depends.exe 看看实际调用的是什么函数。&lt;/p&gt;
&lt;h4&gt;分析调用栈&lt;/h4&gt;
&lt;p&gt;记录内存分配需要记录当时的调用栈信息，这里我不打算详细介绍 Windows 下如何拿到当前的调用栈信息，相关的函数是 &lt;code&gt;RtlCaptureStackBackTrace&lt;/code&gt;，网上有许多相关的资料，也可以看看我的代码里面的函数 &lt;a href=&#34;https://github.com/disenone/LeakDetector/blob/master/LeakDetector/RealDetector.cpp&#34;&gt;&lt;code&gt;printTrace&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;h4&gt;检测内存泄露&lt;/h4&gt;
&lt;p&gt;至此，我们已经把龙珠都收集全了，下面正式召唤神龙。&lt;/p&gt;
&lt;p&gt;我想做成可以局部检测内存泄露（这是跟 VLD 不同的地方，VLD 做的是全局的检测，并支持多线程）。所以我在实际替换函数的类&lt;code&gt;RealDetector&lt;/code&gt;上又封装了一层&lt;code&gt;LeakDetector&lt;/code&gt;，并把&lt;code&gt;LeakDetector&lt;/code&gt;的接口暴露给使用者。使用时只需构造&lt;code&gt;LeakDetector&lt;/code&gt;，即完成函数的替换并开始检测内存泄露，&lt;code&gt;LeakDetector&lt;/code&gt;析构时会恢复原来的函数，中止内存泄露检测，并打印内存泄露检测结果。&lt;/p&gt;
&lt;p&gt;用下面代码测试一下：&lt;/p&gt;
&lt;p&gt;```cpp&lt;/p&gt;
&lt;h1&gt;include &#34;LeakDetector.h&#34;&lt;/h1&gt;
&lt;h1&gt;include &lt;iostream&gt;&lt;/h1&gt;
&lt;p&gt;using namespace std;&lt;/p&gt;
&lt;p&gt;void new_some_mem()
{
    char&lt;em&gt; c = new char[12];
    int&lt;/em&gt; i = new int[4];
}&lt;/p&gt;
&lt;p&gt;int main()
{
    auto ld = LDTools::LeakDetector(&#34;LeakDetectorTest.exe&#34;);
    new_some_mem();
    return 0;
}&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;代码直接 &lt;code&gt;new&lt;/code&gt; 了一些内存出来，没有释放掉就直接退出，程序打印的结果：&lt;/p&gt;
&lt;p&gt;```
============== LeakDetector::start ===============
LeakDetector init success.
============== LeakDetector::stop ================
Memory Leak Detected: total 2&lt;/p&gt;
&lt;p&gt;Num 1:
    e:\program\github\leakdetector\leakdetector\realdetector.cpp (109): LeakDetector.dll!LDTools::RealDetector::_malloc() + 0x1c bytes
    f:\dd\vctools\crt\vcstartup\src\heap\new_scalar.cpp (19): LeakDetectorTest.exe!operator new() + 0x9 bytes
    f:\dd\vctools\crt\vcstartup\src\heap\new_array.cpp (15): LeakDetectorTest.exe!operator new&lt;a href=&#34;&#34;&gt;&lt;/a&gt; + 0x9 bytes
    e:\program\github\leakdetector\leakdetectortest\leakdetectortest.cpp (12): LeakDetectorTest.exe!new_some_mem() + 0x7 bytes
    e:\program\github\leakdetector\leakdetectortest\leakdetectortest.cpp (19): LeakDetectorTest.exe!main()
    f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl (74): LeakDetectorTest.exe!invoke_main() + 0x1b bytes
    f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl (264): LeakDetectorTest.exe!__scrt_common_main_seh() + 0x5 bytes
    f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl (309): LeakDetectorTest.exe!__scrt_common_main()
    f:\dd\vctools\crt\vcstartup\src\startup\exe_main.cpp (17): LeakDetectorTest.exe!mainCRTStartup()
    KERNEL32.DLL!BaseThreadInitThunk() + 0x24 bytes
    ntdll.dll!RtlUnicodeStringToInteger() + 0x253 bytes
    ntdll.dll!RtlUnicodeStringToInteger() + 0x21e bytes&lt;/p&gt;
&lt;p&gt;Num 2:
    e:\program\github\leakdetector\leakdetector\realdetector.cpp (109): LeakDetector.dll!LDTools::RealDetector::_malloc() + 0x1c bytes
    f:\dd\vctools\crt\vcstartup\src\heap\new_scalar.cpp (19): LeakDetectorTest.exe!operator new() + 0x9 bytes
    f:\dd\vctools\crt\vcstartup\src\heap\new_array.cpp (15): LeakDetectorTest.exe!operator new&lt;a href=&#34;&#34;&gt;&lt;/a&gt; + 0x9 bytes
    e:\program\github\leakdetector\leakdetectortest\leakdetectortest.cpp (11): LeakDetectorTest.exe!new_some_mem() + 0x7 bytes
    e:\program\github\leakdetector\leakdetectortest\leakdetectortest.cpp (19): LeakDetectorTest.exe!main()
    f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl (74): LeakDetectorTest.exe!invoke_main() + 0x1b bytes
    f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl (264): LeakDetectorTest.exe!__scrt_common_main_seh() + 0x5 bytes
    f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl (309): LeakDetectorTest.exe!__scrt_common_main()
    f:\dd\vctools\crt\vcstartup\src\startup\exe_main.cpp (17): LeakDetectorTest.exe!mainCRTStartup()
    KERNEL32.DLL!BaseThreadInitThunk() + 0x24 bytes
    ntdll.dll!RtlUnicodeStringToInteger() + 0x253 bytes
    ntdll.dll!RtlUnicodeStringToInteger() + 0x21e bytes
```&lt;/p&gt;
&lt;p&gt;程序正确地找出有两个地方申请的内存没有释放，并且打印出了完整的调用栈信息，我们需要的功能至此已经完成了。&lt;/p&gt;
&lt;h3&gt;结语&lt;/h3&gt;
&lt;p&gt;当你还不了解程序链接、装载与库的时候，你可能会对如何找到共享链接库的函数一头雾水，更不要说要把链接库的函数替换成我们自己的函数了。这里就以检测内存泄露为例子，探讨下了如何替换 Windows DLL 的函数，更详细的实现可以参考 VLD 的源码。&lt;/p&gt;
&lt;p&gt;另外想说的是，《程序员的自我修养：链接、装载与库》真是本不错的书呢，纯感慨非软广。&lt;/p&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/cpp-%E7%BC%96%E5%86%99Windows%E4%B8%8B%E7%9A%84MemoryLeakDetector/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Sat, 02 Dec 2023 09:39:15 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/cpp-%E7%BC%96%E5%86%99Windows%E4%B8%8B%E7%9A%84MemoryLeakDetector/</guid>
      
    </item>
    
    <item>
      <title>Unity人物控制</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;Unity人物控制&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2014-3-15-unity-3rdperson-control0/run_jump.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;人物的动作控制是游戏里面很重要的一部分，操作性强的游戏能够很好的吸引玩家。这里我就尝试做一个简单的人物操作控制，人物能够完成基本的移动，包括行走，跳跃。&lt;/p&gt;
&lt;h2&gt;需求&lt;/h2&gt;
&lt;p&gt;先来考虑一下，我们的人物操作具体的需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;行走，能够在刚体的表面行走，由按键上下左右输入来控制，暂不考虑加速减速过程&lt;/li&gt;
&lt;li&gt;行走的速度在不同方向上可以不同，例如后退应该比前进慢&lt;/li&gt;
&lt;li&gt;跳跃，由jump按键控制，人物以一定初速度从上离开地面，并慢慢回落到地面&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么大致的思路就是：用速度来描述人物的运动，速度每个方向上的分量可以分别计算，最后速度乘以时间就是人物的位置偏移了。&lt;/p&gt;
&lt;h2&gt;人物组件设置&lt;/h2&gt;
&lt;p&gt;在为人物写脚本来操作控制前，需要一些准备工作，把人物的相关组件先配置好：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为了控制人物并使人物有一些刚性物理上的表现需要为人物添加一个&lt;code&gt;Character Controller Component&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;为了结构更分明一些，先把关于人物的操作输入分出来，读取输入并初步处理后把结果传给人物控制器，把这部分的脚本命名为&lt;code&gt;MyThirdPersonInput.cs&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;真正控制人物移动的脚本命名为&lt;code&gt;MyThirdPersonController.cs&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;配置后的结果是这样：
&lt;img alt=&#34;&#34; src=&#34;assets/img/2014-3-15-unity-3rdperson-control0/setting.png&#34;&gt;&lt;/p&gt;
&lt;h2&gt;输入&lt;/h2&gt;
&lt;p&gt;输入就是上下左右和跳跃，方向需要做一个归一化的处理：&lt;/p&gt;
&lt;p&gt;```c#
// get movement from input
var direction = new Vector3(Input.GetAxis(&#34;Horizontal&#34;), 0, 
    Input.GetAxis(&#34;Vertical&#34;));
if (direction != Vector3.zero)
{
    // constrain length to [0, 1]
    var directionLength = direction.magnitude;
    directionLength = Math.Min(1, directionLength);
    direction = direction.normalized * directionLength;
}
person.inputMoveDirction = direction;
person.inputJump = Input.GetButton(&#34;Jump&#34;);
````&lt;/p&gt;
&lt;h2&gt;描述移动和跳跃&lt;/h2&gt;
&lt;p&gt;我们需要用一些变量来描述人物的动作，例如移动速度，跳跃速度等，移动用下面变量描述：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#    
[System.Serializable]
public class Movement
{
    public float forwardSpeed = 5F;
    public float backwardSpeed = 5F;
    public float sidewardSpeed = 5F;
}
public Movement movement = new Movement();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[System.Serializable]&lt;/code&gt;是为了让这些参数暴露到Inspector上。跳跃的描述如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
[System.Serializable]
public class Jumping 
{
    public bool enable = true;      // true if can jump
    public float jumpSpeed = 5F;    // original speed when jump
    public float gravity = 10F;
    public float maxFallSpeed = 20F;
    public bool jumping = false;    // true if now in the air
}
public Jumping jumping = new Jumping();&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;分解速度&lt;/h2&gt;
&lt;p&gt;为了方便描述不同方向的移动，把方向分成三个分量：前后、左右、上下，分别求解。&lt;/p&gt;
&lt;p&gt;前后速度不同，根据数值的正负判断：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
if (velocity.z &amp;gt; 0)
    velocity.z *= movement.forwardSpeed;
else
    velocity.z *= movement.backwardSpeed;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;左右速度一致：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
velocity.x = inputMoveDirction.x * movement.sidewardSpeed;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;跳跃麻烦一点，要判断当前人物的状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果已经在空中，用重力计算速度&lt;/li&gt;
&lt;li&gt;如果在地上：&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;如果按下跳跃键，速度为跳跃初始速度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;否则y方向速度为0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;c#
if (!isOnGround)
{
    yVelocity = Math.Max(yVelocity - jumping.gravity * Time.deltaTime, 
        -jumping.maxFallSpeed);
}
else
{
    if (jumping.enable &amp;amp;&amp;amp; inputJump)
    {
        yVelocity = jumping.jumpSpeed;
    }
    else
        yVelocity = 0F;
}&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;更新人物位置&lt;/h2&gt;
&lt;p&gt;计算出来的速度假定为从本帧开始的速度，那么本帧计算位置的速度应该是前一帧计算出来的，因此在更新速度前，先计算人物的新位置：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
// move to new position
var collisionFlag = controller.Move(velocity * Time.deltaTime);
isOnGround = (collisionFlag &amp;amp; CollisionFlags.CollidedBelow) != 0;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;controller.Move&lt;/code&gt;会返回&lt;code&gt;CollisionFlags&lt;/code&gt;来表示碰撞的状态，通过这个状态就可以知道人物是不是站在地面上。&lt;/p&gt;
&lt;p&gt;完整代码：&lt;/p&gt;
&lt;p&gt;MyThirdPersonInput.cs:&lt;/p&gt;
&lt;p&gt;```c#
using UnityEngine;
using System;
using System.Collections;
[RequireComponent(typeof(MyThirdPersonController))]&lt;/p&gt;
&lt;p&gt;public class MyThirdPersonInput : MonoBehaviour {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private MyThirdPersonController person;

void Awake()
{
    person = GetComponent&amp;lt;MyThirdPersonController&amp;gt;();
}

// Update is called once per frame
void Update () 
{
    // get movement from input
    var direction = new Vector3(Input.GetAxis(&#34;Horizontal&#34;), 0, 
        Input.GetAxis(&#34;Vertical&#34;));

    if (direction != Vector3.zero)
    {
        // constrain length to [0, 1]
        var directionLength = direction.magnitude;

        directionLength = Math.Min(1, directionLength);

        direction = direction.normalized * directionLength;

    }

    person.inputMoveDirction = direction;
    person.inputJump = Input.GetButton(&#34;Jump&#34;);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;MyThirdPersonController.cs:&lt;/p&gt;
&lt;p&gt;```c#
using UnityEngine;
using System;
using System.Collections;&lt;/p&gt;
&lt;p&gt;public class MyThirdPersonController : MonoBehaviour {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// The current global direction we want the character to move in.
[System.NonSerialized]
public Vector3 inputMoveDirction = Vector3.zero;

// Is the jump button held down? We use this interface instead of checking
// for the jump button directly so this script can also be used by AIs.
[System.NonSerialized]
public bool inputJump = false;

[System.Serializable]
public class Movement
{
    public float forwardSpeed = 5F;
    public float backwardSpeed = 5F;
    public float sidewardSpeed = 5F;
}
public Movement movement = new Movement();

[System.Serializable]
public class Jumping 
{
    public bool enable = true;      // true if can jump
    public float jumpSpeed = 5F;    // original speed when jump
    public float gravity = 10F;     
    public float maxFallSpeed = 20F;
    public bool jumping = false;    // true if now in the air
}
public Jumping jumping = new Jumping();

private CharacterController controller;
private Vector3 velocity = Vector3.zero;
private bool isOnGround = true;
// Use this for initialization
void Start () 
{
    controller = GetComponent&amp;lt;CharacterController&amp;gt;();
}

// Update is called once per frame
void FixedUpdate() 
{
    // move to new position
    var collisionFlag = controller.Move(velocity * Time.deltaTime);
    isOnGround = (collisionFlag &amp;amp; CollisionFlags.CollidedBelow) != 0;

    // update velocity
    float yVelocity = velocity.y;
    velocity = Vector3.zero;

    // x-z plane velocity
    if (inputMoveDirction != Vector3.zero)
    {
        velocity.z = inputMoveDirction.z;
        if (velocity.z &amp;gt; 0)
            velocity.z *= movement.forwardSpeed;
        else
            velocity.z *= movement.backwardSpeed;

        velocity.x = inputMoveDirction.x * movement.sidewardSpeed;
    }

    // y velocity
    if (!isOnGround)
    {
        yVelocity = Math.Max(yVelocity - jumping.gravity * Time.deltaTime, 
            -jumping.maxFallSpeed);
    }
    else
    {
        if (jumping.enable &amp;amp;&amp;amp; inputJump)
        {
            yVelocity = jumping.jumpSpeed;
        }
        else
            yVelocity = 0F;
    }

    velocity = transform.rotation * velocity;
    velocity.y = yVelocity;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/unity-Unity%E4%BA%BA%E7%89%A9%E6%8E%A7%E5%88%B6/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Sat, 02 Dec 2023 09:39:15 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/unity-Unity%E4%BA%BA%E7%89%A9%E6%8E%A7%E5%88%B6/</guid>
      
    </item>
    
    <item>
      <title>C/C++ 的命令行参数处理总结</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;C/C++ 的命令行参数处理总结&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://img.shields.io/badge/vs-2015-68217A.svg&#34;&gt;{:style=&#34;display: inline-block&#34;}
&lt;img alt=&#34;&#34; src=&#34;https://img.shields.io/badge/gcc-4.9-blue.svg&#34;&gt;{:style=&#34;display: inline-block&#34;}
&lt;img alt=&#34;&#34; src=&#34;https://img.shields.io/badge/clang-3.7-birghtgreen.svg&#34;&gt;{:style=&#34;display: inline-block&#34;}&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2016-11-19-aparsing/aparsing.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;前一阵子翻 Linux 内核代码的时候看到了内核对模块参数 (moduleparam) 的处理，觉得挺精妙，让我不禁想研究下 C 下的命令行参数要怎样更好地处理。本文所用代码都在这里 &lt;a href=&#34;https://github.com/disenone/aparsing&#34;&gt;aparsing&lt;/a&gt; 。代码支持在 Windows 、 Linux 、 Mac OS X 下编译运行，详细的编译指南在 README.md 里面。 &lt;/p&gt;
&lt;h2&gt;getenv&lt;/h2&gt;
&lt;p&gt;标准库为我们提供了一个函数 &lt;code&gt;getenv&lt;/code&gt; ，按照字面意思，这个函数是用来获取环境变量的，那么只要我们预先设置好需要的环境变量，在程序里面拿出来，就间接地把参数传到程序里面啦。我们来看下面这段&lt;a href=&#34;https://github.com/disenone/aparsing/blob/master/getenv/getenv_test.c&#34;&gt;代码&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;``` cpp linenums=&#34;1&#34;&lt;/p&gt;
&lt;h1&gt;include &lt;stdlib.h&gt;&lt;/h1&gt;
&lt;h1&gt;include &lt;stdio.h&gt;&lt;/h1&gt;
&lt;p&gt;//char &lt;em&gt;getenv( const char &lt;/em&gt;name );
//GETENV_ADD=abc GETENV_NUM=2 ./getenv_test &lt;/p&gt;
&lt;p&gt;int main (int argc, char &lt;em&gt;&lt;em&gt;argv)
{
    char &lt;/em&gt;add, &lt;/em&gt;num;
    if((add = getenv(&#34;GETENV_ADD&#34;)))
        printf(&#34;GETENV_ADD = %s\n&#34;, add);
    else
        printf(&#34;GETENV_ADD not found\n&#34;);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if((num = getenv(&#34;GETENV_NUM&#34;)))
{
    int numi = atoi(num);
    printf(&#34;GETENV_NUM = %d\n&#34;, numi);
}
else
    printf(&#34;GETENV_NUM not found\n&#34;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getenv&lt;/code&gt; 函数声明如第 &lt;a href=&#34;#__codelineno-0-5&#34;&gt;4&lt;/a&gt; 行，传入想要获取的变量名字，返回该变量的值，如果找不到变量，则返回0。&lt;a href=&#34;#__codelineno-0-10&#34;&gt;10&lt;/a&gt; 和 &lt;a href=&#34;#__codelineno-0-15&#34;&gt;15&lt;/a&gt; 行就是分别获取两个环境变量的值，如果变量有效则打印变量值。需要注意的是 &lt;code&gt;getenv&lt;/code&gt; 返回的都是字符串，需要使用者手动转换数值类型的，所以使用起来不够方便。编译运行:&lt;/p&gt;
&lt;p&gt;Windows 下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bat
set GETENV_ADD=abc &amp;amp; set GETENV_NUM=1 &amp;amp; .\getenv_test.exe&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Linux 下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shell
GETENV_ADD=abc GETENV_NUM=2 ./getenv_test&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GETENV_ADD = abc
GETENV_NUM = 2&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;getopt&lt;/h2&gt;
&lt;p&gt;Linux 给我们提供了一组函数 &lt;code&gt;getopt, getopt_long, getopt_long_only&lt;/code&gt; 来处理命令行传递进来的函数，这三个函数的声明分别是：&lt;/p&gt;
&lt;p&gt;```cpp linenums=&#34;1&#34;
extern char *optarg;
extern int optind, opterr, optopt;&lt;/p&gt;
&lt;p&gt;int getopt(int argc, char * const argv[],
                  const char *optstring);&lt;/p&gt;
&lt;p&gt;int getopt_long(int argc, char * const argv[],
            const char &lt;em&gt;optstring,
            const struct option &lt;/em&gt;longopts, int *longindex);&lt;/p&gt;
&lt;p&gt;int getopt_long_only(int argc, char * const argv[],
            const char &lt;em&gt;optstring,
            const struct option &lt;/em&gt;longopts, int *longindex);
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getopt&lt;/code&gt; 只能处理短参数（即单字符参数），&lt;code&gt;getopt_long, getopt_long_only&lt;/code&gt; 则可以处理长参数。详细的函数解释可以去翻 Linux 下的手册，下面我们通过例子来说明 &lt;code&gt;getopt&lt;/code&gt; 和 &lt;code&gt;getopt_long&lt;/code&gt; 的用法。&lt;/p&gt;
&lt;p&gt;需要注意的是， Windows 下是没有提供这一组函数的，所以我找了一份可以在 Windows 下编译的源码，做了小小的改动，代码都在&lt;a href=&#34;https://github.com/disenone/aparsing/tree/master/getopt&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;```cpp linenums=&#34;1&#34;
// test getopt&lt;/p&gt;
&lt;h1&gt;include &lt;getopt.h&gt;&lt;/h1&gt;
&lt;h1&gt;include &lt;stdio.h&gt;&lt;/h1&gt;
&lt;h1&gt;include &lt;string.h&gt;&lt;/h1&gt;
&lt;p&gt;static struct option long_options[] =
{
    {&#34;add&#34;, required_argument, 0, &#39;a&#39;},
    {&#34;append&#34;, no_argument, 0, 0},
    {&#34;delete&#34;, required_argument, 0, 0},
    {&#34;verbose&#34;, optional_argument, 0, 0},
    {&#34;create&#34;, no_argument, 0, 0},
    {&#34;file&#34;, required_argument, 0, 0},
    {&#34;help&#34;, no_argument, 0, 0},
    {0, 0, 0, 0}
};&lt;/p&gt;
&lt;p&gt;static char simple_options[] = &#34;a:bc::d:0123456789&#34;;&lt;/p&gt;
&lt;p&gt;int main (int argc, char **argv)
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int c;
int digit_optind = 0;

while (1)
{
    int this_option_optind = optind ? optind : 1;
    int longindex = -1;

    c = getopt_long(argc, argv, simple_options, long_options, &amp;amp;longindex);
    if (c == -1)
    break;

    switch (c)
    {
        // long option
        case 0:
               printf(&#34;option %s&#34;, long_options[longindex].name);
               if (optarg)
                   printf(&#34; with arg %s&#34;, optarg);
               printf(&#34;\n&#34;);
               break;

            break;

        case &#39;0&#39;:
        case &#39;1&#39;:
        case &#39;2&#39;:
        case &#39;3&#39;:
        case &#39;4&#39;:
        case &#39;5&#39;:
        case &#39;6&#39;:
        case &#39;7&#39;:
        case &#39;8&#39;:
        case &#39;9&#39;:
            if(digit_optind != 0 &amp;amp;&amp;amp; digit_optind != this_option_optind)
                printf(&#34;digits occur in two different argv-elements.\n&#34;);

            digit_optind = this_option_optind;
            printf(&#34;option %c\n&#34;, c);
            break;

        case &#39;a&#39;:
            printf(&#34;option a with value &#39;%s&#39;\n&#34;, optarg);
            break;

        case &#39;b&#39;:
            printf(&#34;option b\n&#34;);
            break;

        case &#39;c&#39;:
            if(optarg)
                printf(&#34;option c with value &#39;%s&#39;\n&#34;, optarg);
            else
                printf(&#34;option c\n&#34;);
            break;

        case &#39;?&#39;:
            break;

        default:
            printf(&#34;?? getopt returned character code 0%o ??\n&#34;, c);
    } // switch
} // while

if (optind &amp;lt; argc)
{
    printf(&#34;non-option ARGV-elements: &#34;);
    while (optind &amp;lt; argc)
    printf(&#34;%s &#34;, argv[optind++]);
    printf(&#34;\n&#34;);
}

return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;我们来着重分析 &lt;code&gt;getopt_long&lt;/code&gt; 的用法，&lt;code&gt;getopt_long&lt;/code&gt; 的前三个参数跟 &lt;code&gt;getopt&lt;/code&gt; 是一样的，分别是：命令行参数个数 &lt;code&gt;argc&lt;/code&gt; ，命令行参数数组 &lt;code&gt;argv&lt;/code&gt;，短参数具体形式 &lt;code&gt;optstring&lt;/code&gt;。&lt;code&gt;otpstring&lt;/code&gt; 的格式就是一个个的短参数字符，后面加冒号 &lt;code&gt;:&lt;/code&gt; 表示带参数，两个冒号 &lt;code&gt;::&lt;/code&gt; 表示可选参数，譬如第 19 行，就是声明短参数的形式，&lt;code&gt;b&lt;/code&gt; 参数不带额外参数， &lt;code&gt;a&lt;/code&gt; 参数带额外参数，&lt;code&gt;c&lt;/code&gt; 带可选参数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getopt_long&lt;/code&gt; 后两个参数是用来处理长参数的，其中 &lt;code&gt;option&lt;/code&gt; 的结构是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c
struct option {
    const char *name;       // 长参数名字
    int         has_arg;    // 是否带额外参数
    int        *flag;       // 设置如何返回函数调用结果
    int         val;        // 返回的数值
};&lt;/code&gt;
虽然说是长参数，但 &lt;code&gt;name&lt;/code&gt; 还是可以设置为单字符长度的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;has_arg&lt;/code&gt; 可以设置为 &lt;code&gt;no_argument, required_argument, optional_argument&lt;/code&gt;，分别表示不带参数，带参数，带可选参数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flag&lt;/code&gt; 和 &lt;code&gt;val&lt;/code&gt; 是配合使用的，如果 &lt;code&gt;flag = NULL&lt;/code&gt;，&lt;code&gt;getopt_long&lt;/code&gt; 会直接返回 &lt;code&gt;val&lt;/code&gt; ，否则如果 &lt;code&gt;flag&lt;/code&gt; 为有效指针，&lt;code&gt;getopt_long&lt;/code&gt; 会执行类似 &lt;code&gt;*flag = val&lt;/code&gt; 的操作，把 &lt;code&gt;flag&lt;/code&gt; 指向的变量设置为 &lt;code&gt;val&lt;/code&gt; 的数值。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;getopt_long&lt;/code&gt; 找到匹配的短参数，会返回该短参数的字符值，如果找到匹配的长参数，会返回 &lt;code&gt;val&lt;/code&gt;（ &lt;code&gt;flag = NULL&lt;/code&gt; ）或者返回 &lt;code&gt;0&lt;/code&gt; （ &lt;code&gt;flag != NULL; *flag = val;&lt;/code&gt; ）；如果遇到非参数的字符，会返回 &lt;code&gt;?&lt;/code&gt;；如果所有参数都处理完毕，则返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;利用返回值的特性，我们可以做出用长参跟短参含义相同的效果，譬如 &lt;code&gt;long_options&lt;/code&gt; 的第一个参数 &lt;code&gt;add&lt;/code&gt;，其 &lt;code&gt;val&lt;/code&gt; 值设置为短参数的字符 &lt;code&gt;&#39;a&#39;&lt;/code&gt;，那么判断返回时，&lt;code&gt;--add&lt;/code&gt; 和 &lt;code&gt;-a&lt;/code&gt; 会进入相同的处理分支，被当作相同的含义来处理了。&lt;/p&gt;
&lt;p&gt;拼图的最后一块就是 &lt;code&gt;optind&lt;/code&gt; 和 &lt;code&gt;optarg&lt;/code&gt; 的用法，&lt;code&gt;optind&lt;/code&gt; 是下一个待处理参数在 &lt;code&gt;argv&lt;/code&gt; 中的位置， &lt;code&gt;optarg&lt;/code&gt; 则指向额外参数字符串。&lt;/p&gt;
&lt;p&gt;编译运行代码：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;``
$ .\getopt_test -a 1 -b -c4 --add 2 --verbose --verbose=3 -123 -e --e
option a with value &#39;1&#39;
option b
option c with value &#39;4&#39;
option a with value &#39;2&#39;
option verbose
option verbose with arg 3
option 1
option 2
option 3
.\getopt_test: invalid option -- e
.\getopt_test: unrecognized option&lt;/code&gt;--e&#39;&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-a&lt;/code&gt; 和 &lt;code&gt;--add&lt;/code&gt; 的含义相同，短参数的可选参数直接跟在后面，譬如 &lt;code&gt;-c4&lt;/code&gt;，而长参数的可选参数需要有等号，譬如 &lt;code&gt;--verbose=3&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;mobuleparam&lt;/h2&gt;
&lt;p&gt;ok，终于来到最初引发这篇文章的方法，Linux 内核用了一种很取巧的方法来给内核模块传递参数，这个方法就是 &lt;code&gt;moduleparam&lt;/code&gt; 。我在这里先简单解释 Linux 内核的 &lt;code&gt;moduleparam&lt;/code&gt; 的做法，更详细的解释可以去看代码。虽然我借鉴了一些 &lt;code&gt;moduleparam&lt;/code&gt; 的处理方法，但和 Linux 内核的 &lt;code&gt;moduleparam&lt;/code&gt; 有一些不同，为了区分，我会把我的方法叫做 &lt;code&gt;small moduleparam&lt;/code&gt; ， Linux 内核的依然叫做 &lt;code&gt;moduleparam&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;先来看看 &lt;code&gt;moduleparam&lt;/code&gt; 的用法，在模块里面声明：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c
int enable_debug = 0;
module_param(enable_debug, int, 0);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后加载模块时输入参数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shell
$ insmod mod enable_debug=1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;变量 &lt;code&gt;enable_debug&lt;/code&gt; 就被正确地设置为 &lt;code&gt;1&lt;/code&gt;，使用起来很方便，需要增加的代码也很少，代码可以写得很简短优雅，不用像 &lt;code&gt;getenv&lt;/code&gt; 和 &lt;code&gt;getopt&lt;/code&gt; 那样写很多循环判断，而且还自带类型转换，所以我看到就想，要是能把这个方法拿来处理命令行参数，那就更好了。&lt;/p&gt;
&lt;p&gt;接着来看看 &lt;code&gt;moduleparam&lt;/code&gt; 的核心实现：&lt;/p&gt;
&lt;p&gt;```cpp linenums=&#34;1&#34;
struct kernel_param {
    const char &lt;em&gt;name;           // 变量名字
    u16 perm;                   // 变量访问权限
    u16 flags;                  // 变量是否 bool 类型
    param_set_fn set;           // str -&amp;gt; 变量值
    param_get_fn get;           // 变量值 -&amp;gt; str
    union {
        void &lt;/em&gt;arg;              // 变量指针
        const struct kparam_string &lt;em&gt;str;
        const struct kparam_array &lt;/em&gt;arr;
    };
};&lt;/p&gt;
&lt;p&gt;#define &lt;strong&gt;module_param_call(prefix, name, set, get, arg, isbool, perm)  \
    /&lt;em&gt; Default value instead of permissions? &lt;/em&gt;/         \
    static int __param_perm_check_##name __attribute&lt;/strong&gt;((unused)) =  \
    BUILD_BUG_ON_ZERO((perm) &amp;lt; 0 || (perm) &amp;gt; 0777 || ((perm) &amp;amp; 2))  \
    + BUILD_BUG_ON_ZERO(sizeof(&#34;&#34;prefix) &amp;gt; MAX_PARAM_PREFIX_LEN);   \
    static const char &lt;strong&gt;param_str_##name[] = prefix #name;      \
    static struct kernel_param __moduleparam_const __param_##name   \
    __used                              \
        __attribute&lt;/strong&gt; ((unused,&lt;strong&gt;section&lt;/strong&gt; (&#34;__param&#34;),aligned(sizeof(void *)))) \
    = { __param_str_##name, perm, isbool ? KPARAM_ISBOOL : 0,   \
        set, get, { arg } }&lt;/p&gt;
&lt;p&gt;#define module_param_call(name, set, get, arg, perm)                  \
    __module_param_call(MODULE_PARAM_PREFIX,                  \
                name, set, get, arg,                  \
                __same_type(*(arg), bool), perm)&lt;/p&gt;
&lt;p&gt;#define module_param_named(name, value, type, perm)            \
    param_check_##type(name, &amp;amp;(value));                \
    module_param_call(name, param_set_##type, param_get_##type, &amp;amp;value, perm); \
    __MODULE_PARM_TYPE(name, #type)&lt;/p&gt;
&lt;p&gt;#define module_param(name, type, perm)              \
    module_param_named(name, name, type, perm)&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;module_param&lt;/code&gt; 是一个宏，它实际做的事情是建立了一个可以反射到传入变量的结构 &lt;code&gt;kernel_param&lt;/code&gt; ，该结构保存了足够访问和设置变量的信息，即第 20-24 行，并且把结构放在叫做 &lt;code&gt;__param&lt;/code&gt; 的 &lt;code&gt;section&lt;/code&gt; 中（ &lt;code&gt;__section__ (&#34;__param&#34;)&lt;/code&gt; ）。结构保存好之后，内核会在加载模块时，找出 elf 文件的 &lt;code&gt;section __param&lt;/code&gt; 的位置和结构数量，在根据名字和 &lt;code&gt;param_set_fn&lt;/code&gt; 分别设置每个参数的数值。找出特定名字 &lt;code&gt;section&lt;/code&gt; 的方法是平台相关的，Linux 内核实现的是对 elf 文件的处理，Linux 提供了指令 &lt;code&gt;readelf&lt;/code&gt; 来查看 elf 文件的信息，有兴趣的可以查看 &lt;code&gt;readelf&lt;/code&gt; 的帮助信息。&lt;/p&gt;
&lt;p&gt;上面说道 Linux 内核的做法是平台相关的，而我想要的平台无关的处理参数的方法，所以我们就要改一改原始的 &lt;code&gt;moduleparam&lt;/code&gt; 的做法，把 &lt;code&gt;__section__ (&#34;__param&#34;)&lt;/code&gt; 声明去掉，毕竟我们并不像去很麻烦地读取 elf 文件的 &lt;code&gt;section&lt;/code&gt; 。先来看看修改后的用法：&lt;/p&gt;
&lt;p&gt;```cpp linenums=&#34;1&#34;&lt;/p&gt;
&lt;h1&gt;include &#34;moduleparam.h&#34;&lt;/h1&gt;
&lt;h1&gt;include &lt;stdio.h&gt;&lt;/h1&gt;
&lt;p&gt;static int test = 0;
static bool btest = 0;
static unsigned int latest_num = 0;
static long latest[10] = {0};
static char strtest[20] = &#34;\0&#34;;&lt;/p&gt;
&lt;p&gt;void usage()
{
    char *msg = &#34;usage: moduleparam_test [test=int] [btest[=bool]] [latest=int array] [strtest=string]\n&#34;;
    printf(msg);
}&lt;/p&gt;
&lt;p&gt;int unknown_handler(char &lt;em&gt;param, char &lt;/em&gt;val)
{
    printf(&#34;find unknown param: %s\n&#34;, param);
    return 0;
}&lt;/p&gt;
&lt;p&gt;int main (int argc, char **argv)
{
    init_module_param(4);
    module_param(test, int);
    module_param_bool(btest);
    module_param_array(latest, long, &amp;amp;latest_num);
    module_param_string(strtest, strtest, sizeof(strtest));&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int ret = parse_params(argc, argv, unknown_handler);

if(ret != 0)
{
    usage();
    return 0;
}

char buf[1024];
for(int i=0; i &amp;lt; MODULE_INIT_VARIABLE_NUM; ++i)
{
    MODULE_INIT_VARIABLE[i].get(buf, &amp;amp;MODULE_INIT_VARIABLE[i]);
    printf(&#34;%s = %s\n&#34;, MODULE_INIT_VARIABLE[i].name, buf);
}
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;那么为了保存每一个反射的结构，我就增加了一个宏 &lt;code&gt;init_module_param(num)&lt;/code&gt; ，来声明保存结构的空间， &lt;code&gt;num&lt;/code&gt; 是参数的个数，如果实际声明的参数个数超出 &lt;code&gt;num&lt;/code&gt; ，程序会触发断言错误。&lt;code&gt;module_param&lt;/code&gt; 的声明跟原始的稍有不同，去掉了最后一个表示访问权限的参数，不做权限的控制。另外新增了宏 &lt;code&gt;module_param_bool&lt;/code&gt; 来处理表示 &lt;code&gt;bool&lt;/code&gt; 的变量，这在 Linux 的版本是不需要的，因为它用到了 gcc 内建函数 &lt;code&gt;__builtin_types_compatible_p&lt;/code&gt; 来判断变量的类型，很遗憾，MSVC 是没有这个函数的，所以我只能把这个功能去掉，增加一个宏。 &lt;code&gt;module_param_array&lt;/code&gt; 和 &lt;code&gt;module_param_string&lt;/code&gt; 就是对数组和字符串的处理，这两个功能在原始的版本也是有的。&lt;/p&gt;
&lt;p&gt;声明参数完毕，就是处理传入的参数了，使用宏 &lt;code&gt;parse_params&lt;/code&gt; ，传入 &lt;code&gt;argc, argv&lt;/code&gt;，第 3 个参数是对未知参数的处理回调函数指针，可以传 &lt;code&gt;NULL&lt;/code&gt; ，则入到位置参数会中断处理参数，返回错误码。&lt;/p&gt;
&lt;p&gt;编译运行代码：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.\moduleparam_test.exe error=0 test=101 btest=1 latest=1,2,3 strtest=\&#34;Hello World!\&#34;
Parsing ARGS: error=0 test=101 btest=1 latest=1,2,3 strtest=&#34;Hello World!&#34;
find unknown param: error
test = 101
btest = Y
latest = 1,2,3
strtest = Hello World!&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以看到数值，数组和字符串都能正确读入并转换格式，如果遇到不能转换格式的参数，会返回错误码并打印相关信息。我们可以很简单地添加几行代码，就完成参数的读入和转换处理，用起来很优雅。更详细实现可以直接看代码，&lt;a href=&#34;https://github.com/disenone/aparsing&#34;&gt;在这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;这次我们总结了一下 C/C++ 下三种处理命令行参数的方法，分别是 &lt;code&gt;getenv&lt;/code&gt; ，&lt;code&gt;getopt&lt;/code&gt; 和 &lt;code&gt;moduleparam&lt;/code&gt;。三种方法有各自的特点，以后有需要可以根据实际的需求来选择合适的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getenv&lt;/code&gt; 是原生多平台就支持的，可以直接使用，但也过于原始，并使用的是环境变量，对环境有一定的污染，每次使用前最好清除不必要的环境变量防止上次的设置存留污染&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getopt&lt;/code&gt; 是 Linux 平台原生支持的，Windows 不支持，所以需要包含实现的代码才能跨平台使用。参数的传递符合 Linux 的命令传参标准，支持可选参数，但使用起来略微麻烦，通常需要循环和条件判断来处理不同的参数，并对数值类型的参数不友好。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;moduleparam&lt;/code&gt; 是参考 Linux 内核的 &lt;code&gt;moduleparam&lt;/code&gt; 实现的命令行参数处理工具，支持跨平台使用，使用简单，能对不同类型的参数进行类型转换，缺点就是每个参数都需要一个相应的变量存储。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/cpp-C%E5%92%8CCpp%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Sat, 02 Dec 2023 05:04:22 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/cpp-C%E5%92%8CCpp%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/</guid>
      
    </item>
    
    <item>
      <title>KCP 源码剖析</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;KCP 源码剖析&#34; /&gt;&lt;/p&gt;
&lt;p&gt;阅读本文之前，如果没听说过 KCP ，或者一点都不了解 KCP，麻烦抽一点时间先看看 KCP 项目的说明文档：&lt;a href=&#34;https://github.com/skywind3000/kcp&#34;&gt;传送门&lt;/a&gt;。本文的目的是深入 KCP 的实现细节去理解 KCP 。&lt;/p&gt;
&lt;h2&gt;什么是 KCP&lt;/h2&gt;
&lt;p&gt;KCP 是一个快速可靠协议，能够以比 TCP 更低的延迟来传送数据，数据重传更快，等待时间更短。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP是为流量设计的（每秒内可以传输多少KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据包从一端发送到一端需要多少时间），以10%-20%带宽浪费的代价换取了比 TCP快30%-40%的传输速度。TCP信道是一条流速很慢，但每秒流量很大的大运河，而KCP是水流湍急的小激流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上是 KCP 文档上面写的，关键词是&lt;strong&gt;带宽&lt;/strong&gt;和&lt;strong&gt;流速&lt;/strong&gt;，KCP 会损耗带宽，带来的好处是更大更均衡的传输速率。更多的说明参考 KCP 自身的文档。&lt;/p&gt;
&lt;h2&gt;KCP 数据结构&lt;/h2&gt;
&lt;p&gt;KCP 源码在 &lt;code&gt;ikcp.h&lt;/code&gt; 和 &lt;code&gt;ikcp.c&lt;/code&gt; 里面，&lt;code&gt;ikcp.h&lt;/code&gt; 核心的是数据结构的声明，首先是 &lt;code&gt;SEGMENT&lt;/code&gt; 数据包，是 KCP 协议处理数据的最小单位：&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; SEGMENT 结构（点击展开代码） &lt;/summary&gt;
```cpp
//=====================================================================
// SEGMENT 一个 SETMENT 就是一个数据包
//=====================================================================
struct IKCPSEG
{
    // 链表节点，发送和接受队列都是这里的链表的结构
    struct IQUEUEHEAD node;

    // 会话编号，同一个会话编号相同
    IUINT32 conv;

    // 数据包类型，譬如 DATA 或者 ACK
    IUINT32 cmd;

    // 由于 MTU 的限制，大数据包会拆分成多个小数据包，这个是小数据包的编号
    IUINT32 frg

    // 每个数据包，都会附带上发送方的接受窗口大小
    IUINT32 wnd;

    // 发送时间，如果是 ACK 包，会设置为源数据包的 ts
    IUINT32 ts;

    // 唯一标识数据包的编号
    IUINT32 sn;

    // 代表小于 una 的数据包都接收成功，跟 TCP 含义一致：oldest unacknowledged sequence number SND
    IUINT32 una;

    // 数据长度
    IUINT32 len;

    // 超时重传时间
    IUINT32 resendts;

    // 下次超时等待时间
    IUINT32 rto;

    // 快速重传，收到本数据包之后的数据包的数量，大于一定数量就触发快速重传
    IUINT32 fastack;

    // 发送次数
    IUINT32 xmit;

    // 数据
    char data[1];
};
```
&lt;/details&gt;

&lt;p&gt;看完 &lt;code&gt;SEGMENT&lt;/code&gt; 的注释，大致能看出 KCP 的核心也是一个 ARQ 协议，通过自动超时重传来保证数据的送达。接着再来看看 KCP 结构 &lt;code&gt;KCPCB&lt;/code&gt; 的定义：&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; KCP 结构（点击展开代码） &lt;/summary&gt;
```cpp
//---------------------------------------------------------------------
// IKCPCB
//---------------------------------------------------------------------
struct IKCPCB
{
    // conv: 会话编号
    // mtu, mss: 最大传输单元，最大报文段大小
    // state: 会话状态，0 有效，-1 断开
    IUINT32 conv, mtu, mss, state;

    // snd_una: 等待 ACK 的包编号
    // snd_nxt: 下一个等待发送的数据包编号
    // rcv_nxt: 下一个等待接收的数据包编号
    IUINT32 snd_una, snd_nxt, rcv_nxt;

    // ts_recent, ts_lastack: 未用到
    // ssthresh: 拥塞控制慢启动阈值
    IUINT32 ts_recent, ts_lastack, ssthresh;

    // rx_rto: rto (retransmission timeout)，超时重传时间
    // rx_rttval, rx_srtt, rx_minrto: 计算 rto 的中间变量
    IINT32 rx_rttval, rx_srtt, rx_rto, rx_minrto;

    // snd_wnd, rcv_wnd: 最大发送和接收窗口大小
    // rmt_wnd: remote wnd ，对端剩余接受窗口大小
    // cwnd: 可发送窗口大小
    // probe: 是否要发送控制报文的标志
    IUINT32 snd_wnd, rcv_wnd, rmt_wnd, cwnd, probe;

    // current: 当前时间
    // interval: 更新间隔
    // ts_flush: 下次需要更新的时间
    // xmit: 发送失败次数
    IUINT32 current, interval, ts_flush, xmit;

    // 对应链表的长度
    IUINT32 nrcv_buf, nsnd_buf;
    IUINT32 nrcv_que, nsnd_que;

    // nodelay: 控制超时重传的 rto 增长速度
    // updated: 是否调用过 ikcp_update
    IUINT32 nodelay, updated;

    // ts_probe, probe_wait: 对端接收窗口长时间为 0 时主动定期发起询问
    IUINT32 ts_probe, probe_wait;

    // deal_link: 对端长时间无应答
    // incr: 参与计算发送窗口大小
    IUINT32 dead_link, incr;

    // queue: 跟用户层接触的数据包
    // buf: 协议缓存的数据包
    struct IQUEUEHEAD snd_queue;
    struct IQUEUEHEAD rcv_queue;
    struct IQUEUEHEAD snd_buf;
    struct IQUEUEHEAD rcv_buf;

    // 需要发送 ack 的数据包信息
    IUINT32 *acklist;

    // 需要 ack 的包数量
    IUINT32 ackcount;

    // acklist 内存大小
    IUINT32 ackblock;

    // 用户层传进来的数据
    void *user;

    // 存放一个 kcp 包的空间
    char *buffer;

    // 触发快速重传的 fastack 次数
    int fastresend;

    // 快速重传最大次数
    int fastlimit;

    // nocwnd: 不考虑慢启动的发送窗口大小
    // stream: 流模式
    int nocwnd, stream;

    // debug log
    int logmask;

    // 发送数据接口
    int (*output)(const char *buf, int len, struct IKCPCB *kcp, void *user);

    void (*writelog)(const char *log, struct IKCPCB *kcp, void *user);
};
```
&lt;/details&gt;

&lt;p&gt;逐一把 KCP 结构里面的字段注释上，可以初步感觉到，整套 KCP 的协议不太复杂，细细去分析代码，你我都能读懂并理解 KCP 协议 :smile:&lt;/p&gt;
&lt;h2&gt;KCP 的 ARQ 实现&lt;/h2&gt;
&lt;p&gt;KCP 本质上是一个 ARQ (Auto Repeat-reQuest，自动重传) 协议，最基本的是要保证可靠的传输。那么我们可以先来关注 KCP 的基本 ARQ 部分，KCP 是怎么实现可靠传输的。&lt;/p&gt;
&lt;p&gt;ARQ 顾名思义，当我们认为对端接收数据包失败时，自动重新发送对应的数据包，它是通过确认接收和超时重传两个机制，来实现可靠传输。具体的代码实现上， KCP 给每个数据包（就是上一节提到的 &lt;code&gt;SEGMENT&lt;/code&gt; ） 分配唯一的 &lt;code&gt;sn&lt;/code&gt; 标识符，一旦对端接收到数据包，会回复一个 ACK 包（同样是 &lt;code&gt;SEGMENT&lt;/code&gt;），ACK 包的 &lt;code&gt;sn&lt;/code&gt; 跟接收到的数据包 &lt;code&gt;sn&lt;/code&gt; 相同，通知接收到此数据包已经接收成功。&lt;code&gt;SEGMENT&lt;/code&gt; 上还有一个 &lt;code&gt;una&lt;/code&gt; 字段，表示下一个期待接收的数据包的编号，换句话说，即是所有在该编号之前的数据包都已经接收完，相当于一个全量的 ACK 包，发送端可以更快的更新发送缓冲和发送窗口。&lt;/p&gt;
&lt;p&gt;我们可以通过跟踪 KCP 包的发送和接受代码，来理解最基本的 ARQ 实现：&lt;/p&gt;
&lt;h3&gt;发送&lt;/h3&gt;
&lt;p&gt;发送的过程是 &lt;code&gt;ikcp_send&lt;/code&gt; -&amp;gt; &lt;code&gt;ikcp_update&lt;/code&gt; -&amp;gt; &lt;code&gt;ikcp_output&lt;/code&gt;，上层调用 &lt;code&gt;ikcp_send&lt;/code&gt; 把数据传给 KCP，KCP 在 &lt;code&gt;ikcp_update&lt;/code&gt; 中处理数据的发送。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; ikcp_send（点击展开代码） &lt;/summary&gt;
```cpp
//---------------------------------------------------------------------
// 发送数据接口，用户调用 ikcp_send 来让 kcp 发送数据
// user/upper level send, returns below zero for error
//---------------------------------------------------------------------
int ikcp_send(ikcpcb *kcp, const char *buffer, int len)
{
    IKCPSEG *seg;
    int count, i;

    // mss 不能小于1
    assert(kcp-&gt;mss &gt; 0);
    if (len &lt; 0) return -1;

    // append to previous segment in streaming mode (if possible)
    if (kcp-&gt;stream != 0) {
        // 处理流模式
        // ......
    }

    // 计算分包，如果数据长度 len 大于 mss，需要分成多个包发送，对端接受到之后再拼起来
    if (len &lt;= (int)kcp-&gt;mss) count = 1;
    else count = (len + kcp-&gt;mss - 1) / kcp-&gt;mss;

    if (count &gt;= (int)IKCP_WND_RCV) return -2;

    if (count == 0) count = 1;

    // 分包
    for (i = 0; i &lt; count; i++) {
        // 计算包的数据长度，并分配对应的 seg 结构
        int size = len &gt; (int)kcp-&gt;mss ? (int)kcp-&gt;mss : len;
        seg = ikcp_segment_new(kcp, size);
        assert(seg);
        if (seg == NULL) {
            return -2;
        }

        // 设置 seg 的 数据信息，frg 表示分包编号
        if (buffer &amp;&amp; len &gt; 0) {
            memcpy(seg-&gt;data, buffer, size);
        }
        seg-&gt;len = size;
        seg-&gt;frg = (kcp-&gt;stream == 0)? (count - i - 1) : 0;

        // 加到 snd_queue 的末尾，nsnd_qua 加一
        iqueue_init(&amp;seg-&gt;node);
        iqueue_add_tail(&amp;seg-&gt;node, &amp;kcp-&gt;snd_queue);
        kcp-&gt;nsnd_que++;
        if (buffer) {
            buffer += size;
        }
        len -= size;
    }

    return 0;
}
```
&lt;/details&gt;

&lt;p&gt;&lt;code&gt;ikcp_send&lt;/code&gt; 是由 KCP 的上层来调用的发送数据接口，所有让 KCP 发送的数据，都应该通过这个接口。 &lt;code&gt;ikcp_send&lt;/code&gt; 做的事情很简单，主要就是把数据，根据 &lt;code&gt;kcp-&amp;gt;mss&lt;/code&gt; （一个包最大数据长度）来分成多个包，并设置分包编号，最后放到发送链表 &lt;code&gt;snd_queue&lt;/code&gt; 的末尾。流模式就是把多次调用 &lt;code&gt;ikcp_send&lt;/code&gt; 的数据都看成一个流，会先自动填充未满的 &lt;code&gt;SEGMENT&lt;/code&gt; 再分配新的，详细实现本文不讨论，感兴趣的，相信看完本文，再对应看看代码就能理解。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ikcp_send&lt;/code&gt; 调用完成之后，数据放在的 KCP 的 &lt;code&gt;snd_queue&lt;/code&gt; 中，那么后面 KCP 需要找个时机，把待发送的数据发送出去，这块代码都放在 &lt;code&gt;ikcp_update&lt;/code&gt; 和 &lt;code&gt;ikcp_flush&lt;/code&gt; 里面：&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; ikcp_update（点击展开代码） &lt;/summary&gt;
```cpp
//---------------------------------------------------------------------
// ikcp_update 是给上层定期调用的接口，用来更新 kcp 的状态，发送数据
// update state (call it repeatedly, every 10ms-100ms), or you can ask 
// ikcp_check when to call it again (without ikcp_input/_send calling).
// &#39;current&#39; - current timestamp in millisec. 
//---------------------------------------------------------------------
void ikcp_update(ikcpcb *kcp, IUINT32 current)
{
    IINT32 slap;

    kcp-&gt;current = current;

    // ikcp_flush 会检查这个，上层必须调用过 ikcp_update 才能调用 ikcp_flush，建议只使用 ikcp_update
    if (kcp-&gt;updated == 0) {
        kcp-&gt;updated = 1;
        kcp-&gt;ts_flush = kcp-&gt;current;
    }

    slap = _itimediff(kcp-&gt;current, kcp-&gt;ts_flush);

    if (slap &gt;= 10000 || slap &lt; -10000) {
        kcp-&gt;ts_flush = kcp-&gt;current;
        slap = 0;
    }

    if (slap &gt;= 0) {
        // 下次 flush 的时间
        kcp-&gt;ts_flush += kcp-&gt;interval;
        if (_itimediff(kcp-&gt;current, kcp-&gt;ts_flush) &gt;= 0) {
            kcp-&gt;ts_flush = kcp-&gt;current + kcp-&gt;interval;
        }
        ikcp_flush(kcp);
    }
}
```
&lt;/details&gt;

&lt;p&gt;&lt;code&gt;ikcp_update&lt;/code&gt; 做的事情很简单，判断一下 &lt;code&gt;ts_flush&lt;/code&gt; 的时间，符合条件则调用 &lt;code&gt;ikcp_flush&lt;/code&gt;，主要的处理逻辑都在 &lt;code&gt;ikcp_flush&lt;/code&gt; 里面了，因为 &lt;code&gt;ikcp_flush&lt;/code&gt; 内容复杂一点，我们目前只关注跟 ARQ 发送相关的部分：&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; 发送数据（点击展开代码） &lt;/summary&gt;
```cpp
//---------------------------------------------------------------------
// ikcp_flush
//---------------------------------------------------------------------
void ikcp_flush(ikcpcb *kcp)
{
    IUINT32 current = kcp-&gt;current;

    // buffer 是要传给 ikcp_output 的数据，初始化为 3 倍数据包大小
    char *buffer = kcp-&gt;buffer;
    char *ptr = buffer;
    int count, size, i;
    IUINT32 resent, cwnd;
    IUINT32 rtomin;
    struct IQUEUEHEAD *p;
    int change = 0;
    int lost = 0;
    IKCPSEG seg;

    // &#39;ikcp_update&#39; haven&#39;t been called.
    if (kcp-&gt;updated == 0) return;

    seg.conv = kcp-&gt;conv;
    seg.cmd = IKCP_CMD_ACK;
    seg.frg = 0;

    // seg.wnd 是表示当前可接收窗口大小
    seg.wnd = ikcp_wnd_unused(kcp);
    seg.una = kcp-&gt;rcv_nxt;
    seg.len = 0;
    seg.sn = 0;
    seg.ts = 0;

    // 发送 ack
    // 计算 发送窗口
    //...

    // 把数据包从 snd_queue 移动到 snd_buf
    // 移动是需要满足 发送窗口 大小，发送窗口满了，就停止移动
    // 放在 snd_buf 的里面的数据，就是可以直接调用 ikcp_output 给对端发送的数据
    while (_itimediff(kcp-&gt;snd_nxt, kcp-&gt;snd_una + cwnd) &lt; 0) {
        IKCPSEG *newseg;
        if (iqueue_is_empty(&amp;kcp-&gt;snd_queue)) break;

        newseg = iqueue_entry(kcp-&gt;snd_queue.next, IKCPSEG, node);

        iqueue_del(&amp;newseg-&gt;node);
        iqueue_add_tail(&amp;newseg-&gt;node, &amp;kcp-&gt;snd_buf);
        kcp-&gt;nsnd_que--;
        kcp-&gt;nsnd_buf++;

        newseg-&gt;conv = kcp-&gt;conv;
        newseg-&gt;cmd = IKCP_CMD_PUSH;
        newseg-&gt;wnd = seg.wnd;
        newseg-&gt;ts = current;

        // seg 唯一序号，其实就是一个递增的 kcp-&gt;snd_nxt
        newseg-&gt;sn = kcp-&gt;snd_nxt++;

        // una 在这里设置，通知对端下一个等待接收的包序号
        newseg-&gt;una = kcp-&gt;rcv_nxt;
        newseg-&gt;resendts = current;
        newseg-&gt;rto = kcp-&gt;rx_rto;
        newseg-&gt;fastack = 0;
        newseg-&gt;xmit = 0;
    }

    // 计算快速重传标志，超时等待时间
    // ...

    // 发送 snd_buf
    for (p = kcp-&gt;snd_buf.next; p != &amp;kcp-&gt;snd_buf; p = p-&gt;next) {
        IKCPSEG *segment = iqueue_entry(p, IKCPSEG, node);
        int needsend = 0;
        if (segment-&gt;xmit == 0) {
            // 首次发送
            // set-&gt;xmit 表示发送次数
            // resendts 超时重传的等待时间
            needsend = 1;
            segment-&gt;xmit++;
            segment-&gt;rto = kcp-&gt;rx_rto;
            segment-&gt;resendts = current + segment-&gt;rto + rtomin;
        }
        else if (_itimediff(current, segment-&gt;resendts) &gt;= 0) {
            // 超时重传
            // ...
        }
        else if (segment-&gt;fastack &gt;= resent) {
            // 快速重传
            // ...
        }

        if (needsend) {
            int need;
            segment-&gt;ts = current;
            segment-&gt;wnd = seg.wnd;
            segment-&gt;una = kcp-&gt;rcv_nxt;

            size = (int)(ptr - buffer);
            need = IKCP_OVERHEAD + segment-&gt;len;

            // 每当 buffer 中的数据超过 mtu ，那就先发出去，尽量避免底层再分包
            if (size + need &gt; (int)kcp-&gt;mtu) {
                ikcp_output(kcp, buffer, size);
                ptr = buffer;
            }

            // 把 seg 控制数据复制到 buffer 上，kcp 自己来处理大小端问题
            ptr = ikcp_encode_seg(ptr, segment);

            // 再复制数据
            if (segment-&gt;len &gt; 0) {
                memcpy(ptr, segment-&gt;data, segment-&gt;len);
                ptr += segment-&gt;len;
            }


            if (segment-&gt;xmit &gt;= kcp-&gt;dead_link) {
                kcp-&gt;state = (IUINT32)-1;
            }
        }
    }

    // flash remain segments
    size = (int)(ptr - buffer);
    if (size &gt; 0) {
        ikcp_output(kcp, buffer, size);
    }

    // 计算 ssthresh，更新慢启动窗口
    // ...
}
```
&lt;/details&gt;

&lt;p&gt;我们目前只关注 &lt;code&gt;ikcp_flush&lt;/code&gt; 里面有关发送数据的逻辑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先 KCP 会根据对端的接收窗口大小，把 &lt;code&gt;snd_queue&lt;/code&gt; 上的数据移动到 &lt;code&gt;snd_buf&lt;/code&gt; 上面，计算移动数量的公式是 &lt;code&gt;num = snd_nxt - (snd_una + cwnd)&lt;/code&gt;，也就是：已发送成功的最大包序号 &lt;code&gt;snd_una&lt;/code&gt; 加上 滑动窗口大小 &lt;code&gt;cwnd&lt;/code&gt; 大于 下个待发送的包序号&lt;code&gt;snd_nxt&lt;/code&gt;，则可以继续再发送新的数据包。移动 &lt;code&gt;SEG&lt;/code&gt; 的同时，设置控制字段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遍历 &lt;code&gt;snd_buf&lt;/code&gt;，如果需要发送数据包，则把数据复制到 &lt;code&gt;buffer&lt;/code&gt; 上，复制的同时用 &lt;code&gt;ikcp_encode_seg&lt;/code&gt; 处理控制字段数据的大小端问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后调用 &lt;code&gt;ikcp_output&lt;/code&gt; 把 &lt;code&gt;buffer&lt;/code&gt; 上的数据发送出去&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至此， KCP 完成数据的发送。&lt;/p&gt;
&lt;h3&gt;接收&lt;/h3&gt;
&lt;p&gt;接收的过程是跟发送相反的：&lt;code&gt;ikcp_input&lt;/code&gt; -&amp;gt; &lt;code&gt;ikcp_update&lt;/code&gt; -&amp;gt; &lt;code&gt;ikcp_recv&lt;/code&gt;，用户接收到网络上的数据之后，需要调用 &lt;code&gt;ikcp_input&lt;/code&gt; 传给 KCP 解析，调用 &lt;code&gt;ikcp_update&lt;/code&gt; 的时候会给发送端回复 ACK 包，上层通过调用 &lt;code&gt;ikcp_recv&lt;/code&gt; 来接收 KCP 解析之后的数据。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; 接收数据（点击展开代码） &lt;/summary&gt;
```cpp
//---------------------------------------------------------------------
// input data
//---------------------------------------------------------------------
int ikcp_input(ikcpcb *kcp, const char *data, long size)
{
    IUINT32 prev_una = kcp-&gt;snd_una;
    IUINT32 maxack = 0, latest_ts = 0;
    int flag = 0;

    // 合法性检查
    if (data == NULL || (int)size &lt; (int)IKCP_OVERHEAD) return -1;

    // data 可能是多个 KCP 包，循环处理
    while (1) {
        IUINT32 ts, sn, len, una, conv;
        IUINT16 wnd;
        IUINT8 cmd, frg;
        IKCPSEG *seg;

        // 不够一个 KCP 包，退出
        if (size &lt; (int)IKCP_OVERHEAD) break;

        // 先把控制字段解析出来
        data = ikcp_decode32u(data, &amp;conv);
        if (conv != kcp-&gt;conv) return -1;

        data = ikcp_decode8u(data, &amp;cmd);
        data = ikcp_decode8u(data, &amp;frg);
        data = ikcp_decode16u(data, &amp;wnd);
        data = ikcp_decode32u(data, &amp;ts);
        data = ikcp_decode32u(data, &amp;sn);
        data = ikcp_decode32u(data, &amp;una);
        data = ikcp_decode32u(data, &amp;len);

        size -= IKCP_OVERHEAD;

        if ((long)size &lt; (long)len || (int)len &lt; 0) return -2;

        // 数据包类型检查
        if (cmd != IKCP_CMD_PUSH &amp;&amp; cmd != IKCP_CMD_ACK &amp;&amp;
            cmd != IKCP_CMD_WASK &amp;&amp; cmd != IKCP_CMD_WINS) 
            return -3;

        kcp-&gt;rmt_wnd = wnd;

        // 这里的 una 是发送方的 kcp-&gt;rcv_nxt，根据这个数据，可以去掉已确认接收的数据包
        ikcp_parse_una(kcp, una);
        // 去掉已确认接收的包后，更新 snd_una 下一个要发送的序号
        ikcp_shrink_buf(kcp);

        if (cmd == IKCP_CMD_ACK) {
            // ack 包
            // ...
        }
        else if (cmd == IKCP_CMD_PUSH) {
            // 数据包
            // 如果接收到的数据包序号 sn，在接收窗口内，则正常处理，否则直接丢弃，等重传
            if (_itimediff(sn, kcp-&gt;rcv_nxt + kcp-&gt;rcv_wnd) &lt; 0) {

                // 接收到的每个数据包，都要回一个 ack 包，记录下来
                ikcp_ack_push(kcp, sn, ts);

                // 接收的数据调用 ikcp_parse_data 处理
                if (_itimediff(sn, kcp-&gt;rcv_nxt) &gt;= 0) {
                    seg = ikcp_segment_new(kcp, len);
                    seg-&gt;conv = conv;
                    seg-&gt;cmd = cmd;
                    seg-&gt;frg = frg;
                    seg-&gt;wnd = wnd;
                    seg-&gt;ts = ts;
                    seg-&gt;sn = sn;
                    seg-&gt;una = una;
                    seg-&gt;len = len;

                    if (len &gt; 0) {
                        memcpy(seg-&gt;data, data, len);
                    }

                    ikcp_parse_data(kcp, seg);
                }
            }
        }
        else if (cmd == IKCP_CMD_WASK) {
            // 查询窗口包
            // ...
        }
        else if (cmd == IKCP_CMD_WINS) {
            // 查询窗口的回复包
            // ...
        }
        else {
            return -3;
        }

        data += len;
        size -= len;
    }

    // 处理快速重传逻辑
    // ...

    // 更新发送窗口
    // ...

    return 0;
}
```
&lt;/details&gt;

&lt;p&gt;&lt;code&gt;ikcp_input&lt;/code&gt; 循环处理每一个 &lt;code&gt;SEG&lt;/code&gt; 包，先检查数据包的合法性和类型，因为每个数据包都会带上 &lt;code&gt;una&lt;/code&gt;，存放的是发送端等待接收的包序号，需要小于 &lt;code&gt;una&lt;/code&gt; 的包对端都已经接受成功，所以可以把 &lt;code&gt;snd_buff&lt;/code&gt; 中需要小于 &lt;code&gt;una&lt;/code&gt; 的都删掉，并更新 &lt;code&gt;snd_nxt&lt;/code&gt;，这一部分由 &lt;code&gt;ikcp_parse_una&lt;/code&gt; 和 &lt;code&gt;ikcp_shrink_buf&lt;/code&gt; 来处理。接收到的每个数据包，都需要回复 ACK 包，由 &lt;code&gt;ikcp_ack_push&lt;/code&gt; 记录下来，最后调用 &lt;code&gt;ikcp_parse_data&lt;/code&gt; 处理数据。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; 解析数据（点击展开代码） &lt;/summary&gt;
```cpp
void ikcp_parse_data(ikcpcb *kcp, IKCPSEG *newseg)
{
    struct IQUEUEHEAD *p, *prev;
    IUINT32 sn = newseg-&gt;sn;
    int repeat = 0;

    // 序号检查
    if (_itimediff(sn, kcp-&gt;rcv_nxt + kcp-&gt;rcv_wnd) &gt;= 0 ||
        _itimediff(sn, kcp-&gt;rcv_nxt) &lt; 0) {
        ikcp_segment_delete(kcp, newseg);
        return;
    }

    // 找出 newseg 应该放置的位置，因为接收到的 seg 可能是乱序的
    for (p = kcp-&gt;rcv_buf.prev; p != &amp;kcp-&gt;rcv_buf; p = prev) {
        IKCPSEG *seg = iqueue_entry(p, IKCPSEG, node);
        prev = p-&gt;prev;
        if (seg-&gt;sn == sn) {
            // 重复收到
            repeat = 1;
            break;
        }
        if (_itimediff(sn, seg-&gt;sn) &gt; 0) {
            break;
        }
    }

    // 把 newseg 放到 rcv_buf 正确的位置上
    if (repeat == 0) {
        iqueue_init(&amp;newseg-&gt;node);
        iqueue_add(&amp;newseg-&gt;node, p);
        kcp-&gt;nrcv_buf++;
    }    else {
        ikcp_segment_delete(kcp, newseg);
    }

    // 把数据从 rcv_buf 移动到 rcv_queue
    while (! iqueue_is_empty(&amp;kcp-&gt;rcv_buf)) {
        IKCPSEG *seg = iqueue_entry(kcp-&gt;rcv_buf.next, IKCPSEG, node);
        // 如果 seg 序号是等待接收的序号，移动到 rcv_queue
        if (seg-&gt;sn == kcp-&gt;rcv_nxt &amp;&amp; kcp-&gt;nrcv_que &lt; kcp-&gt;rcv_wnd) {
            iqueue_del(&amp;seg-&gt;node);
            kcp-&gt;nrcv_buf--;
            iqueue_add_tail(&amp;seg-&gt;node, &amp;kcp-&gt;rcv_queue);
            kcp-&gt;nrcv_que++;
            kcp-&gt;rcv_nxt++;
        }    else {
            break;
        }
    }
}
```
&lt;/details&gt;

&lt;p&gt;&lt;code&gt;ikcp_parse_data&lt;/code&gt; 主要的工作就是把 &lt;code&gt;newseg&lt;/code&gt; 放置到 &lt;code&gt;kcp-&amp;gt;rcv_buf&lt;/code&gt; 合适的位置上，并把数据从 &lt;code&gt;rcv_buf&lt;/code&gt; 移动到 &lt;code&gt;rcv_queue&lt;/code&gt;。&lt;code&gt;rcv_buf&lt;/code&gt; 合适的位置的意思是，&lt;code&gt;rcv_buf&lt;/code&gt; 是按照 &lt;code&gt;sn&lt;/code&gt; 的递增顺序排列的，&lt;code&gt;newseg&lt;/code&gt; 需要根据自己的 &lt;code&gt;sn&lt;/code&gt; 大小查找合适的位置。&lt;code&gt;rcv_buf&lt;/code&gt; 上的数据要移动到 &lt;code&gt;rcv_queue&lt;/code&gt;，条件是 &lt;code&gt;rcv_buf&lt;/code&gt; 上的数据包序号，等于 KCP 在等待接收的包序号 &lt;code&gt;kcp-&amp;gt;rcv_nxt&lt;/code&gt; ，移动一个数据包之后，需要更新 &lt;code&gt;kcp-&amp;gt;rvc_nxt&lt;/code&gt;，再处理下一个数据包。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ikcp_input&lt;/code&gt; 之后，上层调用 &lt;code&gt;ikcp_update&lt;/code&gt; 时候会发送 ACK 包，调用 &lt;code&gt;ikcp_recv&lt;/code&gt; 会给上层返回有效数据。&lt;code&gt;ikcp_update&lt;/code&gt; 和 &lt;code&gt;ikcp_recv&lt;/code&gt; 互相独立，没有调用顺序要求，视上层的调用时机而定。我们先来看 &lt;code&gt;ikcp_update&lt;/code&gt; 里面有关 ACK 发送的部分：&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; 回复 ACK（点击展开代码） &lt;/summary&gt;
```cpp
// 前面说过，ikcp_update 最终是调用 ikcp_flush
void ikcp_flush(ikcpcb *kcp, IUINT32 current)
{
    // ...

    // 回复 ACK 包
    count = kcp-&gt;ackcount;
    for (i = 0; i &lt; count; i++) {
        size = (int)(ptr - buffer);
        if (size + (int)IKCP_OVERHEAD &gt; (int)kcp-&gt;mtu) {
            ikcp_output(kcp, buffer, size);
            ptr = buffer;
        }
        ikcp_ack_get(kcp, i, &amp;seg.sn, &amp;seg.ts);
        ptr = ikcp_encode_seg(ptr, &amp;seg);
    }

    kcp-&gt;ackcount = 0;

    // ...
}
```
&lt;/details&gt;

&lt;p&gt;ACK 包的之前已经由 &lt;code&gt;ikcp_ack_push&lt;/code&gt; 保存起来了，所以这里只需要 &lt;code&gt;ikcp_ack_get&lt;/code&gt; 获取每个 ACK 包的信息，发送给对方。上层可以使用 &lt;code&gt;ikcp_recv&lt;/code&gt; 从 KCP 获取数据：&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; ikcp_recv（点击展开代码） &lt;/summary&gt;
```cpp
//---------------------------------------------------------------------
// user/upper level recv: returns size, returns below zero for EAGAIN
//---------------------------------------------------------------------
int ikcp_recv(ikcpcb *kcp, char *buffer, int len)
{
    struct IQUEUEHEAD *p;
    int ispeek = (len &lt; 0)? 1 : 0;
    int peeksize;
    int recover = 0;
    IKCPSEG *seg;
    assert(kcp);

    // 一些有效性检查
    if (iqueue_is_empty(&amp;kcp-&gt;rcv_queue))
        return -1;
    if (len &lt; 0) len = -len;

    // 计算能返回的数据长度
    peeksize = ikcp_peeksize(kcp);

    if (peeksize &lt; 0)
        return -2;
    if (peeksize &gt; len)
        return -3;

    // 判断下接收窗口
    if (kcp-&gt;nrcv_que &gt;= kcp-&gt;rcv_wnd)
        recover = 1;

    // 遍历 rcv_queue，把数据复制到 buffer 上
    for (len = 0, p = kcp-&gt;rcv_queue.next; p != &amp;kcp-&gt;rcv_queue; ) {
        int fragment;
        seg = iqueue_entry(p, IKCPSEG, node);
        p = p-&gt;next;

        if (buffer) {
            memcpy(buffer, seg-&gt;data, seg-&gt;len);
            buffer += seg-&gt;len;
        }

        len += seg-&gt;len;

        // 判断分包
        fragment = seg-&gt;frg;

        // 移除数据包
        if (ispeek == 0) {
            iqueue_del(&amp;seg-&gt;node);
            ikcp_segment_delete(kcp, seg);
            kcp-&gt;nrcv_que--;
        }

        // 所有分包都复制完，退出循环
        if (fragment == 0)
            break;
    }

    assert(len == peeksize);

    // rcv_queue 又空了一些，尝试继续从 rcv_buf 移动到 rcv_queue
    while (! iqueue_is_empty(&amp;kcp-&gt;rcv_buf)) {
        seg = iqueue_entry(kcp-&gt;rcv_buf.next, IKCPSEG, node);
        if (seg-&gt;sn == kcp-&gt;rcv_nxt &amp;&amp; kcp-&gt;nrcv_que &lt; kcp-&gt;rcv_wnd) {
            iqueue_del(&amp;seg-&gt;node);
            kcp-&gt;nrcv_buf--;
            iqueue_add_tail(&amp;seg-&gt;node, &amp;kcp-&gt;rcv_queue);
            kcp-&gt;nrcv_que++;
            kcp-&gt;rcv_nxt++;
        }    else {
            break;
        }
    }

    return len;
}
```
&lt;/details&gt;

&lt;p&gt;&lt;code&gt;ikcp_recv&lt;/code&gt; 一次调用只会返回一个完整的数据包，上层可以循环调用直到没有数据返回为止，函数的逻辑比较简单，就是从 &lt;code&gt;rcv_queue&lt;/code&gt; 中复制数据到上层传进来的 &lt;code&gt;buffer&lt;/code&gt; 里面，至此接收方对于接收到的数据包已经处理完毕。&lt;/p&gt;
&lt;p&gt;接收方处理数据包的时候，给发送方发送了 ACK 包，我们再来看看发送方接受 ACK 包的处理：&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; 处理 ACK 包（点击展开代码） &lt;/summary&gt;
```cpp
int ikcp_input(ikcpcb *kcp, const char *data, long size)
{
    // ...
    IUINT32 maxack = 0, latest_ts = 0;
    // ...
    while (1) {
        // ...
        // ts 是对端的 kcp-&gt; current
        data = ikcp_decode32u(data, &amp;ts);
        data = ikcp_decode32u(data, &amp;sn);

        if (cmd == IKCP_CMD_ACK) {
            // 更新 rot
            if (_itimediff(kcp-&gt;current, ts) &gt;= 0) {
                ikcp_update_ack(kcp, _itimediff(kcp-&gt;current, ts));
            }
            // 更新 snd_buf
            ikcp_parse_ack(kcp, sn);
            ikcp_shrink_buf(kcp);

            // maxack = 这次 input 的所有 ACK 包中最大的 sn
            if (flag == 0) {
                flag = 1;
                maxack = sn;
                latest_ts = ts;
            }    else {
                if (_itimediff(sn, maxack) &gt; 0) {
                #ifndef IKCP_FASTACK_CONSERVE
                    maxack = sn;
                    latest_ts = ts;
                #else
                    if (_itimediff(ts, latest_ts) &gt; 0) {
                        maxack = sn;
                        latest_ts = ts;
                    }
                #endif
                }
            }
        }
        // ...
    }

    // 如果有收到 ACK 包，记录用来做快速重传
    if (flag != 0) {
        ikcp_parse_fastack(kcp, maxack, latest_ts);
    }
}
```
&lt;/details&gt;

&lt;p&gt;可以看到接收到 ACK 包后同样会需要 &lt;code&gt;ikcp_parse_ack&lt;/code&gt; 和 &lt;code&gt;ikcp_shrink_buf&lt;/code&gt; 来更新 &lt;code&gt;snd_buf&lt;/code&gt;，另外还需要调用 &lt;code&gt;ikcp_update_ack&lt;/code&gt; 来计算更新 rto （retransmission timeout，超时重传时间）。&lt;code&gt;ikcp_input&lt;/code&gt; 计算收到的 ACK 包中最大序号，来记录做快速重传用。就这样，发送方收到 ACK 包，把发送数据从 &lt;code&gt;snd_buf&lt;/code&gt; 中移除，该数据包可靠地送达到了接收方，一次完整的 ARQ 确认接收过程结束。&lt;/p&gt;
&lt;h3&gt;超时重传&lt;/h3&gt;
&lt;p&gt;前面介绍的是 KCP 实现的 ARQ 中的 确认接收机制，ARQ 还需要一个超时重传来保证可靠性，下面我们来看看 KCP 是怎么做超时重传的。&lt;/p&gt;
&lt;p&gt;让我们回到 &lt;code&gt;ikcp_flush&lt;/code&gt; 函数：&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; 超时重传（点击展开代码） &lt;/summary&gt;
```cpp
void ikcp_flush(ikcpcb *kcp)
{
    // ...
    // 发送 snd_buf
    for (p = kcp-&gt;snd_buf.next; p != &amp;kcp-&gt;snd_buf; p = p-&gt;next) {
        IKCPSEG *segment = iqueue_entry(p, IKCPSEG, node);
        int needsend = 0;
        if (segment-&gt;xmit == 0) {
            // 首次发送
            needsend = 1;
            segment-&gt;xmit++;
            // 设置 segment-&gt;rto
            // 通过 segment-&gt;rto 计算 segment-&gt;resendts 超时重传时间
            segment-&gt;rto = kcp-&gt;rx_rto;
            segment-&gt;resendts = current + segment-&gt;rto + rtomin;
        }
        else if (_itimediff(current, segment-&gt;resendts) &gt;= 0) {
            // 超时重传
            needsend = 1;
            segment-&gt;xmit++;
            kcp-&gt;xmit++;
            // nodelay 控制下一次超时重传时间的计算
            if (kcp-&gt;nodelay == 0) {
                segment-&gt;rto += kcp-&gt;rx_rto;
            }    else {
                segment-&gt;rto += kcp-&gt;rx_rto / 2;
            }
            segment-&gt;resendts = current + segment-&gt;rto;
            lost = 1;
        }
        else if (segment-&gt;fastack &gt;= resent) {
            // 快速重传
            // ...
        }
        if (needsend) {
            // 发送数据
            // ...
        }
    // ...
}
```
&lt;/details&gt;

&lt;p&gt;一旦当前时间 &lt;code&gt;current&lt;/code&gt; 大于 &lt;code&gt;segment-&amp;gt;resendts&lt;/code&gt; 超时重传时间，说明在这段时间内，都没有收到接收方的 ACK 包，触发超时重传机制，&lt;code&gt;needsend = 1&lt;/code&gt;，重新发送数据。&lt;/p&gt;
&lt;p&gt;有了确认接收和超时重传机制，KCP 就可以保证基础的可靠数据传输了。但是为了能够保持更稳定的数据流速，KCP 还做了更多的事情，下面我们一起看看 KCP 还做了那些优化。&lt;/p&gt;
&lt;h2&gt;KCP 提升流速的策略&lt;/h2&gt;
&lt;h3&gt;快速重传&lt;/h3&gt;
&lt;p&gt;发送方发送了序号为 &lt;code&gt;sn&lt;/code&gt; 和 &lt;code&gt;sn + 1&lt;/code&gt; 两个数据包，如果只收到了 &lt;code&gt;sn + 1&lt;/code&gt; 的 ACK 包，那可能是因为 &lt;code&gt;sn&lt;/code&gt; 的 ACK 包在网路中还没到达，又或者 ACK 包丢了，又或者 &lt;code&gt;sn&lt;/code&gt; 数据包丢了，如果此时还没到超时重传的时间，网络也还不太拥堵，只是因为某种原因而突发丢包，那么发送方主动提前发送 &lt;code&gt;sn&lt;/code&gt; 数据包，可以帮助接收方更快地接收数据，提高流速。&lt;/p&gt;
&lt;p&gt;KCP 里面也相应实现了快速重传机制，也在 &lt;code&gt;ikcp_flush&lt;/code&gt; 里面：&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; 快速重传（点击展开代码） &lt;/summary&gt;
```cpp
void ikcp_flush(ikcpcb *kcp)
{
    // ...
    resent = (kcp-&gt;fastresend &gt; 0)? (IUINT32)kcp-&gt;fastresend : 0xffffffff;

    // 发送 snd_buf
    for (p = kcp-&gt;snd_buf.next; p != &amp;kcp-&gt;snd_buf; p = p-&gt;next) {
        IKCPSEG *segment = iqueue_entry(p, IKCPSEG, node);
        int needsend = 0;
        if (segment-&gt;xmit == 0) {
            // ...
        }
        else if (_itimediff(current, segment-&gt;resendts) &gt;= 0) {
            // ...
        }
        else if (segment-&gt;fastack &gt;= resent) {
            // 快速重传
            if ((int)segment-&gt;xmit &lt;= kcp-&gt;fastlimit ||
                kcp-&gt;fastlimit &lt;= 0) {
                needsend = 1;
                segment-&gt;xmit++;
                segment-&gt;fastack = 0;
                segment-&gt;resendts = current + segment-&gt;rto;
                change++;
            }
        }
        if (needsend) {
            // 发送数据
            // ...
        }
    // ...
}
```
&lt;/details&gt;

&lt;p&gt;要出发快速重传，有两个条件：
* &lt;code&gt;segment-&amp;gt;fastack &amp;gt;= resent&lt;/code&gt;，resent 是可配置的参数 &lt;code&gt;kcp-&amp;gt;fastresend&lt;/code&gt;，配置为 0 会关闭快速重传。&lt;code&gt;segment-&amp;gt;fastack&lt;/code&gt; 是在函数 &lt;code&gt;ikcp_parse_fastack&lt;/code&gt; 里面设置的，这个函数是在 &lt;code&gt;ikcp_input&lt;/code&gt; 里面调用，会根据 &lt;code&gt;ikcp_input&lt;/code&gt; 算出的 &lt;code&gt;maxack&lt;/code&gt; 来给所有 &lt;code&gt;sn&lt;/code&gt; 小于 &lt;code&gt;maxack&lt;/code&gt; 的 &lt;code&gt;segment-&amp;gt;fastack&lt;/code&gt; 加一，所以 &lt;code&gt;segment-&amp;gt;fastack&lt;/code&gt; 就是表示收到比 &lt;code&gt;sn&lt;/code&gt; 大的包的次数。
* &lt;code&gt;segment-&amp;gt;xmit &amp;lt;= kcp-&amp;gt;fastlimit || kcp-&amp;gt;fastlimit &amp;lt;= 0&lt;/code&gt;，&lt;code&gt;setgment-&amp;gt;xmit&lt;/code&gt; 是发送次数，&lt;code&gt;kcp-&amp;gt;fastlimit&lt;/code&gt; 是可配置的最大快速重传次数，发送次数需要小于最大快速重传次数&lt;/p&gt;
&lt;p&gt;一旦满足快速重传的以上条件，KCP 就会执行快速重传，要注意快速重传并不会重置超时重传时间，原来的超时时间依然会生效。&lt;/p&gt;
&lt;h3&gt;缩短超时重传时间&lt;/h3&gt;
&lt;p&gt;超时重传是个很好的机制，但就是太花时间了，按照 TCP 的策略，每次超时重传时间翻倍，等待时间膨胀得很快，在等待时间内，很可能由于接收端的接收窗口已耗尽，无法接收新数据，而等待重传的包序号是在最前面，接收方要接收到重传的包才能把所有数据返回给上层，这种情况，整个网路的流速几乎为 0。KCP 增加了配置可以减缓等待的时间增长，而且也不会是翻倍，通过配置 &lt;code&gt;kcp-&amp;gt;nodelay&lt;/code&gt; 控制每次等待时间只会增长 1 倍的 RTO 或者 0.5 倍的 RTO，有效减缓等待时间的增长，帮助网路尽快恢复流速。&lt;/p&gt;
&lt;h3&gt;更新发送窗口&lt;/h3&gt;
&lt;p&gt;发送窗口表示的是同时传输的数据包数量，窗口越大，同时传输的数据越多，流速越大，但窗口过大，会导致网络拥塞，丢包率上升，数据重传增多，流速下降。所以发送窗口需要根据网络情况不断更新，慢慢趋近最优。 KCP 中关于发送窗口的代码：&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; 发送窗口（点击展开代码） &lt;/summary&gt;
```cpp
ikcpcb* ikcp_create(IUINT32 conv, void *user)
{
    // ...
    // snd_wnd，rcv_wnd 发送和接受的缓冲区大小
    kcp-&gt;snd_wnd = IKCP_WND_SND;    // 32
    kcp-&gt;rcv_wnd = IKCP_WND_RCV;    // 128
    // 对端接收窗口大小              // 128
    kcp-&gt;rmt_wnd = IKCP_WND_RCV
    // 发送窗口 cwnd 初始化 0
    kcp-&gt;cwnd = 0;
    // 发送窗口字节数大小，参与计算 cwnd
    kcp-&gt;incr = 0
    // 慢启动阈值，slow start threshold
    kcp-&gt;ssthresh = IKCP_THRESH_INIT;
    // nocwnd 是可配置参数，1 不考虑 cwnd
    kcp-&gt;nocwnd = 0;
    // ...
}

void ikcp_flush(ikcpcb *kcp)
{
    // ...
    // 发送数据时先计算 发送窗口大小，是发送缓冲区大小和对方接收窗口大小的小值
    cwnd = _imin_(kcp-&gt;snd_wnd, kcp-&gt;rmt_wnd);
    // 默认还需要考虑 kcp-&gt;cwnd，即是不断更新的发送窗口
    if (kcp-&gt;nocwnd == 0) cwnd = _imin_(kcp-&gt;cwnd, cwnd);

    // 根据 cwnd 大小，snd_queue 移动到 snd_buf
    while (_itimediff(kcp-&gt;snd_nxt, kcp-&gt;snd_una + cwnd) &lt; 0) {
    }
    // 发送数据
    resent = (kcp-&gt;fastresend &gt; 0)? (IUINT32)kcp-&gt;fastresend : 0xffffffff;
    // 触发超时重传 lost = 1
    // 触发快速重传 change++

    // 更新慢启动阈值和发送窗口
    if (change) {
        // 如果有触发快速重传，ssthresh 设置为网络上正在传输的数据包数量的一半
        IUINT32 inflight = kcp-&gt;snd_nxt - kcp-&gt;snd_una;
        kcp-&gt;ssthresh = inflight / 2;
        if (kcp-&gt;ssthresh &lt; IKCP_THRESH_MIN)
            kcp-&gt;ssthresh = IKCP_THRESH_MIN;

        // 发送窗口为阈值再加上快速重传相关的 resent
        kcp-&gt;cwnd = kcp-&gt;ssthresh + resent;
        kcp-&gt;incr = kcp-&gt;cwnd * kcp-&gt;mss;
    }

    if (lost) {
        // 如果有超时重传，触发慢启动, ssthresh 阈值为发送窗口的一半
        kcp-&gt;ssthresh = cwnd / 2;
        if (kcp-&gt;ssthresh &lt; IKCP_THRESH_MIN)
            kcp-&gt;ssthresh = IKCP_THRESH_MIN;
        // 发送窗口回到 1，重新慢启动增长
        kcp-&gt;cwnd = 1;
        kcp-&gt;incr = kcp-&gt;mss;
    }

    if (kcp-&gt;cwnd &lt; 1) {
        // 因为初始化为 0，来到这里会再设置成 1
        kcp-&gt;cwnd = 1;
        kcp-&gt;incr = kcp-&gt;mss;
    }
}

int ikcp_input(ikcpcb *kcp, const char *data, long size)
{
    IUINT32 prev_una = kcp-&gt;snd_una;
    // 处理接收的数据

    while (1) {
        // ...
        data = ikcp_decode16u(data, &amp;wnd)
        // rmt_wnd 是对方的接收窗口大小
        kcp-&gt;rmt_wnd = wnd
        // ...
        // 处理数据
    }

    // 最后更新发送窗口
    // kcp-&gt;snd_una - prev_una &gt; 0，表示本次 input 有接受到 ACK 并且发送缓冲 snd_buf 有变化
    if (_itimediff(kcp-&gt;snd_una, prev_una) &gt; 0) {
        // 再判断对方的接收窗口
        if (kcp-&gt;cwnd &lt; kcp-&gt;rmt_wnd) {
            IUINT32 mss = kcp-&gt;mss;

            if (kcp-&gt;cwnd &lt; kcp-&gt;ssthresh) {
                // 小于慢启动阈值，双倍增长
                kcp-&gt;cwnd++;
                kcp-&gt;incr += mss;

            }    else {
                // 大于慢启动阈值之后，通过公式更新 incr ，进而计算 cwnd
                if (kcp-&gt;incr &lt; mss) kcp-&gt;incr = mss;
                kcp-&gt;incr += (mss * mss) / kcp-&gt;incr + (mss / 16);
                if ((kcp-&gt;cwnd + 1) * mss &lt;= kcp-&gt;incr) {
                    kcp-&gt;cwnd++;
                }
            }
            // 更新出来的值还要再比较下 rmt_wnd
            if (kcp-&gt;cwnd &gt; kcp-&gt;rmt_wnd) {
                kcp-&gt;cwnd = kcp-&gt;rmt_wnd;
                kcp-&gt;incr = kcp-&gt;rmt_wnd * mss;
            }
        }
    }
}
```
&lt;/details&gt;

&lt;p&gt;计算发送窗口 &lt;code&gt;kcp-&amp;gt;cwnd&lt;/code&gt; 的大小涉及的代码片段会稍微多一些，因为在发送和接收数据的时候，都会需要更新。&lt;code&gt;kcp-&amp;gt;cwnd&lt;/code&gt; 初始化为 0，
之后会在第一次调用 &lt;code&gt;ikcp_flush&lt;/code&gt; 的时候，判断小于 1 ，便修改成 1。之后发送方根据发送窗口大小，发送出相应数量的数据包，等待 ACK
回复包。ACK 包在 &lt;code&gt;kcp-&amp;gt;input&lt;/code&gt; 中进行处理，&lt;code&gt;kcp-&amp;gt;input&lt;/code&gt; 中如果判断有 ACK 包，并有清除发送缓冲中的发送数据包，说明有数据包已经完成送达，&lt;code&gt;kcp-&amp;gt;cwnd++&lt;/code&gt;。实际上很可能是一次 &lt;code&gt;kcp-&amp;gt;input&lt;/code&gt; 只处理到一个 ACK 包，可以理解为，每收到一个 ACK 包都会有 &lt;code&gt;kcp-&amp;gt;cwnd++&lt;/code&gt;，这句自增实现的是翻倍的效果，譬如当前 &lt;code&gt;kcp-&amp;gt;cwnd = 2&lt;/code&gt;，发送两个数据包，收到两个 ACK 包，触发了两次自增，最后就是 &lt;code&gt;kcp-&amp;gt;cwnd = 4&lt;/code&gt; 翻倍。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cwnd&lt;/code&gt; 可以一直指数增长，直到超过慢启动阈值，或者发生拥堵超时重传，快速重传的情况。发生了超时重传之后，会触发慢启动，慢启动阈值 &lt;code&gt;ssthresh = kcp-&amp;gt;cwnd / 2&lt;/code&gt;，发送窗口 &lt;code&gt;kcp-&amp;gt;cwnd = 1&lt;/code&gt;，回到最初重新指数增长。如果发生了快速重传，KCP 先提前减少 &lt;code&gt;ssthresh&lt;/code&gt;，也即是减少了 &lt;code&gt;cwnd&lt;/code&gt; 指数增长的空间，降低增长速度，提前减缓拥堵的情况。&lt;/p&gt;
&lt;p&gt;KCP 还增加了一个配置 &lt;code&gt;nocwnd&lt;/code&gt;，当 &lt;code&gt;nocwnd = 1&lt;/code&gt;，发送数据是不再考虑发送窗口大小，直接让最大能发送的数量发送数据包，满足高速模式下的要求。&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;本文简单地分析了 KCP 的源码，并讨论了 KCP 上 ARQ 的实现，和一些 KCP 提升流速的策略。还有很多细节没有提到，感兴趣的可以自己翻 KCP 的源码对照着看，相信也能有不少的收获。&lt;/p&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/cpp-KCP%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Sat, 02 Dec 2023 05:04:22 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/cpp-KCP%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      
    </item>
    
    <item>
      <title>游戏 AOI 算法解析和性能实测</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;游戏 AOI 算法解析和性能实测&#34; /&gt;&lt;/p&gt;
&lt;h3&gt;引子&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;AOI&lt;/code&gt; (Area Of Interest) 在多人在线游戏中是很基本的功能，玩家需要接收进入视野范围内的其他玩家或者实体 (Entity) 的信息。计算玩家视野范围内存在哪些实体，有哪些实体进入或离开视野的算法，我们一般称之为 &lt;code&gt;AOI&lt;/code&gt; 算法。&lt;/p&gt;
&lt;p&gt;本文讨论九宫格和十字链两种 &lt;code&gt;AOI&lt;/code&gt; 算法，并给出两种算法的实测性能分析，让你用起来心中有数，遇事不慌。&lt;/p&gt;
&lt;p&gt;文中会提到玩家和实体两种词，实体是游戏中物体的概念，玩家是拥有 AOI 的实体。&lt;/p&gt;
&lt;p&gt;文中代码可在这里找到：&lt;a href=&#34;https://github.com/disenone/AoiTesting&#34;&gt;AoiTesting&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;九宫格&lt;/h3&gt;
&lt;p&gt;所谓九宫格，是把场景内所有实体的位置按照格子划分，譬如划分成边长 200 的正方形，要找出中心玩家 AOI 范围内的其他实体，就把这个范围内涉及到的格子内的玩家都做一遍比较。&lt;/p&gt;
&lt;p&gt;例如场景每 100 毫秒会 Tick 一次，在 Tick 中我们可以这样更新玩家的 AOI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以玩家位置为中心，AOI 半径计算涉及到的格子集合&lt;/li&gt;
&lt;li&gt;对格子集合中的实体逐个计算跟玩家的距离&lt;/li&gt;
&lt;li&gt;距离小于 AOI 半径的实体集合则是玩家的新的 AOI&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;九宫格算法做起来很简单，算法用几句话就能描述清楚了，具体的性能分析我们留到后面，先来看看十字链表算法。&lt;/p&gt;
&lt;h3&gt;十字链表&lt;/h3&gt;
&lt;p&gt;对于 3D 游戏，我们一般会给 X 轴和 Z 轴坐标分别构建有序的链表，每个实体在链表上都有一个节点，存放的是该坐标轴值，按照值递增的顺序来存放。但如果只是存放实体本身的坐标点，这两个链表做查询的效率依然很低。&lt;/p&gt;
&lt;p&gt;真正关键的是，我们在链表上还会给拥有 AOI 的每个玩家增加左右两个哨兵节点。两个哨兵的坐标值跟玩家本身坐标正好相差了 AOI 半径，譬如玩家 &lt;code&gt;P&lt;/code&gt; 坐标为 &lt;code&gt;(a, b, c)&lt;/code&gt;，AOI 半径为 &lt;code&gt;r&lt;/code&gt; ，那么在 X 轴上会有两个哨兵 &lt;code&gt;left_x, right_x&lt;/code&gt;，坐标值分别为 &lt;code&gt;a - r&lt;/code&gt; 和 &lt;code&gt;a + r&lt;/code&gt;。由于有哨兵的存在，我们通过跟踪哨兵跟其他实体节点的移动来更新 AOI。继续前面的例子，一个实体 &lt;code&gt;E&lt;/code&gt; 移动导致在 X 轴上的节点从 &lt;code&gt;left_x&lt;/code&gt; 的右边想左跨过 &lt;code&gt;left_x&lt;/code&gt; 来到 &lt;code&gt;left_x&lt;/code&gt; 的左边，那么说明 &lt;code&gt;E&lt;/code&gt; 肯定是离开了 &lt;code&gt;P&lt;/code&gt; 的 AOI；同理如果向右跨过了 &lt;code&gt;right_x&lt;/code&gt; 也是离开了 AOI。相反，如果是向右跨过 &lt;code&gt;left_x&lt;/code&gt;，或者向左跨过 &lt;code&gt;right_x&lt;/code&gt;，说明有可能会进入到 &lt;code&gt;P&lt;/code&gt; 的 AOI 中。&lt;/p&gt;
&lt;p&gt;可以看到，十字链表算法要比九宫格复杂得多，我们需要维护两条有序的链表，并且在每个实体坐标更新的时候，同步移动链表上的节点，并且在移动跨过其他节点时更新 AOI。&lt;/p&gt;
&lt;h3&gt;九宫格的实现&lt;/h3&gt;
&lt;p&gt;因为涉及到实测的性能，所以我们先来稍微深入一点九宫格算法的实现细节：&lt;/p&gt;
&lt;p&gt;```cpp
struct Sensor {
  // ...
  Nuid sensor_id;
  float radius;
  float radius_square;
  PlayerPtrList aoi_players[2];
};&lt;/p&gt;
&lt;p&gt;struct PlayerAoi {
  // ...  &lt;br&gt;
  Nuid nuid;
  SquareId square_id;
  int square_index;
  Pos pos;
  Pos last_pos;
  Uint32 flags;
  std::vector&lt;Sensor&gt; sensors;
};
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PlayerAoi&lt;/code&gt; 存放玩家的数据，其中有一个 &lt;code&gt;sensors&lt;/code&gt; 数组，&lt;code&gt;sensors&lt;/code&gt; 就是用来计算一定范围内的实体，每次 &lt;code&gt;Tick&lt;/code&gt; 之后把计算出来的实体计划放在 &lt;code&gt;aoi_players&lt;/code&gt;。&lt;code&gt;aoi_players&lt;/code&gt; 是存放了两个数组，用于上一次 &lt;code&gt;Tick&lt;/code&gt; 结果做比较，求出进入和离开玩家。 &lt;code&gt;Tick&lt;/code&gt; 的大致流程是这样：&lt;/p&gt;
&lt;p&gt;```cpp
AoiUpdateInfos SquareAoi::Tick() {
  AoiUpdateInfos update_infos;
  PlayerPtrList remove_list;&lt;/p&gt;
&lt;p&gt;for (auto&amp;amp; elem : player_map_) {
    auto&amp;amp; player = *elem.second;
    // ...
    // 对有 sensors 的玩家计算 Aoi
    if (!player.sensors.empty()) {
      auto update_info = &lt;em&gt;UpdatePlayerAoi(cur_aoi_map_idx&lt;/em&gt;, &amp;amp;player);
      if (!update_info.sensor_update_list.empty()) {
        update_infos.emplace(update_info.nuid, std::move(update_info));
      }
    }
    // ...
  }&lt;/p&gt;
&lt;p&gt;// ...
  // 记录玩家上次的位置
  for (auto&amp;amp; elem : player_map_) {
    auto&amp;amp; player = *elem.second;
    player.last_pos = player.pos;
  }
  cur_aoi_map_idx_ = 1 - cur_aoi_map_idx_;
  return update_infos;
}
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Tick&lt;/code&gt; 做的事情很简单，遍历有 &lt;code&gt;sensors&lt;/code&gt; 的玩家，逐个计算 &lt;code&gt;sensor&lt;/code&gt; 范围内的实体，即为 AOI。&lt;code&gt;last_pos&lt;/code&gt; 是用来参与判断实体是否有进入或者离开 AOI，&lt;code&gt;_UpdatePlayerAoi&lt;/code&gt; 的代码如下：&lt;/p&gt;
&lt;p&gt;```cpp
AoiUpdateInfo SquareAoi::_UpdatePlayerAoi(Uint32 cur_aoi_map_idx, PlayerAoi* pptr) {
  AoiUpdateInfo aoi_update_info;
  aoi_update_info.nuid = pptr-&amp;gt;nuid;
  Uint32 new_aoi_map_idx = 1 - cur_aoi_map_idx;&lt;/p&gt;
&lt;p&gt;for (auto&amp;amp; sensor : pptr-&amp;gt;sensors) {
    auto&amp;amp; old_aoi = sensor.aoi_players[cur_aoi_map_idx];
    auto&amp;amp; new_aoi = sensor.aoi_players[new_aoi_map_idx];
    (this-&amp;gt;&lt;em&gt;calc_aoi_players_func_)(&lt;/em&gt;pptr, sensor, &amp;amp;new_aoi);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SensorUpdateInfo update_info;

auto&amp;amp; enters = update_info.enters;
auto&amp;amp; leaves = update_info.leaves;
float radius_square = sensor.radius_square;

_CheckLeave(pptr, radius_square, old_aoi, &amp;amp;leaves);
_CheckEnter(pptr, radius_square, new_aoi, &amp;amp;enters);

if (enters.empty() &amp;amp;&amp;amp; leaves.empty()) {
  continue;
}

update_info.sensor_id = sensor.sensor_id;
aoi_update_info.sensor_update_list.push_back(std::move(update_info));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;return aoi_update_info;
}
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;old_aoi&lt;/code&gt; 是上一个 &lt;code&gt;Tick&lt;/code&gt; 计算出来的 AOI，&lt;code&gt;new_aoi&lt;/code&gt; 是本次 &lt;code&gt;Tick&lt;/code&gt; 需要计算的 AOI。&lt;code&gt;new_aoi&lt;/code&gt; 通过遍历 AOI 范围内的所有格子的实体，选出跟玩家距离小于 AOI 半径来获得。之后用 &lt;code&gt;_CheckLeave&lt;/code&gt; 和 &lt;code&gt;_CheckEnter&lt;/code&gt; 两个函数，计算本次 &lt;code&gt;Tick&lt;/code&gt; 离开和进入 AOI 的实体，譬如如果 &lt;code&gt;new_aoi&lt;/code&gt; 中的实体 &lt;code&gt;last_pos&lt;/code&gt; 不在 AOI范围内，说明该实体是在本次 &lt;code&gt;Tick&lt;/code&gt; 进入到了 AOI 范围。具体的代码可以看源文件，这里不再赘述。&lt;/p&gt;
&lt;h3&gt;十字链表的实现&lt;/h3&gt;
&lt;p&gt;相比起九宫格，十字链表实现起来更复杂，先来看基本的数据结构：&lt;/p&gt;
&lt;p&gt;```cpp
struct CoordNode {
  // ...
  Uint8 type;
  float value;
  CoordNode &lt;em&gt;prev = nullptr;
  CoordNode &lt;/em&gt;next = nullptr;
  PlayerAoi &lt;em&gt;pplayer;
  Sensor &lt;/em&gt;psensor;&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;KHASH_MAP_INIT_INT64(SensorHashMap, PlayerAoi*);&lt;/p&gt;
&lt;p&gt;struct Sensor {
  // ...
  Nuid sensor_id;
  float radius;
  float radius_square;
  PlayerAoi *pplayer;
  CoordNode left_x;
  CoordNode right_x;
  CoordNode left_z;
  CoordNode right_z;
  PlayerPtrList aoi_players[2];&lt;/p&gt;
&lt;p&gt;std::shared_ptr&lt;khash_t(SensorHashMap)&gt; aoi_player_candidates;
};&lt;/p&gt;
&lt;p&gt;struct PlayerAoi {
  // ...
  Nuid nuid;
  Pos pos;
  Pos last_pos;
  Uint32 flags;
  CoordNode node_x;
  CoordNode node_z;
  std::vector&lt;Sensor&gt; sensors;
  std::shared_ptr&lt;boost::unordered_map\&lt;Nuid, std::vector\&lt;Nuid&gt;&gt;&gt; detected_by;
};
```&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Sensor&lt;/code&gt; 和 &lt;code&gt;PlayerAoi&lt;/code&gt; 跟九宫格有部分相似，不过多了链表相关的节点结构 &lt;code&gt;CoordNode&lt;/code&gt;。&lt;code&gt;CoordNode&lt;/code&gt; 就是链表上的一个节点，记录了本身节点的类型和数值，类型有三种：玩家节点，&lt;code&gt;Sensor&lt;/code&gt; 左节点，&lt;code&gt;Sensor&lt;/code&gt; 右节点。&lt;/p&gt;
&lt;p&gt;十字链表的大部分工作都是在维持链表的有序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;玩家加入时需要把玩家节点移动到有序的位置上，并且在移动玩家节点的同时，处理进入或者离开其他玩家 AOI 事件。&lt;/li&gt;
&lt;li&gt;玩家移动到正确的位置后，&lt;code&gt;Sensor&lt;/code&gt; 左右节点从玩家前后位置出发，移动到正确的位置，并处理跨过其他玩家节点时触发的进入和离开事件。&lt;/li&gt;
&lt;li&gt;玩家移动时，更新玩家的坐标，并移动玩家节点和 &lt;code&gt;Sensor&lt;/code&gt; 左右节点，处理 AOI 进入离开。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;移动节点的代码如下，每跨过一个节点，都会调用一次 &lt;code&gt;MoveCross&lt;/code&gt; 函数，由 &lt;code&gt;MoveCross&lt;/code&gt; 函数根据移动方向，移动节点和跨过节点的类型来决定是进入还是离开 AOI。&lt;/p&gt;
&lt;p&gt;```cpp
void ListUpdateNode(CoordNode *&lt;em&gt;list, CoordNode &lt;/em&gt;pnode) {
  float value = pnode-&amp;gt;value;&lt;/p&gt;
&lt;p&gt;if (pnode-&amp;gt;next &amp;amp;&amp;amp; pnode-&amp;gt;next-&amp;gt;value &amp;lt; value) {
    // move right
    auto cur_node = pnode-&amp;gt;next;
    while (1) {
      MoveCross(MOVE_DIRECTION_RIGHT, pnode, cur_node);
      if (!cur_node-&amp;gt;next || cur_node-&amp;gt;next-&amp;gt;value &amp;gt;= value) break;
      cur_node = cur_node-&amp;gt;next;
    }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ListRemove(list, pnode);
ListInsertAfter(list, cur_node, pnode);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;} else if (pnode-&amp;gt;prev &amp;amp;&amp;amp; pnode-&amp;gt;prev-&amp;gt;value &amp;gt; value) {
    // move left
    auto cur_node = pnode-&amp;gt;prev;
    while (1) {
      MoveCross(MOVE_DIRECTION_LEFT, pnode, cur_node);
      if (!cur_node-&amp;gt;prev || cur_node-&amp;gt;prev-&amp;gt;value &amp;lt;= value) break;
      cur_node = cur_node-&amp;gt;prev;
    }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ListRemove(list, pnode);
ListInsertBefore(list, cur_node, pnode);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
}
```&lt;/p&gt;
&lt;p&gt;链表的移动很慢，是 &lt;code&gt;O(n)&lt;/code&gt; 的复杂度，特别是在玩家新加入场景时，玩家需要从无穷远的地方，逐步移动到正确的位置上，为此需要大量遍历的节点，消耗很大。为了优化性能，我们可以在场景中固定位置放置灯塔，这种灯塔处理上跟玩家大致相同，只是比玩家多记录了一份 &lt;code&gt;detected_by&lt;/code&gt; 数据，&lt;code&gt;detected_by&lt;/code&gt; 是用来记录该哨兵实体处在哪些 &lt;code&gt;Sensor&lt;/code&gt; 范围内。玩家首次进入场景时，不再从最远处开始移动，而是找到一个最近的灯塔，把节点插入到灯塔旁边，并通过灯塔身上的 &lt;code&gt;detected_by&lt;/code&gt; 数据，快速进入到跟灯塔一致的其他玩家的 AOI 范围内，然后开始移动到正确的位置上，当然移动的时候也要处理进入和离开。同理，对于 &lt;code&gt;Sensor&lt;/code&gt;，也可以通过先继承灯塔的数据，然后从灯塔的位置上移动到正确位置上。通过这两种优化能够提升一倍以上的插入玩家性能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Sensor&lt;/code&gt; 身上还有一个名叫 &lt;code&gt;aoi_player_candidates&lt;/code&gt; 的 &lt;code&gt;HashMap&lt;/code&gt;（这里为了性能，使用了&lt;a href=&#34;https://github.com/attractivechaos/klib/blob/master/khash.h&#34;&gt;khash&lt;/a&gt;）。节点移动触发的 AOI 事件，其实只能检测到 X-Z 坐标轴上边长为 &lt;code&gt;2r&lt;/code&gt; 的正方形区域，不是我们严格意义上的圆形区域的 AOI，这个正方形的区域内的实体都被记录在 &lt;code&gt;aoi_player_candidates&lt;/code&gt; 上，并在 &lt;code&gt;Tick&lt;/code&gt; 中遍历计算圆形区域内的 AOI 范围，所以称为 &lt;code&gt;candidates&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所有十字链表的操作都是为了一直维护正方形区域内的实体 &lt;code&gt;candidates&lt;/code&gt;，十字链表中 &lt;code&gt;Tick&lt;/code&gt; 做的操作跟九宫格几乎一致，只是遍历计算 AOI 的 &lt;code&gt;candidates&lt;/code&gt; 不相同。九宫格的 &lt;code&gt;candidates&lt;/code&gt; 是 AOI 圆形区域所覆盖到的格子的实体，而十字链表则是由 &lt;code&gt;Sensor&lt;/code&gt; 左右节点所界定的边长为 &lt;code&gt;2r&lt;/code&gt; 的正方形区域中的实体。定性的来说，十字链表的 &lt;code&gt;candidates&lt;/code&gt; 一般都要比九宫格少，所以在 &lt;code&gt;Tick&lt;/code&gt; 中的遍历次数少，性能更优，只是十字链表还有大量额外的性能消耗在了维护链表上，这两者整体的性能到底孰优孰劣，我们接下来实测看看。&lt;/p&gt;
&lt;h3&gt;性能实测&lt;/h3&gt;
&lt;p&gt;我这里分别测了玩家加入场景（&lt;code&gt;Add Player&lt;/code&gt;），计算 AOI 进出事件（&lt;code&gt;Tick&lt;/code&gt;），玩家更新坐标位置（&lt;code&gt;Update Pos&lt;/code&gt;）三种情况的时间消耗。&lt;/p&gt;
&lt;p&gt;玩家初始位置在地图范围内随机生成，然后把玩家加入场景。&lt;code&gt;player_num&lt;/code&gt; 是玩家数量，&lt;code&gt;map_size&lt;/code&gt; 则是地图 X-Z 坐标轴范围，玩家的位置在此范围内均匀随机生成，每个玩家都有一个半径 &lt;code&gt;100&lt;/code&gt; 的 &lt;code&gt;Sensor&lt;/code&gt; 作为 AOI，计算时间用的是 &lt;code&gt;boost::timer::cpu_timer&lt;/code&gt;。&lt;code&gt;player_num&lt;/code&gt; 分别选了 &lt;code&gt;100, 1000, 10000&lt;/code&gt; 三种情况，而 &lt;code&gt;map_size&lt;/code&gt; 则选了 &lt;code&gt;[-50, 50], [-100, 100], [-1000, 1000], [-10000, 10000]&lt;/code&gt; 四种情况。&lt;/p&gt;
&lt;p&gt;更新玩家位置会让玩家固定随机方向，以 &lt;code&gt;6m/s&lt;/code&gt; 的速度移动。&lt;/p&gt;
&lt;p&gt;本次测试环境为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU: Intel(R) Core(TM) i5-4590 CPU @ 3.30GHz&lt;/li&gt;
&lt;li&gt;系统: Debian GNU/Linux 10 (buster)&lt;/li&gt;
&lt;li&gt;gcc 版本: gcc version 8.3.0 (Debian 8.3.0-6)&lt;/li&gt;
&lt;li&gt;boost 版本: boost_1_75_0&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;九宫格实测&lt;/h4&gt;
&lt;p&gt;九宫格的测试结果如下：&lt;/p&gt;
&lt;p&gt;```python
===Begin Milestore: player_num = 100, map_size = (-50.000000, 50.000000)
Add Player (1 times) 0.000081s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Tick (1 times) 0.000452s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Update Pos (10 times) 0.000230s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 100, map_size = (-100.000000, 100.000000)
Add Player (1 times) 0.000070s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Tick (1 times) 0.000338s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Update Pos (10 times) 0.000185s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 100, map_size = (-1000.000000, 1000.000000)
Add Player (1 times) 0.000084s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Tick (1 times) 0.000103s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Update Pos (10 times) 0.000187s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 100, map_size = (-10000.000000, 10000.000000)
Add Player (1 times) 0.000084s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Tick (1 times) 0.000080s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Update Pos (10 times) 0.000185s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 1000, map_size = (-50.000000, 50.000000)
Add Player (1 times) 0.000673s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Tick (1 times) 0.035298s wall, 0.030000s user + 0.000000s system = 0.030000s CPU (85.0%)
Update Pos (10 times) 0.001841s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 1000, map_size = (-100.000000, 100.000000)
Add Player (1 times) 0.000664s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Tick (1 times) 0.025806s wall, 0.030000s user + 0.000000s system = 0.030000s CPU (116.3%)
Update Pos (10 times) 0.001842s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 1000, map_size = (-1000.000000, 1000.000000)
Add Player (1 times) 0.000721s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Tick (1 times) 0.001793s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Update Pos (10 times) 0.001849s wall, 0.010000s user + 0.000000s system = 0.010000s CPU (540.8%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 1000, map_size = (-10000.000000, 10000.000000)
Add Player (1 times) 0.000885s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Tick (1 times) 0.000804s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Update Pos (10 times) 0.001855s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 10000, map_size = (-50.000000, 50.000000)
Add Player (1 times) 0.006454s wall, 0.010000s user + 0.000000s system = 0.010000s CPU (154.9%)
Tick (1 times) 3.822028s wall, 3.800000s user + 0.020000s system = 3.820000s CPU (99.9%)
Update Pos (10 times) 0.018402s wall, 0.020000s user + 0.000000s system = 0.020000s CPU (108.7%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 10000, map_size = (-100.000000, 100.000000)
Add Player (1 times) 0.006439s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Tick (1 times) 2.805551s wall, 2.760000s user + 0.040000s system = 2.800000s CPU (99.8%)
Update Pos (10 times) 0.018489s wall, 0.010000s user + 0.000000s system = 0.010000s CPU (54.1%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 10000, map_size = (-1000.000000, 1000.000000)
Add Player (1 times) 0.006698s wall, 0.010000s user + 0.000000s system = 0.010000s CPU (149.3%)
Tick (1 times) 0.093759s wall, 0.100000s user + 0.000000s system = 0.100000s CPU (106.7%)
Update Pos (10 times) 0.018350s wall, 0.010000s user + 0.000000s system = 0.010000s CPU (54.5%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 10000, map_size = (-10000.000000, 10000.000000)
Add Player (1 times) 0.009046s wall, 0.010000s user + 0.000000s system = 0.010000s CPU (110.6%)
Tick (1 times) 0.012091s wall, 0.010000s user + 0.000000s system = 0.010000s CPU (82.7%)
Update Pos (10 times) 0.019033s wall, 0.020000s user + 0.000000s system = 0.020000s CPU (105.1%)
===End Milestore
```&lt;/p&gt;
&lt;p&gt;九宫格在玩家数量 &lt;code&gt;100&lt;/code&gt; 时，三种操作耗时都很小，极限情况 &lt;code&gt;map_size = [-50, 50]&lt;/code&gt;，所有玩家互相都处于 AOI 范围内，&lt;code&gt;Tick&lt;/code&gt; 耗时大概 &lt;code&gt;0.4ms&lt;/code&gt;。玩家加入场景和更新坐标都是线性复杂度 &lt;code&gt;O(player_num)&lt;/code&gt;，性能表现都不错。在 &lt;code&gt;player_num = 10000, map_size = [-50, 50]&lt;/code&gt; 玩家人数达到 1 万的时候，&lt;code&gt;Add Player&lt;/code&gt; 和 &lt;code&gt;Update Pos&lt;/code&gt; 由于都是线性，几毫秒内就能完成，但 &lt;code&gt;Tick&lt;/code&gt; 耗时就去到 &lt;code&gt;3.8s&lt;/code&gt;，需要消耗大量 CPU，属于不可用了。人数 1 万，地图大小 &lt;code&gt;[-1000, 1000]&lt;/code&gt;，情况下，&lt;code&gt;Tick&lt;/code&gt; 时间消耗大概 &lt;code&gt;94ms&lt;/code&gt;，如果能够降低 &lt;code&gt;Tick&lt;/code&gt; 频率的话，譬如一秒两次，还是勉强属于可用的范围内。&lt;/p&gt;
&lt;h4&gt;十字链表实测&lt;/h4&gt;
&lt;p&gt;十字链表的测试结果如下：&lt;/p&gt;
&lt;p&gt;```python
===Begin Milestore: player_num = 100, map_size = (-50.000000, 50.000000)
Add Player (1 times) 0.002057s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Tick (1 times) 0.000330s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Update Pos (10 times) 0.000232s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 100, map_size = (-100.000000, 100.000000)
Add Player (1 times) 0.001201s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Tick (1 times) 0.000222s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Update Pos (10 times) 0.000272s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 100, map_size = (-1000.000000, 1000.000000)
Add Player (1 times) 0.000288s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Tick (1 times) 0.000048s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Update Pos (10 times) 0.000200s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 100, map_size = (-10000.000000, 10000.000000)
Add Player (1 times) 0.000194s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Tick (1 times) 0.000041s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Update Pos (10 times) 0.000192s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 1000, map_size = (-50.000000, 50.000000)
Add Player (1 times) 0.130766s wall, 0.130000s user + 0.000000s system = 0.130000s CPU (99.4%)
Tick (1 times) 0.028091s wall, 0.020000s user + 0.000000s system = 0.020000s CPU (71.2%)
Update Pos (10 times) 0.005369s wall, 0.010000s user + 0.000000s system = 0.010000s CPU (186.2%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 1000, map_size = (-100.000000, 100.000000)
Add Player (1 times) 0.103015s wall, 0.100000s user + 0.000000s system = 0.100000s CPU (97.1%)
Tick (1 times) 0.019545s wall, 0.020000s user + 0.000000s system = 0.020000s CPU (102.3%)
Update Pos (10 times) 0.009208s wall, 0.010000s user + 0.000000s system = 0.010000s CPU (108.6%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 1000, map_size = (-1000.000000, 1000.000000)
Add Player (1 times) 0.010150s wall, 0.010000s user + 0.000000s system = 0.010000s CPU (98.5%)
Tick (1 times) 0.000845s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Update Pos (10 times) 0.003023s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 1000, map_size = (-10000.000000, 10000.000000)
Add Player (1 times) 0.004950s wall, 0.010000s user + 0.000000s system = 0.010000s CPU (202.0%)
Tick (1 times) 0.000427s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
Update Pos (10 times) 0.002234s wall, 0.000000s user + 0.000000s system = 0.000000s CPU (n/a%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 10000, map_size = (-50.000000, 50.000000)
Add Player (1 times) 21.606402s wall, 21.040000s user + 0.570000s system = 21.610000s CPU (100.0%)
Tick (1 times) 3.696885s wall, 3.680000s user + 0.030000s system = 3.710000s CPU (100.4%)
Update Pos (10 times) 0.434396s wall, 0.430000s user + 0.000000s system = 0.430000s CPU (99.0%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 10000, map_size = (-100.000000, 100.000000)
Add Player (1 times) 18.499235s wall, 18.470000s user + 0.020000s system = 18.490000s CPU (100.0%)
Tick (1 times) 2.292608s wall, 2.290000s user + 0.000000s system = 2.290000s CPU (99.9%)
Update Pos (10 times) 1.522617s wall, 1.530000s user + 0.000000s system = 1.530000s CPU (100.5%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 10000, map_size = (-1000.000000, 1000.000000)
Add Player (1 times) 1.642519s wall, 1.640000s user + 0.000000s system = 1.640000s CPU (99.8%)
Tick (1 times) 0.042767s wall, 0.050000s user + 0.000000s system = 0.050000s CPU (116.9%)
Update Pos (10 times) 0.202949s wall, 0.200000s user + 0.000000s system = 0.200000s CPU (98.5%)
===End Milestore&lt;/p&gt;
&lt;p&gt;===Begin Milestore: player_num = 10000, map_size = (-10000.000000, 10000.000000)
Add Player (1 times) 0.571257s wall, 0.570000s user + 0.000000s system = 0.570000s CPU (99.8%)
Tick (1 times) 0.006325s wall, 0.010000s user + 0.000000s system = 0.010000s CPU (158.1%)
Update Pos (10 times) 0.042568s wall, 0.040000s user + 0.000000s system = 0.040000s CPU (94.0%)
===End Milestore
```&lt;/p&gt;
&lt;p&gt;如我们分析一致，十字链表在 &lt;code&gt;Add Player&lt;/code&gt; 和 &lt;code&gt;Update Pos&lt;/code&gt; 上耗时更长，特别是 &lt;code&gt;Add Player&lt;/code&gt;，相比九宫格性能差了几百甚至上万倍（&lt;code&gt;100, [-50, 50]&lt;/code&gt; 十字链耗时 &lt;code&gt;2ms&lt;/code&gt;，而九宫格只有 &lt;code&gt;0.08ms&lt;/code&gt;；&lt;code&gt;10000, [-50, 50]&lt;/code&gt; 十字链 &lt;code&gt;21.6s&lt;/code&gt;，九宫格只有 &lt;code&gt;6ms&lt;/code&gt;。&lt;code&gt;Update Pos&lt;/code&gt; 的耗时也最多会有百倍的差距，&lt;code&gt;10000, [-100, 100]&lt;/code&gt; 十字链更新玩家位置耗时 &lt;code&gt;1.5s&lt;/code&gt;，而九宫格是 &lt;code&gt;18ms&lt;/code&gt;。可以看出，十字链在 &lt;code&gt;Add Player&lt;/code&gt; 和 &lt;code&gt;Update Pos&lt;/code&gt; 耗时的上下限范围比九宫格要大，受人数和地图大小影响更大，在玩家密集的区域，这两个操作的性能会急速下降，直至不可用。&lt;/p&gt;
&lt;p&gt;反观十字链的 &lt;code&gt;Tick&lt;/code&gt; 操作，整体性能确实是比九宫格好，最好的情况耗时大概只有九宫格的一半左右（ &lt;code&gt;1000, [-1000, 1000]&lt;/code&gt; 下十字链耗时 &lt;code&gt;0.8ms&lt;/code&gt;，九宫格 &lt;code&gt;1.8ms&lt;/code&gt;），但是最差的情况十字链会退化到跟九宫格的性能接近（&lt;code&gt;10000, [-10000, 10000]&lt;/code&gt; 下十字链耗时 &lt;code&gt;3.7s&lt;/code&gt;，九宫格 &lt;code&gt;3.8s&lt;/code&gt;。这是因为由于场景小，玩家互相都在彼此的 AOI 范围内，十字链 &lt;code&gt;Tick&lt;/code&gt; 遍历的 &lt;code&gt;candidates&lt;/code&gt; 数量, 其实已经跟九宫格很接近了。&lt;/p&gt;
&lt;p&gt;十字链使用起来要达到比九宫格性能更优，需要一些更强的假设，譬如 &lt;code&gt;player_num = 1000, map_size = [-1000, 1000]&lt;/code&gt; 情况下，&lt;code&gt;Tick&lt;/code&gt; 耗时十字链为 &lt;code&gt;0.8ms&lt;/code&gt; 九宫格 &lt;code&gt;1.8ms&lt;/code&gt;，&lt;code&gt;Update Pos&lt;/code&gt; 十字链为 &lt;code&gt;0.3ms&lt;/code&gt; 九宫格 &lt;code&gt;0.18ms&lt;/code&gt;（注意测试 &lt;code&gt;Update Pos&lt;/code&gt; 时间为执行了 10 次的时间总和）。&lt;code&gt;Tick + Update Pos&lt;/code&gt; 总时间下，十字链如果要比九宫格更少，那 &lt;code&gt;Update Pos&lt;/code&gt; 的次数不能超过 &lt;code&gt;Tick&lt;/code&gt; 的 &lt;code&gt;8&lt;/code&gt; 倍，或者说两个 &lt;code&gt;Tick&lt;/code&gt; 之间，&lt;code&gt;Update Pos&lt;/code&gt; 的次数需要小于 &lt;code&gt;8&lt;/code&gt; 次。另外因为十字链 &lt;code&gt;Add Player&lt;/code&gt; 耗时巨大，不适用于玩家短时间频繁出入场景或者在场景内大范围传送的情况，另外如果短时间内有大量玩家进入场景，也很容易导致性能下降，大量占用 CPU。&lt;/p&gt;
&lt;p&gt;对于十字链表，在一个前提之下还能做一个优化：干掉 &lt;code&gt;Tick&lt;/code&gt;，前提是游戏能接受正方形的 AOI，并且需要实测正方形 AOI 带来的其他诸如网络等消耗是能接受的。其实前提是比较苛刻的，因为在游戏中 AOI 计费能占用的 CPU 通常占比是不大的，但把圆形 AOI 改成方形 AOI 导致 AOI 范围面积增大，范围内的玩家数量也增多，均匀分布下玩家数量可能会增多到原来的 &lt;code&gt;1.27&lt;/code&gt; 倍。但是，一旦能满足前提，十字链表可以做到不需要 &lt;code&gt;Tick&lt;/code&gt; 来定期更新 AOI 事件，因为实现上十字链表的 &lt;code&gt;candidates&lt;/code&gt; 就维护了一份方形下 AOI，原来只是为了计算圆形 AOI，而不得不在 &lt;code&gt;Tick&lt;/code&gt; 中再遍历计算距离。在这种情况下，十字链是有可能能够达到很好的性能，因为十字链表 &lt;code&gt;Update Pos&lt;/code&gt; 的性能可以跟 &lt;code&gt;Tick&lt;/code&gt; 相差几倍到几十倍。&lt;/p&gt;
&lt;p&gt;最后给出两者的对比柱状图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2021-11-18-aoi-tesing/add_player.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2021-11-18-aoi-tesing/tick.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2021-11-18-aoi-tesing/update_pos.png&#34;&gt;&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;本文我们介绍了两种 AOI 算法（九宫格和十字链）的原理和基本实现，并通过实测的数据分析了这两种算法的性能优劣，希望能够给读者带来一些帮助或者启发。&lt;/p&gt;
&lt;p&gt;总的来说，九宫格法实现简单，性能均衡不容易拉胯，非常适合 AOI 不是性能瓶颈的游戏来使用，九宫格法的性能波动范围是在可预期的范围内，性能下限比较高，也不容易导致瓶颈，但另一方面可优化空间也不大，时间复杂度比较固定。反观十字链法，实现要更复杂，性能下限比九宫格法低，但是如果能够满足一些假设和前提，十字链可优化空间更高，换句话说是上限是可以更高。这两种方法各有优劣，游戏业界内也有不同的引擎分别选择了两者之一，各取所需，见仁见智。&lt;/p&gt;
&lt;p&gt;本人能力有限，文中内容仅代表本人想法，如有不足不妥之处欢迎留言讨论。&lt;/p&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/game-%E6%B8%B8%E6%88%8FAOI%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E5%92%8C%E6%80%A7%E8%83%BD%E5%AE%9E%E6%B5%8B/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Sat, 02 Dec 2023 05:04:22 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/game-%E6%B8%B8%E6%88%8FAOI%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E5%92%8C%E6%80%A7%E8%83%BD%E5%AE%9E%E6%B5%8B/</guid>
      
    </item>
    
    <item>
      <title>使用 Visual Studio 2015 编译 Python 2.7.11</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;使用 Visual Studio 2015 编译 Python 2.7.11&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://img.shields.io/badge/python-2.7.11-brightgreen.svg&#34;&gt;{:style=&#34;display: inline-block&#34;}
&lt;img alt=&#34;&#34; src=&#34;https://img.shields.io/badge/vs-2015-68217A.svg&#34;&gt;{:style=&#34;display: inline-block&#34;}&lt;/p&gt;
&lt;h2&gt;原因&lt;/h2&gt;
&lt;p&gt;Python 2.7 的官方版本支持 Visual Studio 2010 以下版本来编译，参考 &lt;code&gt;PCbuild\readme.txt&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.  Install Microsoft Visual Studio 2008, any edition.
2.  Install Microsoft Visual Studio 2010, any edition, or Windows SDK 7.1 and any version of Microsoft Visual Studio newer than 2010.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你想在 Windows 下自己倒腾 Python，譬如编译个 Debug 版本、自己改改源代码等，那么最简单的方法就是装一个 VS2010。
但是对我个人来说， 我更想要用 VS2015 来编译 Python，原因主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VS2010 实在有点过时，使用起来功能和体验比 VS2015 要差得多。一直用着 VS2015，要我再装个 VS2010 实在不愿意。&lt;/li&gt;
&lt;li&gt;由于一直用 VS2015，你会使用它来写一些自己的程序，如果你想要把 Python 嵌入进去，那你就需要使用相同版本的 VS 来编译你的程序，如果使用不同版本的 VS，那会出现各种无法预料的事情。&lt;a href=&#34;http://siomsystems.com/mixing-visual-studio-versions/&#34;&gt;这里有更详细的解释&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以我开始着手用 VS2015 搞定 Python 2.7.11 版本（当前的 Python 2.7 最新版本）。&lt;/p&gt;
&lt;p&gt;要注意，&lt;strong&gt;Python 3.x 已经支持用 VS2015 来编译&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;源码下载&lt;/h2&gt;
&lt;p&gt;Python 的版本当然就是 2.7.11，另外还有一些第三方的模块，具体可以运行 Python 源码目录下 &lt;code&gt;PCbuild\get_externals.bat&lt;/code&gt; 脚本获取所有编译需要的模块，注意你需要安装 svn ，把 svn.exe 添加到系统 PATH 里面。&lt;/p&gt;
&lt;p&gt;下载可能很不稳定，并且整个过程都有可能因为网络问题而终止，所以还是推荐直接在我的github上下载externals目录：&lt;a href=&#34;https://github.com/disenone/wpython-2.7.11/tree/e13f43a3b72ae2bdf4d2950c6364750ae668cbf4/externals&#34;&gt;我的 Python 版本&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;编译过程&lt;/h2&gt;
&lt;h3&gt;第三方模块&lt;/h3&gt;
&lt;p&gt;首先要解决的是第三方的模块，主要是 tcl, tk, tcltk。&lt;/p&gt;
&lt;p&gt;修改文件 &lt;code&gt;externals/tcl-8.5.15.0/win/makefile.vc&lt;/code&gt;，把 434 行改成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- cdebug = -Zi -WX $(DEBUGFLAGS)
+ cdebug = -Zi -WX- $(DEBUGFLAGS)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于选项 &lt;code&gt;WX&lt;/code&gt;，可以看微软的官方文档：&lt;a href=&#34;https://msdn.microsoft.com/en-us/library/ms235592.aspx&#34;&gt;/WX (Treat Linker Warnings as Errors)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再来改&lt;code&gt;PCbuild/tk.vcxproj&lt;/code&gt;，用文本编辑器打开，修改 63, 64 行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- &amp;lt;TkOpts&amp;gt;msvcrt&amp;lt;/TkOpts&amp;gt;
- &amp;lt;TkOpts Condition=&#34;$(Configuration) == &#39;Debug&#39;&#34;&amp;gt;symbols,msvcrt&amp;lt;/TkOpts&amp;gt;
+ &amp;lt;TkOpts&amp;gt;msvcrt,noxp&amp;lt;/TkOpts&amp;gt;
+ &amp;lt;TkOpts Condition=&#34;$(Configuration) == &#39;Debug&#39;&#34;&amp;gt;symbols,msvcrt,noxp&amp;lt;/TkOpts&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改&lt;code&gt;PCbuild/tcltk.props&lt;/code&gt;，用文本编辑器打开，修改41行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- &amp;lt;BuildDirTop&amp;gt;$(BuildDirTop)_VC9&amp;lt;/BuildDirTop&amp;gt;
+ &amp;lt;BuildDirTop&amp;gt;$(BuildDirTop)_VC13&amp;lt;/BuildDirTop&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于 VS2015 取消了 &lt;code&gt;timezone&lt;/code&gt; 的定义，改为 &lt;code&gt;_timezone&lt;/code&gt;，所以代码里面用到 &lt;code&gt;timezone&lt;/code&gt; 的地方都要改成 &lt;code&gt;_timezone&lt;/code&gt;，第三方模块只需要改文件&lt;code&gt;externals/tcl-8.5.15.0/win/tclWinTime.c&lt;/code&gt;，在文件的前面加上：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#if defined _MSC_VER &amp;amp;&amp;amp; _MSC_VER &amp;gt;= 1900
#define timezone _timezone
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;改 Python 源码&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;timezone&lt;/code&gt;的问题在 Python 的模块 &lt;code&gt;time&lt;/code&gt; 里面也有，修改 767 行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- #ifdef __CYGWIN__
+ #if defined(__CYGWIN__) || defined(_MSC_VER) &amp;amp;&amp;amp; _MSC_VER &amp;gt;= 1900
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外由于在 Windows 下 Python 用了一种特殊的方法来检查文件句柄的有效性，而这种方法在 VS2015 中被彻底禁止了，会出现编译错误，所以先改掉。文件 &lt;code&gt;Include/fileobject.h&lt;/code&gt;，73、80 行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;73 - #if defined _MSC_VER &amp;amp;&amp;amp; _MSC_VER &amp;gt;= 1400
73 + #if defined _MSC_VER &amp;amp;&amp;amp; _MSC_VER &amp;gt;= 1400 &amp;amp;&amp;amp; _MSC_VER &amp;lt; 1900

80 - #elif defined _MSC_VER &amp;amp;&amp;amp; _MSC_VER &amp;gt;= 1200
80 + #elif defined _MSC_VER &amp;amp;&amp;amp; _MSC_VER &amp;gt;= 1200 &amp;amp;&amp;amp; _MSC_VER &amp;lt; 1400
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文件&lt;code&gt;Modules/posixmodule.c&lt;/code&gt;，532 行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- #if defined _MSC_VER &amp;amp;&amp;amp; _MSC_VER &amp;gt;= 1400
+ #if defined _MSC_VER &amp;amp;&amp;amp; _MSC_VER &amp;gt;= 1400 &amp;amp;&amp;amp; _MSC_VER &amp;lt; 1900
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此，Python 就可以编译通过。更具体的修改可以看我 commit 的内容：&lt;a href=&#34;https://github.com/disenone/wpython-2.7.11/commit/4037e2d806518dbf06ffb8ee5c46f419ef8d7edf&#34;&gt;modify to build by vs2015&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;检查无效句柄&lt;/h3&gt;
&lt;p&gt;虽然编译通过了，但由于是粗暴地忽略无效文件句柄，直接导致的后果是一旦访问无效的句柄（譬如对同一个文件&lt;code&gt;close&lt;/code&gt;两次），Python 就会直接 assert failed，程序 crash，这样的 Python 根本没法用啊。Python 就是用了一种很特殊的方法来避免这种情况，可惜在 VS2015 里面不能用了，注释是这样解释的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Microsoft CRT in VS2005 and higher will verify that a filehandle is valid and raise an assertion if it isn&#39;t.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;幸好已经有了解决方法，我是在 Python 的 issue 里面看到的，地址在这里：&lt;a href=&#34;http://psf.upfronthosting.co.za/roundup/tracker/issue23524&#34;&gt;issue23524&lt;/a&gt;, &lt;a href=&#34;http://psf.upfronthosting.co.za/roundup/tracker/issue25759&#34;&gt;issue25759&lt;/a&gt;。这种方法也是用在现在 Python 3.x 里面。&lt;/p&gt;
&lt;p&gt;具体地说就是在使用文件句柄的时候禁止掉 Windows 的 assert crash 机制，改为检查错误码。那要怎么禁止 Windows 的 assert 机制呢？答案就是用自己的错误处理函数替代 Windows 默认的处理函数，关键的代码：&lt;/p&gt;
&lt;p&gt;新建文件&lt;code&gt;PC/invalid_parameter_handler.c&lt;/code&gt;，定义我们自己的错误处理函数，可以暂时忽略发生的错误&lt;/p&gt;
&lt;p&gt;```c++&lt;/p&gt;
&lt;h1&gt;ifdef _MSC_VER&lt;/h1&gt;
&lt;h1&gt;include &lt;stdlib.h&gt;&lt;/h1&gt;
&lt;h1&gt;if _MSC_VER &amp;gt;= 1900&lt;/h1&gt;
&lt;p&gt;/&lt;em&gt; pyconfig.h uses this function in the _Py_BEGIN_SUPPRESS_IPH/_Py_END_SUPPRESS_IPH
 * macros. It does not need to be defined when building using MSVC
 * earlier than 14.0 (_MSC_VER == 1900).
 &lt;/em&gt;/&lt;/p&gt;
&lt;p&gt;static void __cdecl _silent_invalid_parameter_handler(
    wchar_t const&lt;em&gt; expression,
    wchar_t const&lt;/em&gt; function,
    wchar_t const* file,
    unsigned int line,
    uintptr_t pReserved) 
{}&lt;/p&gt;
&lt;p&gt;_invalid_parameter_handler _Py_silent_invalid_parameter_handler = _silent_invalid_parameter_handler;&lt;/p&gt;
&lt;h1&gt;endif&lt;/h1&gt;
&lt;h1&gt;endif&lt;/h1&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;定义两个宏方便更换错误处理函数，要注意是暂时的更换，之后是需要换回系统默认的&lt;/p&gt;
&lt;p&gt;```c++&lt;/p&gt;
&lt;h1&gt;if defined _MSC_VER &amp;amp;&amp;amp; _MSC_VER &amp;gt;= 1900&lt;/h1&gt;
&lt;p&gt;extern _invalid_parameter_handler _Py_silent_invalid_parameter_handler;
#define _Py_BEGIN_SUPPRESS_IPH { _invalid_parameter_handler _Py_old_handler = \
    _set_thread_local_invalid_parameter_handler(_Py_silent_invalid_parameter_handler);&lt;/p&gt;
&lt;h1&gt;define _Py_END_SUPPRESS_IPH _set_thread_local_invalid_parameter_handler(_Py_old_handler); }&lt;/h1&gt;
&lt;h1&gt;else&lt;/h1&gt;
&lt;h1&gt;define _Py_BEGIN_SUPPRESS_IPH&lt;/h1&gt;
&lt;h1&gt;define _Py_END_SUPPRESS_IPH&lt;/h1&gt;
&lt;h1&gt;endif /&lt;em&gt; _MSC_VER &amp;gt;= 1900 &lt;/em&gt;/&lt;/h1&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;之后在有可能触发 Windows 文件句柄错误的地方，前后分别加上宏&lt;code&gt;_Py_BEGIN_SUPPRESS_IPH&lt;/code&gt; 和 &lt;code&gt;_Py_END_SUPPRESS_IPH&lt;/code&gt;，之后再检查错误码就可以了，需要修改到的地方不少，参考别人的 commit 来修改：
&lt;a href=&#34;https://github.com/kovidgoyal/cpython/commit/a9ec814d466d3c0139d10b69666f88eed10e4940&#34;&gt;在这里&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;结束&lt;/h2&gt;
&lt;p&gt;至此 Python 2.7.11 就可以在 VS2015 里面正常编译和运行了，不过由于 Python 官方是不推荐这样设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;***WARNING***
Building Python 2.7 for Windows using any toolchain that doesn&#39;t link
against MSVCRT90.dll is *unsupported* as the resulting python.exe will
not be able to use precompiled extension modules that do link against
MSVCRT90.dll.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以使用的时候最好要注意一下。&lt;/p&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/py-%E4%BD%BF%E7%94%A8VisualStudio2015%E7%BC%96%E8%AF%91Python2.7.11/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Sat, 02 Dec 2023 05:04:22 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/py-%E4%BD%BF%E7%94%A8VisualStudio2015%E7%BC%96%E8%AF%91Python2.7.11/</guid>
      
    </item>
    
    <item>
      <title>Unity实现体积光照散射 (Volumetric Light Scattering，云隙光)</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;Unity实现体积光照散射 (Volumetric Light Scattering，云隙光)&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;原理&lt;/h2&gt;
&lt;p&gt;Volumetric Light Scattering 的原理可以参考《GPU Gems 3》&lt;a href=&#34;http://http.developer.nvidia.com/GPUGems3/gpugems3_ch13.html&#34;&gt;第13章&lt;/a&gt;，书上有效果图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2014-3-30-unity-light-scattering/goodeffect.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;好看吧，那好，我们的目标就是实现这种效果。&lt;/p&gt;
&lt;p&gt;书上介绍了原理，一条关键的公式是：&lt;/p&gt;
&lt;p&gt;\[ L(s, \theta, \phi) = exposure \times \sum_{i=0}^n decay^i \times weight \times \frac{L( s_i, \theta_i )}{n} \]&lt;/p&gt;
&lt;p&gt;我的理解是，对于图像上的每个像素，光线都有可能照射到，那么对该像素到光源(在投影到图像上的位置)的连线进行采样(对应公式上\(i\))，采样出的结果进行加权平均(对应公式上\(\sum\))并作为该像素的新的颜色值。另外还有关键的后置像素着色器，但是如果只是用那个着色器来对相机渲染的结果进行处理，会产生明显的人工痕迹，有许多的条纹：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2014-3-30-unity-light-scattering/badeffect.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;那么书上的效果是怎么做出来的？其实书上已经给出了答案，可以用一组图来阐述：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2014-3-30-unity-light-scattering/steps.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;图a 就是粗糙的效果，细心地可以看到有许多条纹，并且没有遮挡不够真实，b、c、 d就是为了获得好的效果需要进行的步骤：&lt;/p&gt;
&lt;p&gt;b. 把灯光辐射效果渲染到图像上，并加上物体的遮挡&lt;/p&gt;
&lt;p&gt;c. 对b执行 Volumetric Light Scattering 像素着色器，得到遮挡后的效果&lt;/p&gt;
&lt;p&gt;d. 添加上把真实场景的颜色&lt;/p&gt;
&lt;p&gt;那么下面我们就来一步一步地实现。&lt;/p&gt;
&lt;h2&gt;画遮挡物体&lt;/h2&gt;
&lt;p&gt;在实际的操作中，我先用&lt;code&gt;RenderWithShader&lt;/code&gt;来把会发生遮挡的物体画成黑色，其他地方为白色，因为这需要对每个面片进行渲染，因此对于复杂的场景，会带来一定的性能消耗。场景中的物体有不透明和透明的，我们希望不透明的物体产生完全的光线遮挡，而透明的物体应该产生部分的遮挡，那么我们就需要针对不同RenderType的物体写不同的Shader，RenderType是SubShader的Tag，不清楚的话可以看&lt;a href=&#34;http://docs.unity3d.com/Documentation/Components/SL-SubshaderTags.html&#34;&gt;这里&lt;/a&gt;，写好之后调用：&lt;/p&gt;
&lt;p&gt;```c#
camera.RenderWithShader(objectOcclusionShader, &#34;RenderType&#34;);&lt;/p&gt;
&lt;p&gt;&lt;code&gt;``&lt;/code&gt;RenderWithShader`的第二个参数就是要求根据RenderType来替换Shader，简单来说，同一个物体的替换的Shader的RenderType要跟替换前一致，这样我们就可以为不同的RenderType的物体使用不同的Shader：&lt;/p&gt;
&lt;p&gt;```glsl
Shader &#34;Custom/ObjectOcclusion&#34; 
{
    Properties 
    {
        _MainTex (&#34;Base (RGB)&#34;, 2D) = &#34;white&#34; {}
    }
    SubShader 
    {
        Tags 
        {
            &#34;Queue&#34; = &#34;Geometry&#34;
            &#34;RenderType&#34; = &#34;Opaque&#34;
        }
        LOD 200
        Pass
        {
            Lighting Off
            ZTest Always Cull Off ZWrite Off
            Fog { Mode off }
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include &#34;UnityCG.cginc&#34;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        uniform sampler2D _MainTex;

        v2f_img vert(appdata_img i)
        {
            v2f_img o;
            o.pos = mul (UNITY_MATRIX_MVP, i.vertex);
            return o;
        }

        half4 frag(v2f_img i): COLOR
        {
            return half4(0, 0, 0, 1);
        }
        ENDCG
    }

}
    SubShader 
{
    Tags 
    {
        &#34;Queue&#34; = &#34;Geometry&#34;
        &#34;RenderType&#34; = &#34;Transparent&#34;
    }
    LOD 200
    Pass
    {
        Lighting Off
        ZTest Always Cull Off ZWrite Off
        Fog { Mode off }
        Blend SrcAlpha OneMinusSrcAlpha     // blend for transparent objects
        CGPROGRAM
        #pragma vertex vert
        #pragma fragment frag
        #include &#34;UnityCG.cginc&#34;

        uniform sampler2D _MainTex;

        v2f_img vert(appdata_img i)
        {
            v2f_img o;
            o.pos = mul (UNITY_MATRIX_MVP, i.vertex);
            o.uv = MultiplyUV( UNITY_MATRIX_TEXTURE0, i.texcoord );
            return o;
        }

        half4 frag(v2f_img i): COLOR
        {
            half3 output = (1, 1, 1);
            half4 color = tex2D(_MainTex, i.uv);
            half alpha = color.a;
            return half4(output *(1-alpha), alpha);
        }
        ENDCG
    }

}

FallBack &#34;Diffuse&#34;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;注意不透明和透明物体的Shader间的差别：不透明的物体直接画成黑色；不透明物体需要执行blending，获取物体纹理上的alpha通道，并基于这个alpha进行blending。上面代码只是列举了Opaque和Transparent，另外还有TreeOpaque (Shader跟Opaque一样，只是改变RenderType) ，TreeTransparentCutout (同Transparent) 等。由于指定了RenderType，所以为了全面，需要尽可能穷尽场景中的会发生遮挡的物体，我这里就只有前面提到的四种。结果大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2014-3-30-unity-light-scattering/objectocclusion.png&#34;&gt;&lt;/p&gt;
&lt;h2&gt;结合物体遮挡画光源辐射&lt;/h2&gt;
&lt;p&gt;画光源的辐射不难，需要注意的是需要根据屏幕的大小做一些处理，使得光源的辐射状是圆形的：&lt;/p&gt;
&lt;p&gt;```c#
Shader &#34;Custom/LightRadiate&#34; 
{
    Properties 
    {
        _MainTex (&#34;Base (RGB)&#34;, RECT) = &#34;white&#34; {}
        _LightPos (&#34;Light Pos In Screen Space(XY)&#34;, Vector) = (0, 0, 0, 1)
        _LightRadius (&#34;Light radiation radius (Pixel)&#34;, Float) = 50
    }
    SubShader 
    {
        Tags { &#34;RenderType&#34;=&#34;Opaque&#34; }
        LOD 200
        Pass
        {
            ZTest Always Cull Off ZWrite Off
            Fog { Mode off }
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include &#34;UnityCG.cginc&#34;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        uniform sampler2D _MainTex;
        float4 _LightPos;
        float _LightRadius;

        v2f_img vert(appdata_img i)
        {
            v2f_img o;
            o.pos = mul (UNITY_MATRIX_MVP, i.vertex);
            o.uv = MultiplyUV( UNITY_MATRIX_TEXTURE0, i.texcoord );
            return o;
        }

        half4 frag(v2f_img i): COLOR
        {
            half2 deltaTexCoord = (i.uv - _LightPos.xy) * half2(_ScreenParams.x, _ScreenParams.y);
            float dis = dot(deltaTexCoord, deltaTexCoord);
            const float maxDis = _LightRadius * _LightRadius;
            dis = saturate((maxDis-dis) / maxDis * 0.5);
            return half4(dis, dis, dis, 1) * half4(tex2D(_MainTex, i.uv).rgb, 1);               
        }

        ENDCG
    }
} 
FallBack &#34;Diffuse&#34;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;这个Shader需要输入光源在屏幕上的位置(可以用&lt;code&gt;camera.WorldToViewportPoint&lt;/code&gt;来计算，得到的是uv坐标)，然后根据指定的半径画一个亮度往外衰减的圆，并把结果跟前面得到的物体遮挡图像(放在&lt;code&gt;_MainTex&lt;/code&gt;里)结合，结果大致为：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2014-3-30-unity-light-scattering/light.png&#34;&gt;&lt;/p&gt;
&lt;h2&gt;Light Scattering处理，并结合真实颜色&lt;/h2&gt;
&lt;p&gt;这里就要用到书上提供的Pixel Shader，我的版本：&lt;/p&gt;
&lt;p&gt;```glsl
Shader &#34;Custom/LightScattering&#34; 
{
    Properties 
    {
        _MainTex (&#34;Base (RGB)&#34;, 2D) = &#34;white&#34; {}
        _LightRadTex(&#34;Light Radiate Tex (RGB)&#34;, 2D) = &#34;white&#34; {}
        _LightPos (&#34;Light Pos In Screen Space(XY)&#34;, Vector) = (0, 0, 0, 1)
        _Params(&#34;Density Weight Decay Exposure&#34;, Vector) = (1.0, 1.0, 1.0, 1.0)
    }
    SubShader 
    {
        LOD 200
        Pass
        {
            ZTest Always Cull Off ZWrite Off
            Fog { Mode off }  &lt;br&gt;
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #pragma target 3.0
            #include &#34;UnityCG.cginc&#34;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        uniform sampler2D _MainTex;
        uniform sampler2D _LightRadTex;
        uniform float4 _LightPos;
        uniform float4 _Params;

        v2f_img vert(appdata_img i)
        {
            v2f_img o;
            o.pos = mul (UNITY_MATRIX_MVP, i.vertex);
            o.uv = MultiplyUV( UNITY_MATRIX_TEXTURE0, i.texcoord );
            return o;
        }

        half4 frag(v2f_img i): COLOR
        {   
            // Calculate vector from pixel to light source in screen space
            float2 deltaTexCoord = (i.uv - _LightPos.xy);

            // Divide by number of samples and scale by control factor, here I use 32 samples
            deltaTexCoord *= 1.0f / 32 * _Params.x; //density;

            // Store color.
            half3 color = tex2D(_MainTex, i.uv).rgb;

            // Store initial sample.
            half3 light = tex2D(_LightRadTex, i.uv).rgb;

            // Set up illumination decay factor.
            half illuminationDecay = 1.0f;

            for(int j = 0; j &amp;lt; 31; ++j)
            {
                // Step sample location along ray.
                i.uv -= deltaTexCoord;

                // Retrieve sample at new location.
                half3 sample = tex2D(_LightRadTex, i.uv).rgb;

                // Apply sample attenuation scale/decay factors.
                sample *= illuminationDecay * 0.03125 * _Params.y ; //weight;

                // Accumulate combined light.
                light += sample;

                // Update exponential decay factor.
                illuminationDecay *= _Params.z;             //decay;
            }

            // Output final color with a further scale control factor.
            return half4(color+(light * _Params.w), 1); // exposure
        }

        ENDCG       
    }

} 
FallBack &#34;Diffuse&#34;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;大体上跟书上的一致，只是我的参数需要在程序中传进来，并且结合了真实的颜色图和Light Scattering图，结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;assets/img/2014-3-30-unity-light-scattering/effect.gif&#34;&gt;&lt;/p&gt;
&lt;h2&gt;完整代码&lt;/h2&gt;
&lt;p&gt;代码在&lt;a href=&#34;assets/img/2014-3-30-unity-light-scattering/2014-3-30-unity-light-scattering.zip&#34;&gt;这里&lt;/a&gt;，把&lt;code&gt;cs&lt;/code&gt;脚本添加到相机上。&lt;/p&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/unity-Unity%E5%AE%9E%E7%8E%B0%E4%BD%93%E7%A7%AF%E5%85%89%E7%85%A7%E6%95%A3%E5%B0%84/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Sat, 02 Dec 2023 05:04:22 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/unity-Unity%E5%AE%9E%E7%8E%B0%E4%BD%93%E7%A7%AF%E5%85%89%E7%85%A7%E6%95%A3%E5%B0%84/</guid>
      
    </item>
    
    <item>
      <title>Unity第三人称相机构建(上)</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;Unity第三人称相机构建(上)&#34; /&gt;&lt;/p&gt;
&lt;p&gt;我想在Unity中创建一个第三人称相机，相机的行为参考《魔兽世界》的第三人称相机，具体的需求是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;鼠标左键：控制相机围绕人物旋转，人物不旋转&lt;/li&gt;
&lt;li&gt;鼠标右键：控制相机围绕人物旋转，人物的前方向(Unity中的tranform.forward)相应旋转，人物上方向不变&lt;/li&gt;
&lt;li&gt;鼠标左键旋转后，再右键旋转，角色前方向马上根据左键的旋转做调整，再根据右键旋转，此时等价于两次都是右键旋转&lt;/li&gt;
&lt;li&gt;鼠标滚轮：控制相机远近&lt;/li&gt;
&lt;li&gt;相机不能穿过任何刚性物体&lt;/li&gt;
&lt;li&gt;相机在离开碰撞的刚性物体后，慢慢回到原来的距离上&lt;/li&gt;
&lt;li&gt;如果相机在碰到物体时，使用鼠标滚轮操作相机拉近，相机需要马上反应，此后第6点不再发生&lt;/li&gt;
&lt;li&gt;相机在旋转中碰到地面，停止围绕人物上下旋转，改为围绕自身上下旋转，左右旋转依然是围绕人物&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个需求可以先分成两部分：相机旋转，相机刚性。简单起见，这里先来解决相机旋转的问题，也就是需求的前3点。&lt;/p&gt;
&lt;h2&gt;相机位置表示&lt;/h2&gt;
&lt;p&gt;在正式解决相机操作前，还有一个问题需要解决：相机位置的表示。这可以用多种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相机的世界坐标&lt;/li&gt;
&lt;li&gt;相机相对于人物的坐标&lt;/li&gt;
&lt;li&gt;相机在人物坐标系中的方向和距离&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为在我们的需求中，相机是根据人物位置进行变换的，所以我这里使用第三种方式，而且在控制中相机一直瞄准人物，所以在相机内只需要保存距离信息：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
float curDistance = 5F;&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;相机旋转&lt;/h2&gt;
&lt;p&gt;继续细分相机旋转的行为，可以分成左键旋转和右键旋转，下面我们来一步一步地完成这两个旋转。首先我把相机设为人物的子物体(children)，这样人物的一些基本的移动相机都会自动的跟踪。&lt;/p&gt;
&lt;h3&gt;左键旋转&lt;/h3&gt;
&lt;p&gt;单单看左键旋转，需求很简单：&lt;strong&gt;相机旋转，人物不旋转&lt;/strong&gt;，这就相当于一个观察模型的相机，相机可以任意角度观察中心物体。&lt;/p&gt;
&lt;p&gt;在Unity中获取鼠标左键状态使用语句：&lt;code&gt;Input.GetMouseButton(0)&lt;/code&gt;（注：后面涉及到代码的地方，都是使用C#），明显，右键就是&lt;code&gt;Input.GetMouseButton(1)&lt;/code&gt;。获取鼠标光标的移动位置（可以理解为帧之间光标在X-Y上的偏移量）信息是：&lt;code&gt;Input.GetAxis(&#34;Mouse X&#34;); Input.GetAxis(&#34;Mouse Y&#34;)&lt;/code&gt;。那么我们可以先来获取鼠标左键按下后光标的移动信息：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;csharp
if (Input.GetMouseButton(0))
{
    float x = Input.GetAxis(&#34;Mouse X&#34;);
    float y = Input.GetAxis(&#34;Mouse Y&#34;);
}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;代码很简单，那下面就是关键的地方：如何控制相机来旋转。要理解旋转，这里需要一些关于四元数的知识（网上资料很多，这里就不列举了），四元数重要的一点是它可以很简单地构造旋转，特别是围绕某个向量的旋转，理解四元数后，实现相机围绕人物的旋转就不难了。&lt;/p&gt;
&lt;p&gt;另外还有一点要注意的是，四元数旋转轴只是一个向量，以原点为出发点，如果要以世界坐标系中的某点&lt;code&gt;O&lt;/code&gt;为原点，以该点为出发点的向量&lt;code&gt;V&lt;/code&gt;为旋转轴，就需要进行坐标系的变换，简单地说，就是把需要旋转的点&lt;code&gt;P&lt;/code&gt;变换到，以&lt;code&gt;O&lt;/code&gt;为原点的坐标系中，根据&lt;code&gt;V&lt;/code&gt;旋转，再变换会世界坐标系。根据这些操作，可以写出一个功能函数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
Vector3 MyRotate(Vector3 oldPosition, float angle, Vector3 axis, Vector3 axisPosition)
{
    // 构造一个四元数，以axis为旋转轴，这是在人物坐标系中的旋转
    Quaternion rotation = Quaternion.AngleAxis(angle, axis);
    // 这里做的就是坐标系的变换，把相机的世界坐标变换到人物坐标系下的坐标
    Vector3 offset = oldPosition - axisPosition;
    // 计算旋转并变换回世界坐标系中
    return axisPosition + (rotation * offset);
}&lt;/code&gt;
&lt;code&gt;Quaternion&lt;/code&gt;是Unity中表示四元数的类型，加上之前鼠标左键的检测，就可以完成左键控制相机左右旋转。&lt;/p&gt;
&lt;p&gt;鼠标左右移动控制相机左右旋转的代码就可以直接给出：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
newForward = MyRotate(newForward, x, up, Vector3.zero);&lt;/code&gt;
因为这里只有前向量做旋转，没有涉及到坐标系的转换，所以第四个参数为&lt;code&gt;Vector3.zero&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;控制上下旋转比左右旋转难理解一点，因为此时的旋转轴是会一直变化的(这里假设人物的up一直是Y轴的正方向)。注意的相机也是一直在旋转，并且视点中心一直对准人物，那么相机的右方向(right)就是我们想要围绕着旋转的轴了(把相机right想象成人物的right)，这样理解，那么上下旋转的代码也很简单了：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;csharp
newForward = MyRotate(newForward, -y, transform.right, Vector3.zero);&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;右键旋转&lt;/h3&gt;
&lt;p&gt;做了左键旋转，右键旋转就很简单了，只需要在左右旋转的时候设置人物的前方向：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;csharp
player.forward = Vector3.Normalize(new Vector3(oldForward.x, 0, oldForward.z));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上下旋转跟左键的代码一样。&lt;/p&gt;
&lt;h3&gt;先左键，后右键&lt;/h3&gt;
&lt;p&gt;上面虽然可以分别左键旋转，右键旋转，但是一旦先用左键旋转，再用右键操作的时候，问题就会出现：人物的前方向和相机的前方向不同了！那么相机和人物的正方向就从此分离，实际操作起来很奇怪。那么我们在用右键旋转的时候就要先把人物调整为跟相机的正方向一致：&lt;/p&gt;
&lt;p&gt;```csharp
player.forward = Vector3.Normalize(new Vector3(oldForward.x, 0, oldForward.z));&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;欧拉角万向锁&lt;/h3&gt;
&lt;p&gt;至此，相机的旋转差不多就完成，不过还有一个问题要注意：欧拉角万向锁。原理这里就不细讲，有兴趣的朋友可以自行搜索，针对这里相机的情况，就是当相机上下旋转到跟人物的上方向重合的时候，相机的视角会发生突变。这是因为相机到达人物的头顶或者脚底，相机的上方向会发生突变(因为相机的上方向的Y值一直都要大于零)，所以我们需要限制相机的上下旋转范围，防止发生万向锁。操作很简单，就是限制相机的前方向与人物的上方向的夹角的范围：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
if ((Vector3.Dot(transform.forward, transform.parent.up) &amp;gt;= -0.95F || y &amp;gt; 0) &amp;amp;&amp;amp;
    (Vector3.Dot(transform.forward, transform.parent.up) &amp;lt;= 0.95F || y &amp;lt; 0))&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;完整代码&lt;/h3&gt;
&lt;p&gt;```csharp
// rotate oldPosition around a axis starting at axisPosition
Vector3 MyRotate(Vector3 oldPosition, float angle, Vector3 axis, Vector3 axisPosition)
{
    Quaternion rotation = Quaternion.AngleAxis(angle, axis);
    Vector3 offset = oldPosition - axisPosition;
    return axisPosition + (rotation * offset);
}&lt;/p&gt;
&lt;p&gt;// rotate oldForward, player forward may change when use mouse RB
Vector3 RotateIt(Vector3 oldForward, Vector3 up, Vector3 right, Transform player)
{
    Vector3 newForward = -oldForward;
    // mouse LB RB rotate camera and character
    if (Input.GetMouseButton(0) ^ Input.GetMouseButton(1))
    {
        float x = Input.GetAxis(&#34;Mouse X&#34;) * rotateSpeed;
        float y = Input.GetAxis(&#34;Mouse Y&#34;) * rotateSpeed;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    if (x != 0F)
    {
        newForward = MyRotate(newForward, x, up, Vector3.zero);

        // mouse RB, character rotate together
        if (Input.GetMouseButton(1))
        {
            player.forward = Vector3.Normalize(new Vector3(oldForward.x, 0, 
                oldForward.z));
        }
    }

    if (y != 0F)
    {

        if ((Vector3.Dot(transform.forward, up) &amp;gt;= -0.95F || y &amp;gt; 0)
            &amp;amp;&amp;amp; (Vector3.Dot(transform.forward, up) &amp;lt;= 0.95F || y &amp;lt; 0))
        {
            newForward = MyRotate(newForward, -y, transform.right, Vector3.zero);

        }
    }
}

return -newForward;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/unity-Unity%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0%E7%9B%B8%E6%9C%BA%E6%9E%84%E5%BB%BA%28%E4%B8%8A%29/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Sat, 02 Dec 2023 05:04:22 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/unity-Unity%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0%E7%9B%B8%E6%9C%BA%E6%9E%84%E5%BB%BA%28%E4%B8%8A%29/</guid>
      
    </item>
    
    <item>
      <title>Unity第三人称相机构建(下)</title>
      
      
      
      
      <description>&lt;p&gt;&lt;meta property=&#34;og:title&#34; content=&#34;Unity第三人称相机构建(下)&#34; /&gt;&lt;/p&gt;
&lt;p&gt;上一集讲完了&lt;a href=&#34;unity-Unity第三人称相机构建(上).md&#34;&gt;相机的旋转&lt;/a&gt;，那么现在我们要解决的问题是相机的刚性，要怎么做呢？&lt;/p&gt;
&lt;h2&gt;相机刚性&lt;/h2&gt;
&lt;p&gt;回顾之前提的需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;鼠标滚轮：控制相机远近&lt;/li&gt;
&lt;li&gt;相机不能穿过任何刚性物体&lt;/li&gt;
&lt;li&gt;相机在离开碰撞的刚性物体后，慢慢回到原来的距离上&lt;/li&gt;
&lt;li&gt;如果相机在碰到刚体时，使用鼠标滚轮操作相机拉近，相机需要马上反应，此后第6点不再发生；碰撞地面后不能进行缩放操作&lt;/li&gt;
&lt;li&gt;相机在旋转中碰到地面，停止围绕人物上下旋转，改为围绕自身上下旋转，左右旋转依然是围绕人物&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这几点的意思是：相机在碰到刚性物体时，会被迫拉近跟人物的距离，那么我们想要相机在离开的时候，可以慢慢地回到原来的距离；但是如果在自动拉近距离后，用滚轮再手动拉近，说明相机离开碰撞的物体，那么这个拉近的距离就是相机的实际距离。下面我们来一点一点的解这些需求。&lt;/p&gt;
&lt;h2&gt;滚轮控制&lt;/h2&gt;
&lt;p&gt;鼠标滚轮控制很简单，只需要知道获取滚轮信息是&lt;code&gt;Input.GetAxis(&#34;Mouse ScrollWheel&#34;)&lt;/code&gt;，并设定距离的最大值最小值就ok：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
public float mouseWheelSensitivity = 2; // control zoom speed
public int mouseWheelZoomMin = 2;       // min distance
public int mouseWheelZoomMax = 10;      // max distance
float curDistance = 5F;
float zoom = Input.GetAxis(&#34;Mouse ScrollWheel&#34;);
if (zoom != 0F)
{
    float distance = curDistance;
    distance -= zoom * mouseWheelSensitivity;
    distance = Math.Min(mouseWheelZoomMax, Math.Max(mouseWheelZoomMin, distance));
    return distance;
}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里&lt;code&gt;playerTransform&lt;/code&gt;指向人物。&lt;/p&gt;
&lt;h2&gt;不能穿过任何刚性物体&lt;/h2&gt;
&lt;p&gt;这需要检测相机跟刚体的接触，有一个函数可以实现这个功能：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
static bool Raycast(Ray ray, RaycastHit hitInfo, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;具体用法参考Unity的&lt;a href=&#34;http://docs.unity3d.com/Documentation/ScriptReference/Physics.Raycast.html&#34;&gt;Reference&lt;/a&gt;，我们可以这样实现碰撞的检测：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
RaycastHit hitInfo;
if (Physics.Raycast(playerTransform.position, desiredPosition - playerTransform.position,
    out hitInfo, (playerTransform.position - desiredPosition).magnitude, 1))
{
    curDistance = hitInfo.distance;
}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;targetPosition&lt;/code&gt;就是碰撞的位置，把相机的位置设到碰撞的位置就可以。&lt;/p&gt;
&lt;h2&gt;离开刚体后，慢慢回到原来的距离上&lt;/h2&gt;
&lt;p&gt;要完成这个功能，首先要分别记录下相机应该处于的距离(&lt;code&gt;desiredDistance&lt;/code&gt;)和目前距离(&lt;code&gt;curDistance&lt;/code&gt;)，把滚轮操作的结果用&lt;code&gt;desiredDistance&lt;/code&gt;先存起来，再根据碰撞计算物体的新距离；
在检测到相机离开刚体，或者碰撞到更远的刚体时候，不能直接把碰撞的位置赋值给相机，需要用一个移动速度来向新的距离移动。先来获取新的距离：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
float newDistance = desiredDistance;
RaycastHit hitInfo;
if (Physics.Raycast(playerTransform.position, desiredPosition - playerTransform.position,
    out hitInfo, (playerTransform.position - desiredPosition).magnitude, 1))
{
    newDistance = hitInfo.distance;
}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;那么怎么判断相机正在向更远的距离移动呢？可以用&lt;code&gt;newDistances&lt;/code&gt;和当前的距离进行比较：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
// 向更近的距离移动
if (newDistance &amp;lt; curDistance)
{
    curDistance = newDistance;
}
// 向更远的距离移动
else if(newDistance &amp;gt; curDistance)
{
}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;那么判断到向更远距离移动后，就很直观了，直接加个速度来移动：&lt;/p&gt;
&lt;p&gt;```c#
curDistance = Math.Min(curDistance + Time.deltaTime * autoZoomOutSpeed, newDistance);&lt;/p&gt;
&lt;p&gt;```
相机的大致行为我们已经完成了，还有一些细节需要处理。&lt;/p&gt;
&lt;h2&gt;碰到刚体后滚轮拉近，地面不缩放&lt;/h2&gt;
&lt;p&gt;这里有两个要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;碰到刚体后只能拉近，不能拉远&lt;/li&gt;
&lt;li&gt;碰到地面后不能缩放&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先用变量来保存相机的碰撞状态：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
bool isHitGround = false;       // 表示是否碰撞地面
bool isHitObject = false;       // 表示是否碰撞刚体(除开地面)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在判断滚轮缩放的时候加上条件判断：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
if (zoom != 0F &amp;amp;&amp;amp; (!isHitGround || (isHitObject &amp;amp;&amp;amp; zoom &amp;gt; 0F)) )
{
    // calculate distance
}&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;碰到地面绕自身上下旋转&lt;/h2&gt;
&lt;p&gt;这个功能实现起来有点麻烦，需要因为这时候我们之前假设相机一直对准人物不成立了，这时分成两个向量：&lt;strong&gt;相机自身的朝向(&lt;code&gt;desireForward&lt;/code&gt;)&lt;/strong&gt;和&lt;strong&gt;人物到相机的方向(&lt;code&gt;cameraToPlayer&lt;/code&gt;)&lt;/strong&gt;，分别计算这两个向量的值，前者就决定相机的朝向，后者就决定相机的位置。为了方便，把&lt;a href=&#34;unity-Unity第三人称相机构建(上).md&#34;&gt;上一集&lt;/a&gt;的旋转函数拆成X旋转(&lt;code&gt;RotateX&lt;/code&gt;)和Y旋转(&lt;code&gt;RotateY&lt;/code&gt;)，那么在计算&lt;code&gt;cameraToPlayer&lt;/code&gt;的&lt;code&gt;RotateY&lt;/code&gt;时加上条件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
if ((!isHitGround) || 
    (isHitGround &amp;amp;&amp;amp; transform.forward.y &amp;lt;= cameraToPlayer.y &amp;amp;&amp;amp; yAngle &amp;gt; 0))
{
    cameraToPlayer = RotateY(cameraToPlayer, playerTransform.up, 
        transform.right, yAngle);
}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个条件有两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有碰到地面&lt;/li&gt;
&lt;li&gt;碰到地面，但是准备离开地面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后用&lt;code&gt;cameraToPlayer&lt;/code&gt;计算相机的位置：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
transform.position = playerTransform.position - cameraToPlayer * curDistance;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;并且在有需要的时候(也就是碰到地面)计算相机的朝向：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c#
if (!isHitGround)
{
    transform.LookAt(playerTransform);
}
else
{
    desireForward = RotateX(desireForward, playerTransform.up, xAngle);
    desireForward = RotateY(desireForward, playerTransform.up, transform.right, yAngle);
    transform.forward = desireForward;
}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样相机的行为我们都实现了。&lt;/p&gt;
&lt;p&gt;完整代码：&lt;/p&gt;
&lt;p&gt;```c#
using UnityEngine;
using System;
using System.Collections;&lt;/p&gt;
&lt;p&gt;// use a forward vector and distance to describe the camera position
public class MyThirdPersonCamera : MonoBehaviour {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private Transform playerTransform;      // reference to player

public float mouseWheelSensitivity = 3; // control zoom speed
public int mouseWheelZoomMin = 2;       // min distance
public int mouseWheelZoomMax = 10;      // max distance

public float rotateSpeed = 5F;          // speed of rotate around player    
public float autoZoomOutSpeed = 10F;    // speed of auto zoom out, camera will auto zoom out 
                                        // to pre distance when stop colliding object
float curDistance = 5F;                 // distance to player
float desiredDistance = 5F;             // distance should be      
bool isHitGround = false;               // hit ground flag
bool isHitObject = false;               // hit object(except ground) flag

// Use this for initialization
void Awake ()
{
    playerTransform = transform.parent;
}

void Start () 
{
    transform.position = playerTransform.position - playerTransform.forward 
        * curDistance;
    transform.LookAt(playerTransform);

}

// Update is called once per frame
void Update () 
{
    Vector3 cameraToPlayer = 
        (playerTransform.position - transform.position).normalized;

    Vector3 desireForward = transform.forward;

    // get new distance of zoom
    desiredDistance = ZoomIt(curDistance, desiredDistance);

    float xAngle, yAngle;
    bool isRightDown;

    // get mouse LB, RB status
    GetMouseButtonStatus(out xAngle, out yAngle, out isRightDown);

    // rotate camera by x-axis movement
    cameraToPlayer = RotateX(cameraToPlayer, playerTransform.up, xAngle);

    // if RB on, change player orientation
    if (isRightDown)
    {
        playerTransform.forward = Vector3.Normalize(new Vector3(cameraToPlayer.
            x, 0, cameraToPlayer.z));
    }

    // rotate camera by y-axis, if camera is not on ground or camera is going to leave ground
    if ((!isHitGround) 
    || (isHitGround &amp;amp;&amp;amp; transform.forward.y &amp;lt;= cameraToPlayer.y &amp;amp;&amp;amp; yAngle &amp;gt; 0))
    {
        cameraToPlayer = RotateY(cameraToPlayer, playerTransform.up, transform.
            right, yAngle);
    }

    // detect collision of camera to rigid body, get the distance camera should be
    float newDistance = DealWithCollision(playerTransform.position, 
        -cameraToPlayer, desiredDistance,ref isHitGround, ref isHitObject);

    // check the distance
    if (newDistance &amp;lt;= curDistance)
    {
        curDistance = newDistance;
    }
    else
    {
        // now moving to farther position, use a speed to move it
        curDistance = Math.Min(curDistance + Time.deltaTime * autoZoomOutSpeed, 
            newDistance);
    }

    // now calculate the position
    transform.position = playerTransform.position - cameraToPlayer * curDistance;

    // calculate the camera forward, if on ground, camera will rotate on self.Space
    if (!isHitGround)
    {
        transform.LookAt(playerTransform);
    }
    else
    {
        desireForward = RotateX(desireForward, playerTransform.up, xAngle);
        desireForward = RotateY(desireForward, playerTransform.up, transform.
            right, yAngle);
        transform.forward = desireForward;
    }
}

// zoom in and zoom out
float ZoomIt(float curDistance, float desiredDistance)
{
    float zoom = Input.GetAxis(&#34;Mouse ScrollWheel&#34;);

    //  zoom when hit rigid body and zoom in, or not on ground
    if (zoom != 0F &amp;amp;&amp;amp; (!isHitGround || (isHitObject &amp;amp;&amp;amp; zoom &amp;gt; 0F)) )
    {
        float distance = curDistance;

        distance -= zoom * mouseWheelSensitivity;
        distance = Math.Min(mouseWheelZoomMax, Math.Max(mouseWheelZoomMin, distance));

        return distance;
    }
    return desiredDistance;
}

// rotate oldPosition around a axis starting at axisPosition
Vector3 RotateAroundAxis(Vector3 point, float angle, Vector3 axis, Vector3 axisPosition)
{
    Quaternion rotation = Quaternion.AngleAxis(angle, axis);
    Vector3 offset = point - axisPosition;
    return axisPosition + (rotation * offset);
}

void GetMouseButtonStatus(out float x, out float y, out bool isRightDown)
{
    x = y = 0F;
    isRightDown = false;
    if (Input.GetMouseButton(0) ^ Input.GetMouseButton(1))
    {
        x = Input.GetAxis(&#34;Mouse X&#34;) * rotateSpeed;
        y = -Input.GetAxis(&#34;Mouse Y&#34;) * rotateSpeed;
        if (Input.GetMouseButton(1))
        {
            isRightDown = true;
        }
    }
}

// rotate vectorP2C(player to camera) around up while mouse x is on, return true if do rotate
Vector3 RotateX(Vector3 vectorP2C, Vector3 up, float angle)
{
    Vector3 newVector = vectorP2C;
    if (angle != 0F)
    {
        newVector = RotateAroundAxis(newVector, angle, up, Vector3.zero);
    }
    return newVector;
}

// rotate vectorP2C(player to camera) around right while mouse y is on, return true is do rotate
Vector3 RotateY(Vector3 vectorP2C, Vector3 up, Vector3 right, float angle)
{
    Vector3 newVector = vectorP2C;
    if (angle != 0F)
    {
        if ((Vector3.Dot(vectorP2C, up) &amp;gt;= -0.99F || angle &amp;lt; 0)
            &amp;amp;&amp;amp; (Vector3.Dot(vectorP2C, up) &amp;lt;= 0.99F || angle &amp;gt; 0))
        {
            newVector = RotateAroundAxis(newVector, angle, right, Vector3.zero);
        }
    }
    return newVector;
}

// return distance if no collision, else return distance to rigid body
float DealWithCollision(Vector3 origin, Vector3 direction, float distance, 
    ref bool ishitGround, ref bool ishitObject)
{
    // collision detection
    RaycastHit hitInfo;
    float newDistance = distance;
    if (Physics.Raycast(playerTransform.position, direction, out hitInfo, desiredDistance, 1))
    {
        if (hitInfo.collider is TerrainCollider)
        {
            ishitGround = true;
            ishitObject = false;
        }
        else
        {
            ishitObject = true;
            ishitGround = false;
        }
        newDistance = hitInfo.distance;
    }
    else
    {
        ishitGround = ishitObject = false;
    }

    return newDistance;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
```&lt;/p&gt;
&lt;p&gt;--8&amp;lt;-- &#34;footer.md&#34;&lt;/p&gt;</description>
      <link>https://wiki.disenone.site/unity-Unity%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0%E7%9B%B8%E6%9C%BA%E6%9E%84%E5%BB%BA%28%E4%B8%8B%29/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link>
      <pubDate>Sat, 02 Dec 2023 05:04:22 +0000</pubDate>
      <source url="https://wiki.disenone.site/feed_rss_updated.xml">Disenone's Wiki</source>
      
      <guid isPermaLink="true">https://wiki.disenone.site/unity-Unity%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0%E7%9B%B8%E6%9C%BA%E6%9E%84%E5%BB%BA%28%E4%B8%8B%29/</guid>
      
    </item>
    
  </channel>
</rss>